<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Why's Blog]]></title>
  <subtitle><![CDATA[从明天起，做一个幸福的人。面朝汪海，春暖花开。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.callmewhy.com/"/>
  <updated>2015-12-07T10:00:43.000Z</updated>
  <id>http://blog.callmewhy.com/</id>
  
  <author>
    <name><![CDATA[CallMeWhy]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[CGI FastCGI WSGI 学习笔记]]></title>
    <link href="http://blog.callmewhy.com/2015/12/07/what-is-wsgi-and-cgi/"/>
    <id>http://blog.callmewhy.com/2015/12/07/what-is-wsgi-and-cgi/</id>
    <published>2015-12-07T02:11:50.000Z</published>
    <updated>2015-12-07T10:00:43.000Z</updated>
    <content type="html"><![CDATA[<p>最近用 Flask 给以前写的 OpenCV 代码配置一个入口供前端调用，翻文档的时候发现部署服务器和在本地运行与我一开始想的并不太一样。于是花点时间了解并整理了一下，补补基础课。</p>
<h2 id="CGI">CGI</h2><h3 id="概念">概念</h3><p>CGI 是一种服务器和后端可执行程序之间的交互标准，它描述了『如何通过环境变量来传递请求信息』。</p>
<h3 id="原理">原理</h3><p>最原始的服务器，简单到就是访问文件目录，每次的请求都是请求加载目录下的文件。比如文档放在 <code>/usr/local/apache/htdocs</code> 目录下，访问 <a href="http://example.com/index.html" target="_blank" rel="external">http://example.com/index.html</a> 其实就是请求 <code>/usr/local/apache/htdocs/index.html</code> 文件。</p>
<p>CGI 通过服务器脚本（或者二进制文件），扩展了这个基础的『访问过程』。它利用程序的标准输入输出流，完成 HTTP 通信。每次请求的文本以标准输入流的形式进入服务器端的 CGI 程序，创建进程并执行，然后将运行结果通过进程的标准输出流输出作为响应。</p>
<p>比如 <code>/usr/local/apache/htdocs/cgi-bin</code> 是我们的 CGI 目录，当请求了 CGI 目录里的文件的时候（比如访问 <a href="http://example.com/cgi-bin/printenv.pl" target="_blank" rel="external">http://example.com/cgi-bin/printenv.pl</a> ），服务器并不会返回这个文件，而会运行这个程序，然后将生成的内容返回给客户端。所以理论上，任何有输入输出能力的语言都可以用来写 CGI。</p>
<p>CGI 的工作原理如图：</p>
<p><img src="http://ww1.sinaimg.cn/large/61d238c7jw1eyr31id7kqj20z40cwjtn.jpg" alt=""></p>
<p>解释一下，上面图中的 CGI 指的是 CGI 程序。CGI 是一种协议标准，CGI 程序是实现了 CGI 标准的程序，确保输入输出合法，这是两个相关但不同的概念。</p>
<h3 id="优点">优点</h3><p>CGI 的优点也就是它的作用了。CGI 程序提供了很多静态网页无法实现的功能，比如加载数据、数据运算等等。早期的动态网页基本都是基于 CGI 实现的。</p>
<h3 id="缺点">缺点</h3><p>在 CGI 协议下，解析器的反复加载是性能低下的主要原因。每个发送到服务器的请求，都需要经过『启动进程、处理请求、结束进程』三个步骤，所以当访问量增大时，系统资源的开销也会增大，导致服务器性能下降甚至服务中断。</p>
<p>更惨的是，这种『一个请求一个进程』的模式意味着没有『状态』可言，导致很多资源无法复用，比如连接数据库、内存缓存等等。</p>
<h2 id="FastCGI">FastCGI</h2><h3 id="概念-1">概念</h3><p>FastCGI 是 CGI 的增强版本，用于减少 Server 与 CGI 应用之间的交互开销，从而使 Server 可以同时处理更多的请求。</p>
<h3 id="原理-1">原理</h3><p>和 CGI 的 <code>fork-and-execute</code> 模式不同的是，FastCGI 以 <code>Daemon</code> 的形式运行，在初始化的时候会启动一个 <code>FastCGI Server</code> 然后长驻内存，处理一系列的请求。</p>
<p>Nginx+FastCGI 的工作流程是这样的：</p>
<ul>
<li>初始化 FastCGI 进程管理器，启动主进程和多个 CGI 子进程。主进程主要是管理子进程，同时还需要监听端口（例如9000端口）；子进程则是处于等待连接的状态。</li>
<li>当请求到达服务器时，Nginx 通过 location 指令，将请求（例如以 <code>php</code> 为后缀的文件）分配到指定端口（例如9000端口）来处理。</li>
<li>FastCGI 进程管理器选择并连接到一个子进程，服务器将环境变量和标准输入发送给子进程。</li>
<li>子进程接受请求并完成处理后，将标准输出和错误信息从同一连接返回给服务器。</li>
<li>子进程关闭连接，继续等待下一个请求。</li>
</ul>
<p>工作原理如图：</p>
<p><img src="http://ww4.sinaimg.cn/large/61d238c7jw1eyr2zrcgzrj218e0c4ju1.jpg" alt=""></p>
<p>上图中的 <code>wrapper</code> 可以理解为用于启动另一个程序的程序，因为 Nginx 本身不支持对外部程序的直接调用或者解析，所以外部程序必须通过 FastCGI 接口来调用。</p>
<h3 id="优点-1">优点</h3><p>除了继承 CGI 原有的优点之外， FastCGI 还有以下特点：</p>
<ul>
<li>业务分离：FastCGI 后端和 Web Server 运行在不同的进程中，后端的故障不会导致 Web Server 停止服务。</li>
<li>分布式计算：由于 FastCGI 服务器是可以独立运行的，所以 FastCGI 程序可以在服务器以外的主机上执行，并且接受来自其它服务器的请求。</li>
<li>多个可扩展角色：在 FastCGI 中，程序被赋予明确的角色，例如响应器角色、认证器角色、过滤器角色等等。</li>
</ul>
<h2 id="WSGI">WSGI</h2><h3 id="概念-2">概念</h3><p>WSGI 是 Web 服务器和 Web 应用程序之间的一种简单而通用的接口，最初是为 Python 量身定做。</p>
<h3 id="原理-2">原理</h3><p>WSGI 属于接口规范，从层级上来讲要比 CGI/FastCGI 高级。</p>
<p>WSGI 中存在两种角色：接受请求的 Server 和处理请求的 Application，它们底层是通过 FastCGI 沟通的。</p>
<p>WSGI 的工作流程如下：</p>
<ul>
<li>客户端发起 HTTP 请求到 Nginx</li>
<li>Nginx 转成 FastCGI 请求发送到 WSGI 的 Server（例如 flup）</li>
<li>WSGI 的 Server 通过 app(environ, start_response) 函数调用 Application</li>
<li>Application 再根据 environ 里的内容，对用户代码中注册的路由和响应函数进行调用。</li>
</ul>
<h4 id="Server">Server</h4><p>Server 端从规定的输入中获取 Request 数据，然后把环境变量（environ）和回调函数（start_response）传给 Application 。</p>
<h4 id="Application">Application</h4><p>Application 会处理请求并通过回调函数将结果返回给 Server。</p>
<p>和 Serve 对应，一个标准的 Application 接受两个参数：</p>
<ul>
<li>environ：一个包含所有 HTTP 请求信息的 dict 对象</li>
<li>start_response：一个发送 HTTP 响应的函数</li>
</ul>
<h4 id="Middleware">Middleware</h4><p>Middleware 是一个比较特殊的存在，它是夹在二者之间的，对于 Server 端而言它是个 Application ，而对于 Application 而言它就是 Server 端。</p>
<p>它可以实现以下功能：</p>
<ul>
<li>重写环境变量，根据目标 URL，将请求消息路由到不同的应用对象。</li>
<li>允许在一个进程中同时运行多个应用程序或应用框架。</li>
<li>负载均衡和远程处理，通过在网络上转发请求和响应消息。</li>
<li>进行内容后处理，例如应用 XSLT 样式表。</li>
</ul>
<h3 id="优点-2">优点</h3><p>WSGI 将请求的工作通过异步回调进行拆解，可以很方便的在一个线程空间里同时处理多个请求。</p>
<p>另外，方便进行负载均衡和请求转发，不会造成后端应用阻塞。</p>
<h2 id="其他">其他</h2><p>其他一些相关的名词一起梳理一下：</p>
<ul>
<li>uWSGI：一个应用服务器，实现了 uwsgi 、FastCGI 和 HTTP 等协议。</li>
<li>uwsgi：uWSGI 服务器的自有协议，用于定义传输信息的类型。</li>
<li>flup：WSGI 中的 Server 的一种实现</li>
<li>Spawn-FCGI：Python 中的管理 FastCGI 进程管理器。</li>
<li>PHP-CGI： PHP 自带的 FastCGI 管理器。</li>
<li>PHP-FPM：PHP 的 Fastcgi 进程管理器。</li>
</ul>
<p>OK 就是这样。对这方面不是很了解，如果有错误还望及时指出，不胜感激：）</p>
<hr>
<p>参考文献：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Common_Gateway_Interface" target="_blank" rel="external">Common Gateway Interface</a></li>
<li><a href="https://en.wikipedia.org/wiki/Simple_Common_Gateway_Interface" target="_blank" rel="external">Simple Common Gateway Interface</a></li>
<li><a href="https://en.wikipedia.org/wiki/FastCGI" target="_blank" rel="external">FastCGI</a></li>
<li><a href="https://en.wikipedia.org/wiki/Web_Server_Gateway_Interface" target="_blank" rel="external">Web Server Gateway Interface</a></li>
<li><a href="http://taobaofed.org/blog/2015/11/24/nodejs-php-process-manager/" target="_blank" rel="external">浅谈 Node.js 和 PHP 进程管理</a></li>
<li><a href="http://www.2cto.com/os/201111/111318.html" target="_blank" rel="external">Linux PHP 的运行模式与其相关名词术语</a></li>
<li><a href="http://stackoverflow.com/questions/2089271/i-never-really-understood-what-is-cgi" target="_blank" rel="external">I never really understood: what is CGI?</a></li>
<li><a href="http://www.fastcgi.com/drupal/" target="_blank" rel="external">FastCGI/drupal</a></li>
<li><a href="http://zires.info/2011/01/fcgi-scgi-wsgi-cgi/" target="_blank" rel="external">fcgi，scgi，wsgi，cgi</a></li>
<li><a href="http://www.zhihu.com/question/19998865" target="_blank" rel="external">如何理解 CGI WSGI</a></li>
<li><a href="http://www.cgi101.com/learn/" target="_blank" rel="external">CGI Programming 101: Learn CGI Today!</a></li>
<li><a href="http://tools.ietf.org/html/rfc3875" target="_blank" rel="external">RFC3875: The Common Gateway Interface (CGI) Version 1.1</a></li>
<li><a href="http://www.fastcgi.com/devkit/doc/fcgi-spec.html" target="_blank" rel="external">FastCGI Specification</a></li>
<li><a href="http://ifxoxo.com/cgi_fastcgi.html" target="_blank" rel="external">CGI、FastCGI 区别</a></li>
<li><a href="http://book.51cto.com/art/201202/314840.htm" target="_blank" rel="external">Nginx+FastCGI 运行原理</a></li>
<li><a href="http://yansu.org/2014/02/15/apache-and-nginx.html" target="_blank" rel="external">从运行原理及使用场景看 Apache 和 Nginx</a></li>
<li><a href="http://blog.51reboot.com/cgi-fastcgi-wsgi/" target="_blank" rel="external">漫谈 CGI FastCGI WSGI</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0333/" target="_blank" rel="external">PEP 0333</a></li>
<li><a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432012393132788f71e0edad4676a3f76ac7776f3a16000" target="_blank" rel="external">WSGI 接口</a></li>
<li><a href="http://yansu.org/2013/05/19/what-is-wsgi.html" target="_blank" rel="external">WSGI 学习</a></li>
<li><a href="http://nichol.as/benchmark-of-python-web-servers" target="_blank" rel="external">Benchmark of Python WSGI Servers</a></li>
<li><a href="http://cramer.io/2013/06/27/serving-python-web-applications/" target="_blank" rel="external">You Should Be Using Nginx + UWSGI</a></li>
<li><a href="http://stackoverflow.com/questions/1747266/is-there-a-speed-difference-between-wsgi-and-fcgi" target="_blank" rel="external">Is there a speed difference between WSGI and FCGI?</a></li>
<li><a href="http://www.itopers.com/?p=586" target="_blank" rel="external">区分 wsgi、uWSGI、uwsgi、php-fpm、CGI、FastCGI 的概念</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[充分了解当年原始社会的举步维艰，才能体会如今小康阶段的来之不易。]]>
    
    </summary>
    
      <category term="Web" scheme="http://blog.callmewhy.com/tags/Web/"/>
    
      <category term="学习笔记" scheme="http://blog.callmewhy.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[阅读周记]]></title>
    <link href="http://blog.callmewhy.com/2015/11/28/a-note-a-day/"/>
    <id>http://blog.callmewhy.com/2015/11/28/a-note-a-day/</id>
    <published>2015-11-28T05:27:29.000Z</published>
    <updated>2015-12-13T09:30:20.000Z</updated>
    <content type="html"><![CDATA[<p>最近开始每天花点时间阅读 Pocket 里收藏的文章，已经1300+的未读文章啦，要抓紧时间看起来了。</p>
<p>做一些简单的记录，以后需要的时候方便翻阅。</p>
<p>以下内容通过 <a href="http://why-wechat.avosapps.com/pocket/" target="_blank" rel="external">汪海的实验室 - Pocket 周记生成器</a> 自动生成，完整源码托管在 <a href="https://github.com/callmewhy/why-wechat" target="_blank" rel="external">why-wechat</a> 上。</p>
<h1 id="2015-12-13">2015-12-13</h1><h2 id="前端">前端</h2><ul>
<li><a href="http://www.2ality.com/2011/06/ecmascript.html" target="_blank" rel="external">A JavaScript glossary: ECMAScript, TC39, etc.</a></li>
<li><a href="http://taobaofed.org/blog/2015/10/29/deep-into-node-1/" target="_blank" rel="external">Node.js 探秘（一）- 初识单线程的 Node.js</a></li>
<li><a href="http://taobaofed.org/blog/2015/12/03/deep-into-node-2/" target="_blank" rel="external">Node.js 探秘(二) - 求异存同</a></li>
<li><a href="http://justineo.github.io/singles/writing-modular-js/" target="_blank" rel="external">使用 AMD、CommonJS 及 ES Harmony 编写模块化的 JavaScript</a></li>
<li><a href="http://www.infoq.com/cn/articles/front-end-engineering-and-performance-optimization-part2" target="_blank" rel="external">前端工程精粹（二）：静态资源管理与模板框架</a></li>
<li><a href="http://www.infoq.com/cn/articles/front-end-engineering-and-performance-optimization-part1" target="_blank" rel="external">前端工程精粹（一）：静态资源版本更新与缓存</a></li>
<li><a href="http://youmightnotneedjquery.com/" target="_blank" rel="external">You might not need jQuery</a></li>
<li><a href="http://isux.tencent.com/h5active.html" target="_blank" rel="external">H5动效的常见制作手法</a></li>
<li><a href="http://f2e.souche.com/blog/shuo-shuo-da-jia-du-shou-xi-de-wang-ye-dong-hua-ji-zhu/" target="_blank" rel="external">说说大家都熟悉的网页动画技术</a></li>
<li><a href="http://segmentfault.com/a/1190000004086946" target="_blank" rel="external">【译】Web 权限验证方法说明</a></li>
</ul>
<h2 id="语言">语言</h2><ul>
<li><a href="http://swifter.tips/options/" target="_blank" rel="external">Options</a></li>
<li><a href="http://swift.gg/2015/12/04/the-fibonacci-sequencetype/" target="_blank" rel="external">斐波那契数列型-从数学角度学习 Swift 序列</a></li>
<li><a href="https://www.hackingwithswift.com/swift2" target="_blank" rel="external">What’s new in Swift 2</a></li>
<li><a href="http://taobaofed.org/blog/2015/12/07/some-thing-about-random/" target="_blank" rel="external">Math.random() 二三事</a></li>
<li><a href="http://swift.gg/2015/12/07/a-handful-of-swift-style-rules-swiftlang/" target="_blank" rel="external">几个 Swift 代码规范</a></li>
</ul>
<h2 id="iOS">iOS</h2><ul>
<li><a href="http://swift.gg/2015/12/03/expandable-table-view/" target="_blank" rel="external">如何在 iOS 中实现一个可展开的 Table View</a></li>
<li><a href="https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52" target="_blank" rel="external">iOS Architecture Patterns</a></li>
<li><a href="http://www.altair21.com/156.html" target="_blank" rel="external">Xcode7 免证书真机调试</a></li>
<li><a href="https://github.com/nixzhu/dev-blog/blob/master/2015-12-09-nscache.md" target="_blank" rel="external">NSCache 源码分析</a></li>
</ul>
<h2 id="其他">其他</h2><ul>
<li><a href="http://blog.zhowkev.in/2015/12/11/xiang-yao-da-zao-ji-zhi-de-yong-hu-ti-yan-yong-appsee/" target="_blank" rel="external">想要打造极致的用户体验？用 AppSee</a></li>
<li><a href="http://segmentfault.com/a/1190000004120281" target="_blank" rel="external">揭秘高效协作工具背后的技术架构</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&amp;mid=431264183&amp;idx=1&amp;sn=de4598dc3b6aca5a980d994cf21a2188&amp;scene=0" target="_blank" rel="external">如何成为移动端架构师</a></li>
<li><a href="http://www.infoq.com/cn/articles/wechat-banma-dmp" target="_blank" rel="external">微信斑马系统：微信朋友圈广告背后的利器</a></li>
<li><a href="http://www.infoq.com/cn/news/2015/12/coding-interview-codeinsight" target="_blank" rel="external">Coding 全栈工程师杜万：打造最好用的在线代码阅读工具 CodeInsight</a></li>
</ul>
<h2 id="后端">后端</h2><ul>
<li><a href="http://www.cnblogs.com/Ray-liang/p/4837850.html" target="_blank" rel="external">Flask + Gunicorn + Nginx 部署</a></li>
<li><a href="http://taobaofed.org/blog/2015/11/24/nodejs-php-process-manager/" target="_blank" rel="external">浅谈 Node.js 和 PHP 进程管理</a></li>
<li><a href="http://www.cnblogs.com/Ray-liang/p/4173923.html" target="_blank" rel="external">阿里云部署 Flask + WSGI + Nginx 详解</a></li>
<li><a href="https://www.mgenware.com/blog/?p=2960" target="_blank" rel="external">Express 4/Node.js: 服务器加入更人性化的错误Log</a></li>
<li><a href="http://racksburg.com/choosing-an-http-status-code/" target="_blank" rel="external">Choosing an HTTP Status Code — Stop Making It Hard</a></li>
<li><a href="https://blog.coding.net/blog/React-server-rendering" target="_blank" rel="external">玩转 React 服务器端渲染</a></li>
<li><a href="http://www.jianshu.com/p/be9dd421fb8d" target="_blank" rel="external">python web 部署：nginx + gunicorn + supervisor + flask 部署笔记</a></li>
<li><a href="http://seanlook.com/2015/05/17/nginx-location-rewrite/" target="_blank" rel="external">Nginx 配置 location 总结及 rewrite规则写法</a></li>
</ul>
<h1 id="2015-12-06">2015-12-06</h1><h2 id="前端-1">前端</h2><ul>
<li><a href="https://github.com/fouber/blog/issues/10" target="_blank" rel="external">前端工程–基础篇</a></li>
<li><a href="https://github.com/fouber/blog/issues/7" target="_blank" rel="external">如何进行前端自动化测试</a></li>
<li><a href="https://github.com/fouber/blog/issues/6" target="_blank" rel="external">大公司里怎样开发和部署前端代码</a></li>
<li><a href="https://github.com/fouber/blog/issues/5" target="_blank" rel="external">资源定位中md5戳的计算过程</a></li>
<li><a href="https://github.com/fouber/blog/issues/4" target="_blank" rel="external">前端工程与模块化框架</a></li>
<li><a href="https://github.com/fouber/blog/issues/3" target="_blank" rel="external">前端工程与性能优化</a></li>
<li><a href="https://github.com/fouber/blog/issues/2" target="_blank" rel="external">前端开发体系建设日记</a></li>
<li><a href="https://github.com/fouber/blog/issues/1" target="_blank" rel="external">浅谈前端集成解决方案</a></li>
<li><a href="https://github.com/camsong/blog/issues/3" target="_blank" rel="external">Immutable 详解及 React 中实践</a></li>
<li><a href="http://coderlmn.github.io/frontEndCourse/nomoreJSF.html" target="_blank" rel="external">别再用 JS 框架了</a></li>
<li><a href="https://github.com/xufei/blog/issues/19" target="_blank" rel="external">2015前端组件化框架之路</a></li>
<li><a href="https://github.com/amfe/article/issues/13" target="_blank" rel="external">对无线电商动态化方案的思考（一）</a></li>
<li><a href="https://github.com/amfe/article/issues/14" target="_blank" rel="external">对无线电商动态化方案的思考（二）</a></li>
<li><a href="https://github.com/amfe/article/issues/15" target="_blank" rel="external">对无线电商动态化方案的思考（三）</a></li>
<li><a href="https://github.com/coderLMN/framework-free-single-page-app/blob/master/README.md" target="_blank" rel="external">开发无框架单页面应用</a></li>
<li><a href="https://medium.com/google-developers/tradeoffs-in-server-side-and-client-side-rendering-14dad8d4ff8b" target="_blank" rel="external">Tradeoffs in server side and client side rendering</a></li>
<li><a href="http://www.onebigfluke.com/2015/01/experimentally-verified-why-client-side.html" target="_blank" rel="external">Experimentally verified: “Why client-side templating is wrong”</a></li>
<li><a href="http://www.toobug.net/article/what_is_shadow_dom.html" target="_blank" rel="external">【译】什么是 Shadow Dom</a></li>
<li><a href="http://www.w3cplus.com/preprocessor/sass-basics-control-directives-expressions.html" target="_blank" rel="external">Sass 的表达式和控制命令</a></li>
<li><a href="http://www.w3cplus.com/preprocessor/sass-basics-operators.html" target="_blank" rel="external">Sass 操作符</a></li>
<li><a href="https://github.com/dyygtfx/html-best-practices" target="_blank" rel="external">HTML 最佳实践</a></li>
<li><a href="http://reactjsnews.com/structuring-react-projects/" target="_blank" rel="external">How to Structure a React Project</a></li>
<li><a href="http://taobaofed.org/blog/2015/12/02/waterfall-analyze/" target="_blank" rel="external">页面白屏与瀑布流分析方法</a></li>
<li><a href="http://segmentfault.com/a/1190000003985909" target="_blank" rel="external">你真的会使用 Chrome 开发者工具吗（一）</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzA5NTM2MTEzNw==&amp;mid=415251623&amp;idx=2&amp;sn=761daff0204528d8e656a389c8d0cd0e" target="_blank" rel="external">揭密 Google 秒开技术：如何让网站瞬间加载完毕</a></li>
<li><a href="http://gold.xitu.io/entry/564b1d5a60b294bc127e83f9" target="_blank" rel="external">我们真的缺前端工程师吗</a></li>
<li><a href="http://zhuanlan.zhihu.com/purerender/20346379" target="_blank" rel="external">React 源码剖析系列 － 不可思议的 react diff</a></li>
<li><a href="http://kingdompan.github.io/md/promise_fetch.html" target="_blank" rel="external">Promise 及 Fetch 源码解析</a></li>
<li><a href="http://www.zhihu.com/question/31863128/answer/54025549" target="_blank" rel="external">在你的日常开发中遇到过哪些常用布局是无法用纯 CSS 实现的？</a></li>
<li><a href="https://github.com/tmallfe/tmallfe.github.io/issues/28?from=timeline&amp;isappinstalled=0#issuecomment-160526476" target="_blank" rel="external">天猫双11前端分享系列（四）：大规模 Node.js 应用</a></li>
<li><a href="http://web.jobbole.com/84343/" target="_blank" rel="external">对抗拖库 —- Web 前端慢加密</a></li>
<li><a href="http://taobaofed.org/blog/2015/11/30/animation-bone/" target="_blank" rel="external">骨骼动画原理与前端实现浅谈</a></li>
</ul>
<h2 id="后端-1">后端</h2><ul>
<li><a href="http://alinode.aliyun.com/blog/14" target="_blank" rel="external">V8 垃圾回收</a></li>
</ul>
<h2 id="运维">运维</h2><ul>
<li><a href="http://www.infoq.com/cn/articles/mogujie-11-11-private-cloud-platform-docker-application" target="_blank" rel="external">蘑菇街11.11：私有云平台的 Docker 应用实践</a></li>
</ul>
<h2 id="语言-1">语言</h2><ul>
<li><a href="https://github.com/nixzhu/dev-blog/blob/master/2015-12-04-swift-package-manager.md" target="_blank" rel="external">Swift 包管理器</a></li>
<li><a href="http://andrewliu.in/2015/11/14/Python%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/" target="_blank" rel="external">Python 奇技淫巧</a></li>
</ul>
<h2 id="其他-1">其他</h2><ul>
<li><a href="http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=401389590&amp;idx=1&amp;sn=63c1d56ebea7a128c6b560c4562aa2a8#rd" target="_blank" rel="external">浅析时间序列用户生命周期的聚类方法</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&amp;mid=425829999&amp;idx=1&amp;sn=f7e06bf52bddf9d8c332ea4f21d02ddb" target="_blank" rel="external">递归的故事（下）</a></li>
<li><a href="http://www.infoq.com/cn/news/2015/11/twitter-ab-test" target="_blank" rel="external">Twitter A/B测试技术概览</a></li>
<li><a href="http://tech.meituan.com/meituan-search-rank.html" target="_blank" rel="external">美团O2O排序解决方案—-线上篇</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTk0MzM1Ng==&amp;mid=400488756&amp;idx=2&amp;sn=6bc2c515576bd96ce2cbc72f8b43936e" target="_blank" rel="external">【诸葛干货】爬虫入门-基础理论篇（下篇）</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTk0MzM1Ng==&amp;mid=400349360&amp;idx=1&amp;sn=77a2430e5777675c2041cb0bd82191d4" target="_blank" rel="external">【诸葛干货】一看就明白的爬虫入门-基础理论篇（上篇）</a></li>
<li><a href="http://www.zhihu.com/question/37478564/answer/72262835" target="_blank" rel="external">Facebook 是如何在短时间内做出 mark safe 这个功能的</a></li>
<li><a href="http://isux.tencent.com/introduction-of-webp.html" target="_blank" rel="external">WebP 探寻之路</a></li>
<li><a href="http://isux.tencent.com/20741.html" target="_blank" rel="external">如何低调有内涵地利用站长工具做决策</a></li>
</ul>
<h1 id="2015-11-29">2015-11-29</h1><h2 id="前端-2">前端</h2><ul>
<li><a href="http://www.csdn.net/article/2015-11-16/2826218" target="_blank" rel="external">美团吕伟：借助后端算法 大幅提升前端编译性能</a></li>
<li><a href="http://zhuanlan.zhihu.com/FrontendMagazine/20359205" target="_blank" rel="external">HTML 处理利器 PostHTML 入门教程</a></li>
<li><a href="http://www.barretlee.com/blog/2015/11/16/lazyload-component/" target="_blank" rel="external">图片脚本懒加载 - Lazyload</a></li>
<li><a href="https://github.com/xiangpaopao/blog/issues/7" target="_blank" rel="external">移动端Web上传图片实践</a></li>
<li><a href="http://yalishizhude.github.io/2015/11/13/jquery2angular/" target="_blank" rel="external">从JQuery到Angular的一次改版 // 亚里士朱德的博客</a></li>
<li><a href="http://www.zhihu.com/question/37503039/answer/72388747" target="_blank" rel="external">如何在大型 Web 应用中保持数据的同步更新？</a></li>
<li><a href="http://zhuanlan.zhihu.com/FrontendMagazine/20341776" target="_blank" rel="external">如何开发并维护一个开源的 React 组件？</a></li>
<li><a href="http://www.html5cn.org/article-9031-1.html" target="_blank" rel="external">移动端Web App自适应布局探索与总结</a></li>
<li><a href="http://segmentfault.com/a/1190000004018047" target="_blank" rel="external">【翻译】 JS的递归与TCO尾调用优化</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html" target="_blank" rel="external">尾调用优化</a></li>
<li><a href="http://segmentfault.com/a/1190000004029518" target="_blank" rel="external">HTML5矢量实现文件上传进度条</a></li>
<li><a href="http://jimmysu.logdown.com/posts/254007-do-not-use-bootstrap-like-this" target="_blank" rel="external">Bootstrap 的 10 個錯誤用法</a></li>
<li><a href="http://www.w3ctech.com/topic/1588" target="_blank" rel="external">别再丢用户与应用程序的状态了，赶紧用 Page Visibility 吧</a></li>
<li><a href="http://www.bootcss.com/article/variable-and-function-hoisting-in-javascript/" target="_blank" rel="external">JavaScript 中对变量和函数声明的”提前（hoist）”</a></li>
<li><a href="https://github.com/amfe/article/issues/21" target="_blank" rel="external">15年双11手淘前端技术巡演 - H5性能最佳实践</a></li>
</ul>
<h2 id="后端-2">后端</h2><ul>
<li><a href="http://idlelife.org/archives/808" target="_blank" rel="external">passport.js学习笔记</a></li>
<li><a href="https://segmentfault.com/a/1190000004026112" target="_blank" rel="external">【译】Express在生产环境下的最佳实践 - 性能和可靠性</a></li>
<li><a href="http://segmentfault.com/a/1190000003996618" target="_blank" rel="external">【译】Express在生产环境下的最佳实践 - 安全性</a></li>
<li><a href="http://www.zhihu.com/question/37379084/answer/71894611" target="_blank" rel="external">Node.js 在双十一中有哪些应用，表现如何？</a></li>
<li><a href="http://taobaofed.org/blog/2015/11/03/nodejs-cluster/" target="_blank" rel="external">当我们谈论 cluster 时我们在谈论什么(上)</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&amp;mid=400480069&amp;idx=1&amp;sn=4119397d0e3b0444f04d25f76ecdfbe3" target="_blank" rel="external">如何应对并发(2) - 请求合并及异步处理</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&amp;mid=400470606&amp;idx=1&amp;sn=eff5350f80190ad6e32659f434aac970" target="_blank" rel="external">如何应对并发(1) - 关于数据索引</a></li>
</ul>
<h2 id="语言-2">语言</h2><ul>
<li><a href="http://codingpy.com/article/python-ecosystem-introduction/" target="_blank" rel="external">一篇文章入门Python生态系统</a></li>
<li><a href="http://mazingyu.gitcafe.io/2015/11/17/wherewhereused/" target="_blank" rel="external">Swift where 关键词用法大全</a></li>
</ul>
<h2 id="运维-1">运维</h2><ul>
<li><a href="http://tech.meituan.com/docker_introduction.html" target="_blank" rel="external">Docker系列之一：入门介绍</a></li>
</ul>
<h2 id="其他-2">其他</h2><ul>
<li><a href="http://mux.alimama.com/posts/1454" target="_blank" rel="external">无线端两种弹窗广告方案的A/B test ƕ</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&amp;mid=420893082&amp;idx=1&amp;sn=a89faf1e77b3501dd107dd2a28a41c20" target="_blank" rel="external">时间复杂度的故事</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&amp;mid=421159372&amp;idx=1&amp;sn=0d9e1cd278917334a261b09d1b2fc995" target="_blank" rel="external">递归的故事（上）</a></li>
</ul>
<h2 id="架构">架构</h2><ul>
<li><a href="http://www.infoq.com/cn/news/2015/11/ifttt-data-infrastructure" target="_blank" rel="external">解密 IFTTT 的数据架构</a></li>
</ul>
<h2 id="算法">算法</h2><ul>
<li><a href="http://segmentfault.com/a/1190000004022134" target="_blank" rel="external">协同过滤算法</a></li>
</ul>
<hr>
<h1 id="公众号">公众号</h1><p>阅读周记会定期推送到公众号上：</p>
<p><img src="http://ww1.sinaimg.cn/large/61d238c7gw1eyhvaky06dj20by0byt9k.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[整理每天的 Pocket 阅读记录。]]>
    
    </summary>
    
      <category term="Reading" scheme="http://blog.callmewhy.com/tags/Reading/"/>
    
      <category term="记录笔记" scheme="http://blog.callmewhy.com/categories/%E8%AE%B0%E5%BD%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用 Tesseract 识别字符]]></title>
    <link href="http://blog.callmewhy.com/2015/11/16/use-tesseract-for-ocr/"/>
    <id>http://blog.callmewhy.com/2015/11/16/use-tesseract-for-ocr/</id>
    <published>2015-11-16T07:53:47.000Z</published>
    <updated>2015-11-20T11:53:52.000Z</updated>
    <content type="html"><![CDATA[<p>最近在做一个微信公众账号，很多地方需要用到字符识别(<a href="https://en.wikipedia.org/wiki/Optical_character_recognition" target="_blank" rel="external">OCR</a>)。补了补一些基础知识之后，决定基于 <a href="https://github.com/tesseract-ocr/tesseract/" target="_blank" rel="external">Tesseract</a> 进行开发。</p>
<h2 id="Tesseract"><a href="https://github.com/tesseract-ocr/tesseract" target="_blank" rel="external">Tesseract</a></h2><h3 id="Install">Install</h3><p>训练过程是在 Mac 上完成，然后把训练结果扔到 Docker 上。所以需要安装 Mac 和 Linux 两个环境下的 Tesseract 。</p>
<p>首先是 Mac 下，<a href="https://github.com/Homebrew/homebrew/blob/master/Library/Formula/tesseract.rb" target="_blank" rel="external">homebrew</a> 以前需要手动编译，最近终于加上了 <code>--with-training-tools</code> 的选项，各种训练工具都已经打包搞好，只需要：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install tessreact --with-training-tools</span><br></pre></td></tr></table></figure>
<p>然后 Linux 下，通过 Docker 配置了 Ubuntu@14.04 ，安装也很方便：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install tesseract-ocr</span><br></pre></td></tr></table></figure>
<h3 id="Test">Test</h3><p>安装完成之后，在没有训练之前先先试一下效果如何。比如下面这张：</p>
<p><img src="http://ww4.sinaimg.cn/large/61d238c7jw1ey2y6v8zfzj209q02qglo.jpg" alt=""></p>
<p>通过 Tesseract 识别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tesseract input.jpg result</span><br></pre></td></tr></table></figure>
<p>识别结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">08F1916711&#8216;</span><br></pre></td></tr></table></figure>
<p>嗯大体上数字识别还是准确的，但是对于一些相近的字符比较容易出现识别错误，例如图中的 G 被识别成了 0。原因是默认会使用英语进行识别，而英语字体集中并没有我们想要识别的字体。</p>
<p>这时候我们需要训练自己的字体集，在后面的例子中，我们以 <code>Mourney</code> 字体为例。（并没有这个字体，这只是我们项目的行动代号）</p>
<h3 id="Training">Training</h3><p>准备好用来训练的图片文件和用来测试效果的图片文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#9500;&#9472;&#9472; mon.mourney.exp0.tif&#10;&#9492;&#9472;&#9472; test.jpg</span><br></pre></td></tr></table></figure>
<p>首先，用 <code>tessreact</code> 命令识别原图片，制作 box 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tesseract mon.mourney.exp0.tif mon.mourney.exp0 batch.nochop makebox</span><br></pre></td></tr></table></figure>
<p>会发现目录中多了 <code>mon.mourney.exp0.box</code> 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#9500;&#9472;&#9472; mon.mourney.exp0.box&#10;&#9500;&#9472;&#9472; mon.mourney.exp0.tif&#10;&#9492;&#9472;&#9472; input.jpg</span><br></pre></td></tr></table></figure>
<p>box 文件的内容很简单，就是告诉 Tesseract 这张图里有哪些字符，以及它们的位置，相当于标记自定义字体的包围盒。文件内容大概是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">G 32 1384 49 1411 0&#10;8 56 1384 74 1412 0&#10;F 83 1382 103 1413 0</span><br></pre></td></tr></table></figure>
<p>文中数字分别对应图片中文字『左下右上』的坐标。</p>
<p>然后下载 <a href="http://vietocr.sourceforge.net/training.html" target="_blank" rel="external">jTessBoxEditor</a> ，这是一个第三方的开源编辑器，可以直接编辑 box 文件。点击 Box Editor ，然后打开原图，就可以在可视化界面里编辑调整 box 的位置。</p>
<p>编辑完成后，执行以下命令（具体每条命令的含义请参见<a href="https://github.com/tesseract-ocr/tesseract/wiki/TrainingTesseract" target="_blank" rel="external">官方文档</a>）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#34;font 0 0 0 0 0&#34; &#62; font_properties&#10;tesseract mon.mourney.exp0.tif mon.mourney.exp0 nobatch box.train&#10;unicharset_extractor mon.mourney.exp0.box&#10;mftraining -F font_properties -U unicharset -O mon.unicharset mon.mourney.exp0.tr&#10;cntraining mon.mourney.exp0.tr&#10;&#10;mv normproto mon.normproto&#10;mv inttemp mon.inttemp  &#10;mv pffmtable mon.pffmtable  &#10;mv shapetable mon.shapetable  &#10;&#10;combine_tessdata mon.</span><br></pre></td></tr></table></figure>
<p>执行后注意一下最后输出的 1、3、4、5、13 行，需要确定 Offset 值不是 -1 。训练完成。</p>
<p>此时的文件目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#9500;&#9472;&#9472; mon.inttemp&#10;&#9500;&#9472;&#9472; mon.mourney.exp0.box&#10;&#9500;&#9472;&#9472; mon.mourney.exp0.tif&#10;&#9500;&#9472;&#9472; mon.mourney.exp0.tr&#10;&#9500;&#9472;&#9472; mon.mourney.exp0.txt&#10;&#9500;&#9472;&#9472; mon.normproto&#10;&#9500;&#9472;&#9472; mon.pffmtable&#10;&#9500;&#9472;&#9472; mon.shapetable&#10;&#9500;&#9472;&#9472; mon.traineddata&#10;&#9500;&#9472;&#9472; mon.unicharset&#10;&#9500;&#9472;&#9472; font_properties&#10;&#9500;&#9472;&#9472; test.jpg&#10;&#9492;&#9472;&#9472; unicharset</span><br></pre></td></tr></table></figure>
<p>生成的 <code>mon.traineddata</code> 就是我们需要的训练结果，把它移到 Tesseract 的 <code>tessdata</code> 目录下，然后再次用 <code>tesseract</code> 命令识别，不过这次指定语言为我们定义的 <code>mon</code> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tesseract -l mon test.jpg result</span><br></pre></td></tr></table></figure>
<p>这时会发现，已经能够准确的识别出结果了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#62; Test  cat result.txt&#10;G8F19167111</span><br></pre></td></tr></table></figure>
<p>好吧并没有，多识别了一个 1 。原始图片还是需要做一些简单的处理，比如做一下腐蚀、膨胀、二值化等等。</p>
<h2 id="NodeJS">NodeJS</h2><p>接下来就是写个后端接口来调用这个 <code>tesseract</code> 方法。有了 <a href="https://github.com/expressjs/multer" target="_blank" rel="external">multer</a> 这个库来处理文件上传，以及 <a href="https://github.com/desmondmorris/node-tesseract" target="_blank" rel="external">node-tesseract</a> 这个库来封装 <code>tesseract</code> 命令，代码十分简单：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> multer = <span class="built_in">require</span>(<span class="string">'multer'</span>)</span><br><span class="line"><span class="keyword">var</span> upload = multer(&#123;</span><br><span class="line">  dest: <span class="string">'uploads/'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> tesseract = <span class="built_in">require</span>(<span class="string">'node-tesseract'</span>);</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/mourney'</span>, upload.single(<span class="string">'image'</span>), <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> image = req.file;</span><br><span class="line">  <span class="keyword">var</span> options = &#123;</span><br><span class="line">    l: <span class="string">'mon'</span>,</span><br><span class="line">    psm: <span class="number">7</span></span><br><span class="line">  &#125;;</span><br><span class="line">  tesseract.process(image.path, options, <span class="function"><span class="keyword">function</span>(<span class="params">err, text</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(text);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.send(text);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> host = server.address().address;</span><br><span class="line">  <span class="keyword">var</span> port = server.address().port;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'listening at http://%s:%s'</span>, host, port);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>部署到服务器上，用 <code>Paw</code> 测试一下：</p>
<p><img src="http://ww4.sinaimg.cn/large/61d238c7gw1ey5c36wusej21iw0e0di5.jpg" alt=""></p>
<p>成功，后端初步调试完成。</p>
<hr>
<p>参考文献：</p>
<ul>
<li><a href="https://github.com/tesseract-ocr/tesseract/wiki/TrainingTesseract" target="_blank" rel="external">Training Tesseract</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[调教调教，调教出属于你的文字识别系统。]]>
    
    </summary>
    
      <category term="OCR" scheme="http://blog.callmewhy.com/tags/OCR/"/>
    
      <category term="开发笔记" scheme="http://blog.callmewhy.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用 Babel + React + Webpack 搭建 Web 应用]]></title>
    <link href="http://blog.callmewhy.com/2015/11/09/use-react-with-babel-and-webpack/"/>
    <id>http://blog.callmewhy.com/2015/11/09/use-react-with-babel-and-webpack/</id>
    <published>2015-11-09T11:32:22.000Z</published>
    <updated>2015-11-10T06:34:27.000Z</updated>
    <content type="html"><![CDATA[<p>同志们，我又来闲扯前端了。掐指一算不务正业地折腾前端已经有将近一个月的时间了，这段时间零零散散做了三四个简单的小项目，尝试了 Grunt Gulp Webpack 之类的项目构建工具，折腾了 AngularJS ReactJS VueJS 之类的前端框架，对比了 Jade Mustache Ejs 之类的模板引擎，把玩了 Sass Less Stylus 之类的预处理器，还借助着 Babel 体验了一把 ES6+ ，心中一直有这样一种感觉：还是 iOS 好啊！（别问我为什么试这么多东西，挑一个用不就行了吗？是啊，但是不试一遍怎么知道挑哪个好Q_Q</p>
<p>简单整理一下最新的一个项目：一个用于微信传播的 HTML5 小活动，源码在活动上线之后会开源到 Github 上。</p>
<h2 id="Yeoman"><a href="https://github.com/yeoman/yo" target="_blank" rel="external">Yeoman</a></h2><p>Yeoman 在<a href="http://blog.callmewhy.com/2015/09/18/use-yeoman-with-angular-and-gulp/#Yeoman">前面的文章</a>中介绍过，是一款脚手架工具。新项目使用的是 <a href="https://github.com/yeoman/generator-gulp-webapp" target="_blank" rel="external">generator-gulp-webapp</a> 这个模板，在 <a href="https://github.com/yeoman/generator-gulp-webapp/tree/master/docs/recipes" target="_blank" rel="external">recipes</a> 里介绍了一些常用的扩展方案，主要是 gulp 相关的一些配置。</p>
<h2 id="Babel"><a href="http://babeljs.io/" target="_blank" rel="external">Babel</a></h2><p>Babel 是一款 JavaScript 转译器，它能够将 ES6+ 的代码转译为主流浏览器支持的 ES5 代码，而且还可以通过插件加载 JSX 的语法。</p>
<p>可以在 Babel 的 <a href="http://babeljs.io/repl/" target="_blank" rel="external">repl</a> 里体验一下它的神奇之处。输入一段 ES6 的内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add = (a, b) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>转换之后的结果是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="pi">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>这样就可以无忧无虑的直接使用 ES6+ 开发了 Web 项目了。</p>
<h2 id="Webpack">Webpack</h2><p>Webpack 是一款模块打包工具，在 Webpack 当中，所有的资源都被当作是模块，各种资源通过各种 loader 加载，比如 babel 就提供了 <a href="https://github.com/babel/babel-loader" target="_blank" rel="external">babel-loader</a> 插件，用于在 Webpack 中加载 babel 编译 js 文件。</p>
<p>在项目里用 npm 安装好依赖，添加一个 Webpack 任务，设置 JSX 和 Babel 的相关配置，就可以在项目里使用 React 和 Babel 了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'webpack'</span>, cb =&gt; &#123;</span><br><span class="line">  webpack(&#123;</span><br><span class="line">    entry: <span class="string">'./app/scripts/app.jsx'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">      path: path.resolve(__dirname, <span class="string">'.tmp/scripts/'</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">      extensions: [<span class="string">''</span>, <span class="string">'.js'</span>, <span class="string">'.jsx'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">      loaders: [&#123;</span><br><span class="line">        test: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">        loader: <span class="string">'babel'</span>,</span><br><span class="line">        query: &#123;</span><br><span class="line">          presets: [<span class="string">'react'</span>, <span class="string">'es2015'</span>, <span class="string">'stage-0'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, (err, stats) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> gutil.PluginError(<span class="string">'webpack'</span>, err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(stats.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    cb();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="React"><a href="https://github.com/facebook/react" target="_blank" rel="external">React</a></h2><p>React 是 Facebook 开源的一款前端框架，专注于 View 层，提供数据驱动、可组合的视图组件。结合 JSX 语法写出来大概是这个样子的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> CommentBox = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">className</span>=<span class="value">"commentBox"</span>&gt;</span></span><br><span class="line">        Hello, world! I am a CommentBox.</span><br><span class="line">      <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    )</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">React.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="title">CommentBox</span> /&gt;</span>,</span><br><span class="line">  document.getElementById('content')</span><br><span class="line">);</span></span><br></pre></td></tr></table></figure>
<p>从语法角度来讲，我是不太能接受 React 这种设计的。渲染函数包含了大量业务逻辑，看着像是程序片断而不能直观提供视觉呈现。虽然强调了『模块化』的概念，可以通过封装各种单位模块然后逐渐拼接成完整项目，但是，就是感觉不够优雅。</p>
<p>不过学习的过程中了解了不少有趣的思想，比如单向数据流、Virtual DOM，还有通过 props 和 state 强调『状态管理』，减少可变因素，这些都让我受益匪浅。</p>
<p>React 一般会配合 <a href="http://facebook.github.io/flux/" target="_blank" rel="external">FLUX</a> 使用，官方提供了 <a href="http://facebook.github.io/flux/docs/todo-list.html" target="_blank" rel="external">Todo List</a> 的例子可以作为入门参考。FLUX 的结构大概是这样的：</p>
<p><img src="http://ww1.sinaimg.cn/large/61d238c7jw1exvtvfsmfcj21040joadn.jpg" alt=""></p>
<p>看起来很美好，不过只是照着做了边教程，还没在项目里试过，等到后面有项目可以体验一下。</p>
<h2 id="Next">Next</h2><p>以上内容相当于最近的个人学习小结，匆匆忙忙一笔带过，只是做个记录。</p>
<p>感觉前端是一个很有趣的领域，每个人都在尝试用各种姿势造着各种轮子，接下来的时间不再折腾别人的轮子了，花点时间补补基础知识。</p>
<p>然而。</p>
<p><img src="http://ww4.sinaimg.cn/large/61d238c7gw1ettf9re22uj20fu08owf3.jpg" alt=""></p>
<p>教练，我想写 Swift 。</p>
<hr>
<p>参考资料：</p>
<ul>
<li><a href="http://www.infoq.com/cn/news/2014/05/facebook-mvc-flux" target="_blank" rel="external">Facebook：MVC 不适合大规模应用，改用 Flux</a></li>
<li><a href="http://www.alloyteam.com/2015/10/react-virtual-analysis-of-the-dom/" target="_blank" rel="external">React 虚拟 DOM 浅析</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[在我写完这篇文章的时候，文章里介绍的工具可能已经被淘汰了。]]>
    
    </summary>
    
      <category term="React" scheme="http://blog.callmewhy.com/tags/React/"/>
    
      <category term="开发笔记" scheme="http://blog.callmewhy.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[通过 Moya+RxSwift+Argo 完成网络请求]]></title>
    <link href="http://blog.callmewhy.com/2015/11/01/moya-rxswift-argo-lets-go/"/>
    <id>http://blog.callmewhy.com/2015/11/01/moya-rxswift-argo-lets-go/</id>
    <published>2015-11-01T03:27:59.000Z</published>
    <updated>2015-11-01T13:25:03.000Z</updated>
    <content type="html"><![CDATA[<p>最近在新项目中尝试使用 Moya+RxSwift+Argo 进行网络请求和解析，感觉还阔以，再来给大家安利一波。</p>
<h2 id="Moya"><a href="https://github.com/Moya/Moya" target="_blank" rel="external">Moya</a></h2><p><code>Moya</code> 是一个基于 <code>Alamofire</code> 的更高层网络请求封装，深入学习请参见官方文档：<a href="https://github.com/Moya/Moya/tree/master/docs" target="_blank" rel="external">Moya/Docs</a>。</p>
<p>使用 <code>Moya</code> 之后网络请求一般长了这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">provider.request(.<span class="type">UserProfile</span>(<span class="string">"ashfurrow"</span>)) &#123; (data, statusCode, response, error) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> data = data &#123;</span><br><span class="line">        <span class="comment">// do something with the data</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Moya</code> 提供了很多不错的特性，其中我感觉最棒的是 <code>stub</code> ，配合 <code>sampleData</code> 分分钟就完成了单元测试：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> provider = <span class="type">MoyaProvider</span>&lt;<span class="type">ItemAPI</span>&gt;(stubClosure: <span class="type">MoyaProvider</span>.<span class="type">ImmediatelyStub</span>)</span><br></pre></td></tr></table></figure>
<p>注意这里的 <code>MoyaProvider.ImmediatelyStub</code> ，我原以为它是个枚举类型，看了 <code>MoyaProvider</code> 定义发现这里应该传个 <code>closure</code> ，看了 <code>ImmediatelyStub</code> 的定义发现原来它是个类方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">StubClosure</span> = <span class="type">Target</span> -&gt; <span class="type">Moya</span>.<span class="type">StubBehavior</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">public</span> <span class="keyword">init</span>(stubClosure: <span class="type">StubClosure</span> = <span class="type">MoyaProvider</span>.<span class="type">NeverStub</span>, ...) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">ImmediatelyStub</span>(<span class="title">_</span>: <span class="title">Target</span>) -&gt; <span class="title">Moya</span>.<span class="title">StubBehavior</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> .<span class="type">Immediate</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想打印每次请求的参数，在组装 <code>endpoint</code> 的时候打印即可：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="func"><span class="keyword">func</span> <span class="title">endpointMapping</span><span class="generics">&lt;Target: MoyaTarget&gt;</span><span class="params">(target: Target)</span></span> -&gt; <span class="type">Endpoint</span>&lt;<span class="type">Target</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> parameters = target.parameters &#123;</span><br><span class="line">        log.verbose(<span class="string">"<span class="subst">\(parameters)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">MoyaProvider</span>.<span class="type">DefaultEndpointMapping</span>(target)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> provider = <span class="type">RxMoyaProvider</span>&lt;<span class="type">ItemAPI</span>&gt;(endpointClosure: endpointMapping)</span><br></pre></td></tr></table></figure>
<h2 id="RxSwift"><a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="external">RxSwift</a></h2><p><code>RxSwift</code> 前面强行<a href="http://blog.callmewhy.com/tags/RxSwift/">安利</a>过两波，在此不再赘述啦，<code>Moya</code> 本身提供了 <code>RxSwift</code> 扩展，可以无缝衔接 <code>RxSwift</code> 和 <code>ReactiveCocoa</code> ，于是打开方式变成了这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> provider = <span class="type">RxMoyaProvider</span>&lt;<span class="type">ItemAPI</span>&gt;()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ItemAPI</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">getNewItems</span><span class="params">(completion: [Item] -&gt; Void)</span></span> &#123;</span><br><span class="line">        disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">        provider</span><br><span class="line">            .request(.<span class="type">GetItems</span>())</span><br><span class="line">            .subscribe(</span><br><span class="line">                onNext: &#123; items <span class="keyword">in</span></span><br><span class="line">                    completion(items)</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">            .addDisposableTo(disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Moya</code> 的核心开发者、同时也是 <a href="https://github.com/Artsy/" target="_blank" rel="external">Artsy</a> 的成员：<a href="https://github.com/ashfurrow" target="_blank" rel="external">Ash Furrow</a>， 在 AltConf 做过一次 《<a href="https://realm.io/news/altconf-ash-furrow-functional-reactive-swift/" target="_blank" rel="external">Functional Reactive Awesomeness With Swift</a>》 的分享，推荐大家看一下，很可爱的！</p>
<h2 id="Argo"><a href="https://github.com/thoughtbot/argo" target="_blank" rel="external">Argo</a></h2><p><code>Argo</code> 是 <code>thoughtbot</code> 开源的函数式 <code>JSON</code> 解析转换库。说到 <code>thoughtbot</code> 就不得不提他司关于 <code>JSON</code> 解析质量很高的一系列文章：</p>
<ul>
<li><a href="https://robots.thoughtbot.com/efficient-json-in-swift-with-functional-concepts-and-generics" target="_blank" rel="external">Efficient JSON in Swift with Functional Concepts and Generics</a></li>
<li><a href="https://robots.thoughtbot.com/real-world-json-parsing-with-swift" target="_blank" rel="external">Real World JSON Parsing with Swift</a></li>
<li><a href="https://robots.thoughtbot.com/parsing-embedded-json-and-arrays-in-swift" target="_blank" rel="external">Parsing Embedded JSON and Arrays in Swift</a></li>
<li><a href="https://robots.thoughtbot.com/functional-swift-for-dealing-with-optional-values" target="_blank" rel="external">Functional Swift for Dealing with Optional Values</a></li>
</ul>
<p><code>Argo</code> 基本上就是沿着这些文章的思路写出来的，相关的库还有 <a href="https://github.com/thoughtbot/Runes" target="_blank" rel="external">Runes</a> 和 <a href="https://github.com/thoughtbot/Curry" target="_blank" rel="external">Curry</a>。</p>
<p>使用 <code>Argo</code> 做 <code>JSON</code> 解析很有意思，大致长这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> url: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Item</span>: <span class="title">Decodable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">decode</span><span class="params">(j: JSON)</span></span> -&gt; <span class="type">Decoded</span>&lt;<span class="type">Item</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> curry(<span class="type">Item</span>.<span class="keyword">init</span>)</span><br><span class="line">            &lt;^&gt; j &lt;| <span class="string">"id"</span></span><br><span class="line">            &lt;*&gt; j &lt;| <span class="string">"url"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于这其中各种符号的缘由，在几篇博客中都有讲解，还是挺有意思滴。</p>
<h2 id="All">All</h2><p>说完这三者，如何把它们串起来呢？<a href="https://github.com/artsy/Emergence" target="_blank" rel="external">Emergence</a> 中的 <a href="https://github.com/artsy/Emergence/blob/master/Emergence/Contexts/Networking/Observable%2BNetworking.swift" target="_blank" rel="external">Observable/Networking</a> 给了我们答案。稍微整理后如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ORMError</span> : <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">ORMNoRepresentor</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">ORMNotSuccessfulHTTP</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">ORMNoData</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">ORMCouldNotMakeObjectError</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="func"><span class="keyword">func</span> <span class="title">resultFromJSON</span><span class="generics">&lt;T: Decodable&gt;</span><span class="params">(object:[String: AnyObject], classType: T.<span class="keyword">Type</span>)</span></span> -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">        <span class="keyword">let</span> decoded = classType.decode(<span class="type">JSON</span>.parse(object))</span><br><span class="line">        <span class="keyword">switch</span> decoded &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Success</span>(<span class="keyword">let</span> result):</span><br><span class="line">            <span class="keyword">return</span> result <span class="keyword">as</span>? <span class="type">T</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Failure</span>(<span class="keyword">let</span> error):</span><br><span class="line">            log.error(<span class="string">"<span class="subst">\(error)</span>"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">mapSuccessfulHTTPToObject</span><span class="generics">&lt;T: Decodable&gt;</span><span class="params">(type: T.<span class="keyword">Type</span>)</span></span> -&gt; <span class="type">Observable</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span> &#123; representor <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> response = representor <span class="keyword">as</span>? <span class="type">MoyaResponse</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="type">ORMError</span>.<span class="type">ORMNoRepresentor</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">guard</span> ((<span class="number">200</span>...<span class="number">209</span>) ~= response.statusCode) <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> json = <span class="keyword">try</span>? <span class="type">NSJSONSerialization</span>.<span class="type">JSONObjectWithData</span>(response.data, options: .<span class="type">AllowFragments</span>) <span class="keyword">as</span>? [<span class="type">String</span>: <span class="type">AnyObject</span>] &#123;</span><br><span class="line">                    log.error(<span class="string">"Got error message: <span class="subst">\(json)</span>"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="type">ORMError</span>.<span class="type">ORMNotSuccessfulHTTP</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">guard</span> <span class="keyword">let</span> json = <span class="keyword">try</span> <span class="type">NSJSONSerialization</span>.<span class="type">JSONObjectWithData</span>(response.data, options: .<span class="type">AllowFragments</span>) <span class="keyword">as</span>? [<span class="type">String</span>: <span class="type">AnyObject</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="type">ORMError</span>.<span class="type">ORMCouldNotMakeObjectError</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">self</span>.resultFromJSON(json, classType:type)!</span><br><span class="line">            &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="type">ORMError</span>.<span class="type">ORMCouldNotMakeObjectError</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">mapSuccessfulHTTPToObjectArray</span><span class="generics">&lt;T: Decodable&gt;</span><span class="params">(type: T.<span class="keyword">Type</span>)</span></span> -&gt; <span class="type">Observable</span>&lt;[<span class="type">T</span>]&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span> &#123; response <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> response = response <span class="keyword">as</span>? <span class="type">MoyaResponse</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="type">ORMError</span>.<span class="type">ORMNoRepresentor</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Allow successful HTTP codes</span></span><br><span class="line">            <span class="keyword">guard</span> ((<span class="number">200</span>...<span class="number">209</span>) ~= response.statusCode) <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> json = <span class="keyword">try</span>? <span class="type">NSJSONSerialization</span>.<span class="type">JSONObjectWithData</span>(response.data, options: .<span class="type">AllowFragments</span>) <span class="keyword">as</span>? [<span class="type">String</span>: <span class="type">AnyObject</span>] &#123;</span><br><span class="line">                    log.error(<span class="string">"Got error message: <span class="subst">\(json)</span>"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="type">ORMError</span>.<span class="type">ORMNotSuccessfulHTTP</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">guard</span> <span class="keyword">let</span> json = <span class="keyword">try</span> <span class="type">NSJSONSerialization</span>.<span class="type">JSONObjectWithData</span>(response.data, options: .<span class="type">AllowFragments</span>) <span class="keyword">as</span>? [[<span class="type">String</span> : <span class="type">AnyObject</span>]] <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="type">ORMError</span>.<span class="type">ORMCouldNotMakeObjectError</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Objects are not guaranteed, thus cannot directly map.</span></span><br><span class="line">                <span class="keyword">var</span> objects = [<span class="type">T</span>]()</span><br><span class="line">                <span class="keyword">for</span> dict <span class="keyword">in</span> json &#123;</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> obj = <span class="keyword">self</span>.resultFromJSON(dict, classType:type) &#123;</span><br><span class="line">                        objects.append(obj)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> objects</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="type">ORMError</span>.<span class="type">ORMCouldNotMakeObjectError</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样在调用的时候就很舒服了，以前面的 <code>Item</code> 为例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> provider = <span class="type">RxMoyaProvider</span>&lt;<span class="type">ItemAPI</span>&gt;()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ItemAPI</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">getNewItems</span><span class="params">(records:[Record] = [], needCount: Int, completion: [Item] -&gt; Void)</span></span> &#123;</span><br><span class="line">        disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">        provider</span><br><span class="line">            .request(.<span class="type">AddRecords</span>(records, needCount))</span><br><span class="line">            .mapSuccessfulHTTPToObjectArray(<span class="type">Item</span>)</span><br><span class="line">            .subscribe(</span><br><span class="line">                onNext: &#123; items <span class="keyword">in</span></span><br><span class="line">                    completion(items)</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">            .addDisposableTo(disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个 <code>mapSuccessfulHTTPToObjectArray</code> 方法，直接将 <code>JSON</code> 字符串转换成了 <code>Item</code> 对象，并且传入了后面的数据流中，所以在 <code>onNext</code> 订阅的时候传入的就是 <code>[Item]</code> 数据，并且这个转换过程还是可以复用的，且适用于所有网络请求中 <code>JSON</code> 和 <code>Model</code> 的转换。爽就一个字，我只说一次。</p>
<p>爽！</p>
<h2 id="Next">Next</h2><p>匆匆读了一点 <a href="https://github.com/artsy/Emergence" target="_blank" rel="external">Emergence</a> 和 <a href="https://github.com/artsy/eidolon" target="_blank" rel="external">Eidolon</a> 的项目源码，没有深入不过已经受益匪浅。通过 bundle 管理 id 和 key 直接解决了我当初纠结已久的『完整项目开源如何优雅地保留 git 记录且保护项目隐私』的问题，还有 <code>Moya/RxSwift</code> 和 <code>Moya/ReactiveCocoa</code> 这种子模块化处理也在共有模块管理这个问题上给了我一些启发。</p>
<p>真是很喜欢 Artsy 这样的团队，大家都一起做着自己喜欢的事情，还能站着把钱赚了。</p>
<p>所幸的是我也可以这样做自己喜欢的事情了，不过不赚钱。具体状况后面单独开一篇闲扯扯。</p>
<p>碎告。 </p>
<hr>
<p>参考资料：</p>
<ul>
<li><a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="external">RxSwift</a></li>
<li><a href="https://github.com/Moya/Moya" target="_blank" rel="external">Moya</a></li>
<li><a href="https://github.com/thoughtbot/argo" target="_blank" rel="external">Argo</a></li>
<li><a href="https://github.com/artsy/Emergence" target="_blank" rel="external">Emergence</a></li>
<li><a href="https://github.com/artsy/eidolon" target="_blank" rel="external">Eidolon</a></li>
<li><a href="https://robots.thoughtbot.com/efficient-json-in-swift-with-functional-concepts-and-generics" target="_blank" rel="external">Efficient JSON in Swift with Functional Concepts and Generics</a></li>
<li><a href="https://robots.thoughtbot.com/real-world-json-parsing-with-swift" target="_blank" rel="external">Real World JSON Parsing with Swift</a></li>
<li><a href="https://robots.thoughtbot.com/parsing-embedded-json-and-arrays-in-swift" target="_blank" rel="external">Parsing Embedded JSON and Arrays in Swift</a></li>
<li><a href="https://robots.thoughtbot.com/functional-swift-for-dealing-with-optional-values" target="_blank" rel="external">Functional Swift for Dealing with Optional Values</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[网络方案千千万，换个思路玩玩看。]]>
    
    </summary>
    
      <category term="Swift" scheme="http://blog.callmewhy.com/tags/Swift/"/>
    
      <category term="开发笔记" scheme="http://blog.callmewhy.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Yoapp 小记 - 简单方便的扩展们]]></title>
    <link href="http://blog.callmewhy.com/2015/10/21/extension-in-yoapp/"/>
    <id>http://blog.callmewhy.com/2015/10/21/extension-in-yoapp/</id>
    <published>2015-10-21T04:03:32.000Z</published>
    <updated>2015-10-24T08:12:17.000Z</updated>
    <content type="html"><![CDATA[<h3 id="SppedUp">SppedUp</h3><p>我们团队每隔两周会有一次 SppedUp ，两天时间开发一款全新的应用。从前天凌晨到昨天深夜整整48小时，第一次 SpeedUp 理论上应该已经结束，但是事实上并没有想象中那么理想，一直拖到今天还在继续，而且还存在诸如『登录时键盘遮挡输入框』这种低级错误。今天花了一天时间完善了细节，并且整理一下代码，整理一些 Swift 中的代码优化细节。</p>
<h3 id="UIStoryboardSegue">UIStoryboardSegue</h3><p>作为一名纯粹的 IB 党，少不了和 <code>UIStoryboardSegue</code> 打交道。主要的使用场景是以下两个方法：</p>
<ul>
<li><code>performSegueWithIdentifier(_:sender:)</code></li>
<li><code>prepareForSegue(_:sender:)</code></li>
</ul>
<p>一开始我们是这么写的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">performSegueWithIdentifier(<span class="string">"show_detail"</span>, sender: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>后来发觉这种 <code>hard code</code> 并不科学，于是用 struct 封装了一下定义成常量，这样合理多了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegueIdentifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> showDetail = <span class="string">"show_detail"</span></span><br><span class="line">&#125;</span><br><span class="line">performSegueWithIdentifier(<span class="type">SegueIdentifier</span>.showDetail, sender: dataSource[indexPath.row])</span><br></pre></td></tr></table></figure>
<p>再后来感觉 <code>prepareForSegue</code> 里不能 <code>switch</code> 不开心啊！于是改成用 <code>enum</code> 封装：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SegueIdentifier</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Detail</span> = <span class="string">"show_detail"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">prepareForSegue</span><span class="params">(segue: UIStoryboardSegue, sender: AnyObject?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span></span><br><span class="line">            <span class="keyword">let</span> identifier = segue.identifier,</span><br><span class="line">            <span class="keyword">let</span> segueIdentifier = <span class="type">SegueIdentifier</span>(rawValue: identifier) <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">fatalError</span>(<span class="string">"INVALID SEGUE IDENTIFIER <span class="subst">\(segue.identifier)</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> segueIdentifier &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Detail</span>:</span><br><span class="line">            <span class="comment">// DO SOMETHING</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>但是在调用 <code>performSegue</code> 的时候还是有点难受，不能直接传 <code>enum</code> 进去，必须要 <code>rawValue</code> 才行：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">performSegueWithIdentifier(<span class="type">SegueIdentifier</span>.<span class="type">Detail</span>.rawValue, sender: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>后来昨天看 <a href="https://developer.apple.com/videos/play/wwdc2015-411/" target="_blank" rel="external">Swift in Practice</a> 的时候发现，其实可以利用 <code>protocol extension</code> 把通用的部分封装起来：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SegueHandlerType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">SegueIdentifier</span>: <span class="type">RawRepresentable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SegueHandlerType</span> <span class="title">where</span> <span class="title">Self</span>: <span class="title">UIViewController</span>, <span class="title">SegueIdentifier</span>.<span class="title">RawValue</span> == <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">performSegueWithIdentifier</span><span class="params">(identifier: SegueIdentifier, sender: AnyObject?)</span></span> &#123;</span><br><span class="line">        performSegueWithIdentifier(identifier.rawValue, sender: sender)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">segueIdentifierForSegue</span><span class="params">(segue: UIStoryboardSegue)</span></span> -&gt; <span class="type">SegueIdentifier</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span></span><br><span class="line">            <span class="keyword">let</span> identifier = segue.identifier,</span><br><span class="line">            <span class="keyword">let</span> segueIdentifier = <span class="type">SegueIdentifier</span>(rawValue: identifier) <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">fatalError</span>(<span class="string">"INVALID SEGUE IDENTIFIER <span class="subst">\(segue.identifier)</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> segueIdentifier</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样只要 <code>UIViewController</code> 实现 <code>SegueHandlerType</code> 协议便可获得封装好的方法，比如更好用的 <code>performSegueWithIdentifier</code> ：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">performSegueWithIdentifier(.<span class="type">LoginViewController</span>, sender: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>而且 <code>prepareForSegue</code> 可以直接通过 <code>switch segueIdentifierForSegue(segue)</code> 对不同 <code>segue</code> 做处理：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">RankingViewController</span>: <span class="title">SegueHandlerType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">prepareForSegue</span><span class="params">(segue: UIStoryboardSegue, sender: AnyObject?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> segueIdentifierForSegue(segue) &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Detail</span>:</span><br><span class="line">            <span class="keyword">guard</span></span><br><span class="line">                <span class="keyword">let</span> controller = segue.destinationViewController <span class="keyword">as</span>? <span class="type">DetailViewController</span>,</span><br><span class="line">                <span class="keyword">let</span> cell = sender <span class="keyword">as</span>? <span class="type">RankingCell</span>,</span><br><span class="line">                <span class="keyword">let</span> app = cell.appDetail <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            controller.appDetail = app</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dequeueReusableCellWithIdentifier">dequeueReusableCellWithIdentifier</h3><p>在写 <code>UITableView</code> 的时候总会有一段很难记但是又不得不记的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cell = tableView.dequeueReusableCellWithIdentifier(<span class="string">"XxxxxCell"</span>) <span class="keyword">as</span>! <span class="type">XxxxxCell</span></span><br></pre></td></tr></table></figure>
<p>注意这里又出现了 <code>&quot;XxxxxCell&quot;</code> 这样的 <code>hard code</code> ，我们可以用 <code>Class</code> 的名称作为它的 <code>identifier</code> ，这样只要能获取到 <code>className</code> 就行了。在 Swift 里可以这样获取 <code>className</code> ：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> className: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.description().componentsSeparatedByString(<span class="string">"."</span>).last!</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是乎我们的代码变成了这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cell = tableView.dequeueReusableCellWithIdentifier(<span class="type">XxxxxCell</span>.className) <span class="keyword">as</span>! <span class="type">XxxxxCell</span></span><br></pre></td></tr></table></figure>
<p>接下来我们可以给 <code>UITableView</code> 添加个扩展，封装一下上面的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UITableView</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">dequeueCell</span><span class="generics">&lt;T: UITableViewCell&gt;</span><span class="params">(cell: T.<span class="keyword">Type</span>)</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dequeueReusableCellWithIdentifier(<span class="type">T</span>.className) <span class="keyword">as</span>! <span class="type">T</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以这样生成 <code>cell</code> 了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cell = tableView.dequeueCell(<span class="type">RankingCell</span>)</span><br></pre></td></tr></table></figure>
<h3 id="AVObject">AVObject</h3><p>由于在使用 <code>LeanCloud</code> 做后台服务，所以不可避免要和 <code>AVObject</code> 打交道，<code>AVObject</code> 基本和 <code>NSDictionary</code> 接口一致，所以做了如下封装：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> AVOSCloud</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AVObject</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">stringForKey</span><span class="params">(key: String)</span></span> -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.objectForKey(key) <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">doubleForKey</span><span class="params">(key: String)</span></span> -&gt; <span class="type">Double</span>? &#123;</span><br><span class="line">        <span class="keyword">let</span> o = <span class="keyword">self</span>.objectForKey(key)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> r = o <span class="keyword">as</span>? <span class="type">Double</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> r</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> r = o <span class="keyword">as</span>? <span class="type">String</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Double</span>(r)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="setToRouded">setToRouded</h3><p>将图片设为圆角是一个比较常见的操作，可以通过 <code>extension</code> 简单封装一下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">setToRounded</span><span class="params">(radius: CGFloat? = <span class="literal">nil</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> r = radius ?? <span class="built_in">min</span>(<span class="keyword">self</span>.frame.size.width, <span class="keyword">self</span>.frame.size.height) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">self</span>.layer.cornerRadius = r</span><br><span class="line">        <span class="keyword">self</span>.clipsToBounds = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果指定半径就设置圆角半径，如果没有值则取高和宽的最小值，实现『半圆』效果。</p>
<h3 id="QUESTION">QUESTION</h3><p>这里有个问题没太理解。请看下面两段代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UITableView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">dequeueCell1</span><span class="generics">&lt;T: UITableViewCell&gt;</span><span class="params">(name: String, cell: T.<span class="keyword">Type</span>)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(cell)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">dequeueCell2</span><span class="generics">&lt;T: UITableViewCell&gt;</span><span class="params">(cell: T.<span class="keyword">Type</span>)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(cell)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>唯一的区别就是参数数目不同，但是调用的时候：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">UITableView</span>.dequeueCell1(<span class="string">""</span>, cell: <span class="type">UITableViewCell</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="type">UITableView</span>.dequeueCell2(<span class="type">UITableViewCell</span>)</span><br></pre></td></tr></table></figure>
<p>两个参数的需要 <code>.self</code> 而另一个则不需要。=。=没太搞懂这是哪出，还望赐教！</p>
<hr>
<p>参考文献：</p>
<ul>
<li><a href="https://developer.apple.com/videos/play/wwdc2015-411/" target="_blank" rel="external">Swift in Practice</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[用扩展给你的代码们装备上铠甲吧！]]>
    
    </summary>
    
      <category term="Swift" scheme="http://blog.callmewhy.com/tags/Swift/"/>
    
      <category term="开发笔记" scheme="http://blog.callmewhy.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RxSwift 入坑手册 Part1 - 示例实战]]></title>
    <link href="http://blog.callmewhy.com/2015/09/23/rxswift-getting-started-1/"/>
    <id>http://blog.callmewhy.com/2015/09/23/rxswift-getting-started-1/</id>
    <published>2015-09-23T06:45:59.000Z</published>
    <updated>2015-10-01T07:55:11.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Intro">Intro</h2><p>这部分主要是学习 <a href="https://github.com/ReactiveX/RxSwift/" target="_blank" rel="external">RxSwift</a> 项目中的示例项目，了解 <code>RxSwift</code> 在实际 iOS 开发中的正确打开方式。</p>
<h2 id="Demo1:_GitHub_Signup">Demo1: <a href="https://github.com/ReactiveX/RxSwift/tree/master/RxExample/RxExample/Examples/GitHubSignup" target="_blank" rel="external">GitHub Signup</a></h2><p>第一个示例是 GitHub 注册账号的例子。输入用户名、密码、重复密码，然后提交注册。</p>
<h3 id="username">username</h3><p>在注册流程中，用户名校验是一个很常见的功能。我们一般需要对用户名做如下检查和流程：</p>
<ul>
<li>是否不为空</li>
<li>是否不包含非法字符</li>
<li>是否没有被注册过</li>
<li>以上均通过，联网注册</li>
<li>是否成功连接上服务器</li>
<li>服务器是否正确处理并返回结果</li>
</ul>
<p>要通过 RxSwift 实现以上流程，可以划分成如下几步。</p>
<h4 id="rx_text">rx_text</h4><p>如果想监听文字输入，我们最好能有一个 <code>Observable</code> 的对象不断地给我们发送新的输入值。<code>rx_text</code> 是 RxSwift 针对 Cocoa 库做的各种封装中的一个，可以简单看下它的定义：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UITextField</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">    Reactive wrapper for `text` property.</span><br><span class="line">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> rx_text: <span class="type">ControlProperty</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> rx_value(getter: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>?.text ?? <span class="string">""</span></span><br><span class="line">        &#125;, setter: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] value <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>?.text = value</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回的 <code>ControlProperty</code> 遵循 <code>ControlPropertyType</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ControlPropertyType</span> : <span class="title">ObservableType</span>, <span class="title">ObserverType</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">    - returns: `ControlProperty` interface</span><br><span class="line">    */</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">asControlProperty</span><span class="params">()</span></span> -&gt; <span class="type">ControlProperty</span>&lt;<span class="type">E</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，它既是一个可被订阅者 (<code>ObservableType</code>)，又是一个订阅者 (<code>ObserverType</code>)，也就是说它是一个 <a href="http://blog.callmewhy.com/2015/09/21/rxswift-getting-started-0/#Subjects"><code>Subject</code></a> 对象。由于它是 <code>Observable</code> 的，所以我们可以通过 <code>map</code> 把它转换成想要的输出，例如下面这段代码会实现『每输入一个字就在控制台输出当前内容』的功能（记得 RAC 的系列教程似乎也是这个节奏）：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    <span class="preprocessor">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> usernameOutlet: <span class="type">UITextField</span>!</span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="keyword">let</span> username = usernameOutlet.rx_text</span><br><span class="line">        username.subscribeNext &#123;</span><br><span class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="validate">validate</h4><p>接下来就是验证用户名的阶段了。首先需要一个方法，将用户名转换成一串流。为什么是流？为了统一口径。先看代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">ValidationResult</span> = (valid: <span class="type">Bool</span>?, message: <span class="type">String</span>?)</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">validateUsername</span><span class="params">(username: String)</span></span> -&gt; <span class="type">Observable</span>&lt;<span class="type">ValidationResult</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 如果用户名为空</span></span><br><span class="line">    <span class="keyword">if</span> username.characters.<span class="built_in">count</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> just((<span class="literal">false</span>, <span class="literal">nil</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果用户名中出现非法字符</span></span><br><span class="line">    <span class="keyword">if</span> username.rangeOfCharacterFromSet(<span class="type">NSCharacterSet</span>.alphanumericCharacterSet().invertedSet) != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> just((<span class="literal">false</span>, <span class="string">"Username can only contain numbers or digits"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加载中的值</span></span><br><span class="line">    <span class="keyword">let</span> loadingValue = (valid: <span class="literal">nil</span> <span class="keyword">as</span> <span class="type">Bool</span>?, message: <span class="string">"Checking availabilty ..."</span> <span class="keyword">as</span> <span class="type">String</span>?)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 校验用户名</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">API</span>.usernameAvailable(username)</span><br><span class="line">        .<span class="built_in">map</span> &#123; available <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> available &#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="literal">true</span>, <span class="string">"Username available"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="literal">false</span>, <span class="string">"Username already taken"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .startWith(loadingValue)    <span class="comment">// 在加载结果之前插入 加载中 这个状态的事件值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>梳理一下：</p>
<ul>
<li>如果用户名为空，返回 <code>(false, nil)</code> 完事儿</li>
<li>如果用户名有非法字符，返回 <code>(false, &quot;Username can only contain numbers or digits&quot;)</code> 完事儿</li>
<li>如果本地检查没问题，发给服务器检查，先发送一个事件 <code>loadingValue</code> 表示正在加载，加载成功再发送结果事件</li>
</ul>
<p>这就是我所理解的『统一口径』。虽然本地检查分分钟就能给你个结果，但是如果统一都用『流』来表述，外部处理起来会简单得多。不用管具体的结果是什么，只需要知道是一个 <code>Observable</code> 对象，并且随之而来的是一串事件，就足够了。这一串事件，有可能只有一个，提示用户名不能为空；也有可能有很多，先提示正在加载，然后再提示注册成功。在外部来看，这就是一个事件流。</p>
<p>试想一下如果用 UIKit 的那一套来写这个流程，肯定要监听个 <code>valueChanged</code> 事件然后在委托方法里先判断 A ，如果不符合就刷新 UI ；再判断 B ，不符合就刷新 UI ；最后发请求给服务器，刷新 UI 提示等待，然后加载完了再刷新个 UI 。。。</p>
<h4 id="switch">switch</h4><p>把上面的验证代码用到项目中大概就是这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> usernameValidation = username</span><br><span class="line">    .<span class="built_in">map</span> &#123; username <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> validationService.validateUsername(username)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果把每次的文字改动事件用 v 来表示，那整个事件序列应该是这样的：</p>
<pre><code><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">V</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">V</span><span class="literal">-</span><span class="literal">-</span><span class="comment">V</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">V</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">V</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>
</code></pre><p>而用了 <code>validateUsername</code> 之后，它会把以前的值转换成一个新的序列，就成了这样：</p>
<pre><code>----|<span class="string">------</span>|<span class="string">--</span>|<span class="string">---</span>|<span class="string">---</span>|<span class="string">----
    </span>|<span class="string">      </span>|<span class="string">  </span>|<span class="string">   </span>|<span class="string">   </span>|
    V      V  V   V   V
    |<span class="string">      </span>|<span class="string">  </span>|<span class="string">   </span>|<span class="string">   </span>|
    |<span class="string">      V  </span>|<span class="string">   V   </span>|
    |<span class="string">      </span>|<span class="string">  </span>|<span class="string">   </span>|<span class="string">   </span>|
</code></pre><p>瞬间变成了二维世界了，我们可以用 <a href="http://blog.callmewhy.com/2015/09/21/rxswift-getting-started-0/#switch"><code>switch</code></a> 来『降维』（这名词是我自己起的，如果有更好的称呼欢迎随时打脸(￣ε(#￣)☆╰╮(￣▽￣///))。这里我们选用 <code>switchLastest</code> ：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> usernameValidation = username</span><br><span class="line">    .<span class="built_in">map</span> &#123; username <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> validationService.validateUsername(username)</span><br><span class="line">    &#125;</span><br><span class="line">    .switchLatest()</span><br></pre></td></tr></table></figure>
<p>不妨看一下 ObservableType 的定义：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ObservableType</span> <span class="title">where</span> <span class="title">E</span> : <span class="title">ObservableType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="func"><span class="keyword">func</span> <span class="title">switchLatest</span><span class="params">()</span></span> -&gt; <span class="type">Observable</span>&lt;<span class="type">E</span>.<span class="type">E</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Switch</span>(sources: <span class="keyword">self</span>.asObservable())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个扩展是针对『自己是 <code>ObservableType</code> 且自己监听的事件也是 <code>ObservableType</code> 』这一类对象的。通过 <code>switchLatest</code> 方法我们可以将前面的二维结构梳理成一维结构，每次自动切换到新的序列的最新事件上。</p>
<pre><code>----|<span class="string">------</span>|<span class="string">--</span>|<span class="string">---</span>|<span class="string">---</span>|<span class="string">----
    V      </span>|<span class="string">  </span>|<span class="string">   </span>|<span class="string">   </span>|
    |<span class="string">------</span>|<span class="string">  </span>|<span class="string">   </span>|<span class="string">   </span>|
    |<span class="string">      V  </span>|<span class="string">   </span>|<span class="string">   </span>|
    |<span class="string">      V  </span>|<span class="string">   </span>|<span class="string">   </span>|
    |<span class="string">      </span>|<span class="string">--</span>|<span class="string">   </span>|<span class="string">   </span>|
    |<span class="string">      </span>|<span class="string">  V   </span>|<span class="string">   </span>|
    |<span class="string">      </span>|<span class="string">  </span>|<span class="string">---</span>|<span class="string">   </span>|
    |<span class="string">      </span>|<span class="string">  </span>|<span class="string">   V   </span>|
    |<span class="string">      </span>|<span class="string">  </span>|<span class="string">   V   </span>|
    |<span class="string">      </span>|<span class="string">  </span>|<span class="string">   </span>|<span class="string">---</span>|
    |<span class="string">      </span>|<span class="string">  </span>|<span class="string">   </span>|<span class="string">   V</span>
</code></pre><p>执行结果如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> usernameValidation = username</span><br><span class="line">        .<span class="built_in">map</span> &#123; username <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> validationService.validateUsername(username)</span><br><span class="line">        &#125;</span><br><span class="line">        .switchLatest()</span><br><span class="line">        .subscribe &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Event: - <span class="subst">\($<span class="number">0</span>)</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">----- <span class="type">Output</span> -----</span><br><span class="line"><span class="comment">// 输入 12!</span></span><br><span class="line"><span class="type">Event</span>: - <span class="type">Next</span>((<span class="type">Optional</span>(<span class="literal">false</span>), <span class="type">Optional</span>(<span class="string">"Username can only contain numbers or digits"</span>)))</span><br><span class="line"><span class="comment">// 输出 abc</span></span><br><span class="line"><span class="type">Event</span>: - <span class="type">Next</span>((<span class="literal">nil</span>, <span class="type">Optional</span>(<span class="string">"Checking availabilty ..."</span>)))</span><br><span class="line"><span class="type">Event</span>: - <span class="type">Next</span>((<span class="type">Optional</span>(<span class="literal">false</span>), <span class="type">Optional</span>(<span class="string">"Username already taken"</span>)))</span><br></pre></td></tr></table></figure>
<h4 id="replay">replay</h4><p>我们在 <code>map</code> 里调用了 <code>validateUsername</code> 方法，这会导致如果有多个订阅者的话，会重复调用多次。</p>
<p>例如这个例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sequenceOfElements = sequenceOf(<span class="number">0</span>).<span class="built_in">map</span> &#123; r -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"MAP"</span>)    <span class="comment">// twice</span></span><br><span class="line">    <span class="keyword">return</span> r * <span class="number">2</span></span><br><span class="line">&#125;    </span><br><span class="line"><span class="keyword">let</span> subscription = sequenceOfElements</span><br><span class="line">    .subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"1 - <span class="subst">\(event)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> subscription2 = sequenceOfElements</span><br><span class="line">    .subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"2 - <span class="subst">\(event)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--- <span class="built_in">map</span> example ---</span><br><span class="line"><span class="type">MAP</span></span><br><span class="line"><span class="number">1</span> - <span class="type">Next</span>(<span class="number">0</span>)</span><br><span class="line"><span class="number">1</span> - <span class="type">Completed</span></span><br><span class="line"><span class="type">MAP</span></span><br><span class="line"><span class="number">2</span> - <span class="type">Next</span>(<span class="number">0</span>)</span><br><span class="line"><span class="number">2</span> - <span class="type">Completed</span></span><br></pre></td></tr></table></figure>
<p>我一开始很疑惑，明明订阅的是 <code>map</code> 之后的队列，但是为什么 <code>subscribe</code> 每次都会重新 <code>map</code> 一次呢？</p>
<p>经提醒之后又去仔细翻阅了入门文档 <a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md" target="_blank" rel="external">Getting Started</a> ，看到了下面这段话：</p>
<blockquote>
<p>Every subscriber upon subscription usually generates it’s own separate sequence of elements. Operators are stateless by default. There is vastly more stateless operators then stateful ones.</p>
</blockquote>
<p>这么一想就说得通了，一切都是为了 <code>stateless</code> 。如果 <code>subscribe</code> 的是 <code>map</code> 后的结果，那就意味着需要多存储一个状态，而状态的增加往往意味着复杂度的指数级增长。</p>
<p>为了解决这个多次订阅会多次执行的问题，我们需要 <code>shareReplay</code> ，看下这个示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sequenceOfInts = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> a = sequenceOfInts.<span class="built_in">map</span>&#123; i -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"MAP---<span class="subst">\(i)</span>"</span>)</span><br><span class="line">    <span class="keyword">return</span> i * <span class="number">2</span></span><br><span class="line">&#125;.shareReplay(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">let</span> b = a.subscribeNext &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"--1--<span class="subst">\($<span class="number">0</span>)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line">sequenceOfInts.on(.<span class="type">Next</span>(<span class="number">1</span>))</span><br><span class="line">sequenceOfInts.on(.<span class="type">Next</span>(<span class="number">2</span>))</span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = a.subscribeNext &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"--2--<span class="subst">\($<span class="number">0</span>)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line">sequenceOfInts.on(.<span class="type">Next</span>(<span class="number">3</span>))</span><br><span class="line">sequenceOfInts.on(.<span class="type">Next</span>(<span class="number">4</span>))</span><br><span class="line"><span class="keyword">let</span> d = a.subscribeNext &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"--3--<span class="subst">\($<span class="number">0</span>)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line">sequenceOfInts.on(.<span class="type">Completed</span>)</span><br><span class="line"></span><br><span class="line">--- shareReplay example ---</span><br><span class="line"><span class="type">MAP</span>---<span class="number">1</span></span><br><span class="line">--<span class="number">1</span>--<span class="number">2</span></span><br><span class="line"><span class="type">MAP</span>---<span class="number">2</span></span><br><span class="line">--<span class="number">1</span>--<span class="number">4</span></span><br><span class="line">--<span class="number">2</span>--<span class="number">2</span></span><br><span class="line">--<span class="number">2</span>--<span class="number">4</span></span><br><span class="line"><span class="type">MAP</span>---<span class="number">3</span></span><br><span class="line">--<span class="number">1</span>--<span class="number">6</span></span><br><span class="line">--<span class="number">2</span>--<span class="number">6</span></span><br><span class="line"><span class="type">MAP</span>---<span class="number">4</span></span><br><span class="line">--<span class="number">1</span>--<span class="number">8</span></span><br><span class="line">--<span class="number">2</span>--<span class="number">8</span></span><br><span class="line">--<span class="number">3</span>--<span class="number">4</span></span><br><span class="line">--<span class="number">3</span>--<span class="number">6</span></span><br><span class="line">--<span class="number">3</span>--<span class="number">8</span></span><br></pre></td></tr></table></figure>
<p><code>shareReplay</code> 会返回一个新的事件序列，它监听底层序列的事件，并且通知自己的订阅者们。不过和传统的订阅不同的是，它是通过『重播』的方式通知自己的订阅者。就像是过目不忘的看书，但是每次都只记得最后几行的内容，在有人询问的时候就背诵出来。从上面的例子可以看到，通过 <code>shareReplay</code> 订阅的 <code>map</code> 并不会调用多次。所以我们也可以把它应用到 <code>validateUsername</code> 上：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> usernameValidation = username</span><br><span class="line">    .<span class="built_in">map</span> &#123; username <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> validationService.validateUsername(username)</span><br><span class="line">    &#125;</span><br><span class="line">    .switchLatest()</span><br><span class="line">    .shareReplay(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>这样就不会出现『多次订阅导致重复地检查用户名是否可用』的情况了。</p>
<h4 id="usernameAvailable">usernameAvailable</h4><p>前面梳理了基本的用户名校验流程，接下来看下联网检测这部分是如何实现的。</p>
<p>联网检测用户名是否可用主要是访问用户名对应的 github 地址然后查看是否是 404 ，如果不是那就说明已经被注册了。核心代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">usernameAvailable</span><span class="params">(username: String)</span></span> -&gt; <span class="type">Observable</span>&lt;<span class="type">Bool</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="type">URL</span> = <span class="type">NSURL</span>(string: <span class="string">"https://github.com/<span class="subst">\(URLEscape(username)</span>)"</span>)!</span><br><span class="line">    <span class="keyword">let</span> request = <span class="type">NSURLRequest</span>(<span class="type">URL</span>: <span class="type">URL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.<span class="type">URLSession</span>.rx_response(request)</span><br><span class="line">        .<span class="built_in">map</span> &#123; (maybeData, maybeResponse) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> response = maybeResponse <span class="keyword">as</span>? <span class="type">NSHTTPURLResponse</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> response.statusCode == <span class="number">404</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .observeOn(<span class="keyword">self</span>.dataScheduler)</span><br><span class="line">        .catchErrorJustReturn(<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和前面的 <code>rx_value</code> 相似， <code>rx_response</code> 是针对 <code>NSURLSession</code> 的扩展。通过 <code>observeOn</code> 将监听事件绑定在了 <code>dataScheduler</code> 上。最后 <code>catchErrorJustReturn(false)</code> 表明如果出现异常就返回个 <code>false</code> 。</p>
<p><a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Schedulers.md" target="_blank" rel="external"><code>Scheduler</code></a> 是一种 Rx 里的任务运行机制，类似的 <code>gcd</code> 里的 <code>dispatch queue</code> 。可以通过 <code>observeOn</code> 切换 <code>scheduler</code> ：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">sequence1</span><br><span class="line">    .observeOn(backgroundScheduler)</span><br><span class="line">    .<span class="built_in">map</span> &#123; n <span class="keyword">in</span></span><br><span class="line">      <span class="built_in">println</span>(<span class="string">"This is performed on background scheduler"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    .observeOn(<span class="type">MainScheduler</span>.sharedInstance)</span><br><span class="line">    .<span class="built_in">map</span> &#123; n <span class="keyword">in</span></span><br><span class="line">      <span class="built_in">println</span>(<span class="string">"This is performed on main scheduler"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="password">password</h3><p>密码的检测相比较用户名而言就简单很多，核心代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">validatePassword</span><span class="params">(password: String)</span></span> -&gt; <span class="type">ValidationResult</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> numberOfCharacters = password.characters.<span class="built_in">count</span></span><br><span class="line">    <span class="keyword">if</span> numberOfCharacters == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">false</span>, <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> numberOfCharacters &lt; minPasswordCount &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">false</span>, <span class="string">"Password must be at least <span class="subst">\(minPasswordCount)</span> characters"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">true</span>, <span class="string">"Password acceptable"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里返回了 <code>ValidationResult</code> ，因为所有校验都是本地完成的。</p>
<p>接下来就是重复密码的校验，这部分比较有意思，通过 <a href="http://blog.callmewhy.com/2015/09/21/rxswift-getting-started-0/#combineLatest"><code>combineLatest</code></a> 将两个序列合并起来：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> repeatPasswordValidation = combineLatest(password, repeatPassword) &#123; (password, repeatedPassword) <span class="keyword">in</span></span><br><span class="line">        validationService.validateRepeatedPassword(password, repeatedPassword: repeatedPassword)</span><br><span class="line">    &#125;</span><br><span class="line">    .shareReplay(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>然后 <code>validateRepeatedPassword</code> 方法如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">validateRepeatedPassword</span><span class="params">(password: String, repeatedPassword: String)</span></span> -&gt; <span class="type">ValidationResult</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> repeatedPassword.characters.<span class="built_in">count</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">false</span>, <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> repeatedPassword == password &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">true</span>, <span class="string">"Password repeated"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">false</span>, <span class="string">"Password different"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这几个例子基本都是把事件序列进行组装然后『外包』给其他对象去处理。</p>
<h3 id="bindValidationResultToUI">bindValidationResultToUI</h3><p>检查也检查好了，接下来的就是更新 UI 了，用户名非法、两次密码不一致，这些都需要通过刷新 UI 告知用户。也就是说，需要把前面定义的『事件流』和『用户界面』绑定起来。看下这个绑定的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">bindValidationResultToUI</span><span class="params">(source: Observable&lt;ValidationResult&gt;,</span><br><span class="line">    validationErrorLabel: UILabel)</span></span> &#123;</span><br><span class="line">    source</span><br><span class="line">        .subscribeNext &#123; v <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> validationColor: <span class="type">UIColor</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> valid = v.valid &#123;</span><br><span class="line">                validationColor = valid ? okColor : errorColor</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               validationColor = <span class="type">UIColor</span>.grayColor()</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            validationErrorLabel.textColor = validationColor</span><br><span class="line">            validationErrorLabel.text = v.message ?? <span class="string">""</span></span><br><span class="line">        &#125;</span><br><span class="line">        .addDisposableTo(disposeBag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里出现了 <code>addDisposableTo(disposeBag)</code> ，在此需要解释一下 <a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md#disposing" target="_blank" rel="external"><code>disposing</code></a>  的相关概念。</p>
<p>一个事件流的终结除了前面了解的各种事件之外，还有一种方法，就是 <code>dispose</code> ，释放掉所有的资源。比如这个例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> subscription = interval(<span class="number">0.3</span>, scheduler)</span><br><span class="line">    .subscribe &#123; (e: <span class="type">Event</span>&lt;<span class="type">Int64</span>&gt;) <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">println</span>(e)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">NSThread</span>.sleepForTimeInterval(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">subscription.dispose()</span><br><span class="line"></span><br><span class="line">----- <span class="type">Dispose</span> <span class="type">Sample</span> -----</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>然而 <code>dispose</code> 方法是不推荐使用的，推荐使用更好的解决方案， <code>DisposeBag</code> 就是一个。<code>addDisposableTo(disposeBag)</code> 有点像是 ARC ，先把分配的资源统一丢到袋子里 (有点像是 <code>autoreleasepool</code>) ，然后当 <code>disposeBag</code> 销毁的时候就一起销毁这些资源。在代码里可以看到，只要有 <code>subscribe</code> 的基本在最后都会兜上一个 <code>.addDisposableTo(disposeBag)</code> 用来处理资源自动销毁的问题。</p>
<h3 id="signupEnabled">signupEnabled</h3><p>检查完毕之后，如果所有条件都符合，那就需要把 <code>Signup</code> 按钮高亮，高亮的逻辑是把多个数据流合并在了一起：</p>
 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> signupEnabled = combineLatest(</span><br><span class="line">     usernameValidation,</span><br><span class="line">     passwordValidation,</span><br><span class="line">     repeatPasswordValidation,</span><br><span class="line">     signingProcess</span><br><span class="line"> ) &#123; un, p, pr, signingState <span class="keyword">in</span></span><br><span class="line">     <span class="keyword">return</span> (un.valid ?? <span class="literal">false</span>) &amp;&amp; (p.valid ?? <span class="literal">false</span>) &amp;&amp; (pr.valid ?? <span class="literal">false</span>) &amp;&amp; signingState != <span class="type">SignupState</span>.<span class="type">SigningUp</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在基本的流都构建完毕的情况下，各种需求更多的是对流的组合拼装。比如这里就再次用到了 <code>usernameValidation</code> 这个流，还好前面有 <a href="http://blog.callmewhy.com/2015/09/23/rxswift-getting-started-1/#replay"><code>shareReplay</code></a> 罩着，我们想复用多少次都没问题。</p>
<h3 id="signingProcess">signingProcess</h3><p>在点击注册按钮之后，就是具体的注册流程了，注册流程的代码是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> signingProcess = combineLatest(username, password) &#123; ($<span class="number">0</span>, $<span class="number">1</span>) &#125;</span><br><span class="line">    .sampleLatest(signupSampler)</span><br><span class="line">    .<span class="built_in">map</span> &#123; (username, password) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">API</span>.signup(username, password: password)</span><br><span class="line">    &#125;</span><br><span class="line">    .switchLatest()</span><br><span class="line">    .startWith(<span class="type">SignupState</span>.<span class="type">InitialState</span>)</span><br><span class="line">    .shareReplay(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>这里有个 <code>sampleLatest</code> ，在了解它之前先要了解什么是 <code>sample</code> 。</p>
<h4 id="sample">sample</h4><p><code>sample</code> 就是一次『采样』，当收到采样事件的时候，就会从事件队列中取出一个事件作为『样本』，并发送到事件流里。如果下一次又要采样了，就会从两次采样之间的事件队列中选择最后一个事件，如果两次采集之间没有新的事件就不会进行任何操作。</p>
<p>可以看下这个例子帮助理解：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> o = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> subscription = s</span><br><span class="line">    .sample(o)</span><br><span class="line">    .subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(event)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s.on(.<span class="type">Next</span>(<span class="number">1</span>))</span><br><span class="line">o.on(.<span class="type">Next</span>(<span class="string">"A"</span>))</span><br><span class="line">s.on(.<span class="type">Next</span>(<span class="number">2</span>))</span><br><span class="line">s.on(.<span class="type">Next</span>(<span class="number">3</span>))</span><br><span class="line">o.on(.<span class="type">Next</span>(<span class="string">"B"</span>))</span><br><span class="line">o.on(.<span class="type">Next</span>(<span class="string">"C"</span>))</span><br><span class="line"></span><br><span class="line">--- sample example ---</span><br><span class="line"><span class="type">Next</span>(<span class="number">1</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p><code>sampleLatest</code> 就是，即使两次采样期间没有新的事件也没关系，取整个队列的最后一个事件作为输出。还是上面那个例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> o = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> subscription = s</span><br><span class="line">    .sampleLatest(o)</span><br><span class="line">    .subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(event)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s.on(.<span class="type">Next</span>(<span class="number">1</span>))</span><br><span class="line">o.on(.<span class="type">Next</span>(<span class="string">"1"</span>))</span><br><span class="line">s.on(.<span class="type">Next</span>(<span class="number">2</span>))</span><br><span class="line">s.on(.<span class="type">Next</span>(<span class="number">3</span>))</span><br><span class="line">o.on(.<span class="type">Next</span>(<span class="string">"2"</span>))</span><br><span class="line">o.on(.<span class="type">Next</span>(<span class="string">"3"</span>))</span><br><span class="line"></span><br><span class="line">--- sample example ---</span><br><span class="line"><span class="type">Next</span>(<span class="number">1</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="number">3</span>)</span><br><span class="line"><span class="type">Next</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>所以上面的注册流程代码也就可以理解了：</p>
<ul>
<li>先把 username 和 password 绑起来</li>
<li>将注册按钮的点击事件作为一个触发点，每次点击都会获取最新的账号密码走下面的流程</li>
<li>调用 <code>API.signup</code> 进行注册</li>
<li>将 <code>map</code> 之后的二维队列拍平，切换到最新的队列上</li>
<li>将状态置为初始状态</li>
<li>通过 <code>shareReplay</code> 避免重复订阅导致的反复执行的问题</li>
</ul>
<h4 id="signup">signup</h4><p>项目里的注册功能只是一个 <code>mock</code> 而已，并没有真的访问 API ：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">signup</span><span class="params">(username: String, password: String)</span></span> -&gt; <span class="type">Observable</span>&lt;<span class="type">SignupState</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// this is also just a mock</span></span><br><span class="line">    <span class="keyword">let</span> signupResult = <span class="type">SignupState</span>.<span class="type">SignedUp</span>(signedUp: arc4random() % <span class="number">5</span> == <span class="number">0</span> ? <span class="literal">false</span> : <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">return</span> [just(signupResult), never()]</span><br><span class="line">        .concat()</span><br><span class="line">        .throttle(<span class="number">2</span>, <span class="type">MainScheduler</span>.sharedInstance)</span><br><span class="line">        .startWith(<span class="type">SignupState</span>.<span class="type">SigningUp</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里可以看到 <code>never()</code> 的正确打开方式：用于无限等待。  <code>concat</code> 将上面两个序列首尾拼接起来，然后 <code>throttle</code> 等价于 <a href="http://rxmarbles.com/#debounce" target="_blank" rel="external"><code>debounce</code></a> ：如果两个事件的时间间隔小于某个特定值，就会忽视掉前面一个。通过 <code>never</code> + <code>throttle</code> 伪造了一种等待加载2秒然后返回注册结果的错觉。</p>
<h4 id="disposeBag">disposeBag</h4><p>定义了事件流之后，我们就可以通过 <code>subscribeNext</code> 来刷新 UI 了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">signingProcess</span><br><span class="line">    .subscribeNext &#123; [<span class="keyword">unowned</span> <span class="keyword">self</span>] signingResult <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">switch</span> signingResult &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">SigningUp</span>:</span><br><span class="line">            <span class="keyword">self</span>.signingUpOulet.hidden = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">SignedUp</span>(<span class="keyword">let</span> signed):</span><br><span class="line">            <span class="keyword">self</span>.signingUpOulet.hidden = <span class="literal">true</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> alertView: <span class="type">UIAlertView</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> signed &#123;</span><br><span class="line">                alertView = <span class="type">UIAlertView</span>(title: <span class="string">"GitHub"</span>, message: <span class="string">"Mock signed up to GitHub"</span>, delegate: <span class="literal">nil</span>, cancelButtonTitle: <span class="string">"OK"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                alertView = <span class="type">UIAlertView</span>(title: <span class="string">"GitHub"</span>, message: <span class="string">"Mock signed up failed"</span>, delegate: <span class="literal">nil</span>, cancelButtonTitle: <span class="string">"OK"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            alertView.show()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">self</span>.signingUpOulet.hidden = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure>
<p>注意，每一次 <code>subscribe</code> 都要及时回收资源，在示例代码中是都通过 <code>addDisposableTo(disposeBag)</code> 统一处理了。在 <code>disposeBag</code> 重新赋值的时候就会自动清理资源。</p>
<p>项目中一共有三个地方调用了 <code>disposeBag = DisposeBag()</code> ：</p>
<ul>
<li>定义变量的时候：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> disposeBag = <span class="type">DisposeBag</span>()</span><br></pre></td></tr></table></figure>
<ul>
<li><code>viewDidLoad</code> 里：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    <span class="keyword">self</span>.disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>willMoveToParentViewController</code> 里：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This is one of the reasons why it's a good idea for disposal to be detached from allocations.</span></span><br><span class="line"><span class="comment">// If resources weren't disposed before view controller is being deallocated, signup alert view</span></span><br><span class="line"><span class="comment">// could be presented on top of wrong screen or crash your app if it was being presented while</span></span><br><span class="line"><span class="comment">// navigation stack is popping.</span></span><br><span class="line"><span class="comment">// This will work well with UINavigationController, but has an assumption that view controller will</span></span><br><span class="line"><span class="comment">// never be readded as a child view controller.</span></span><br><span class="line"><span class="comment">// It it was readded UI wouldn't be bound anymore.</span></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">willMoveToParentViewController</span><span class="params">(parent: UIViewController?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> parent = parent &#123;</span><br><span class="line">        <span class="built_in">assert</span>(parent.isKindOfClass(<span class="type">UINavigationController</span>), <span class="string">"Please read comments"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>UINavigationController</code> 中，这样的代码没有问题，但是当把这个 <code>view controller</code> 作为 <code>child view controller</code> 添加到其他界面的时候，会直接走到断言处。原因是在 <code>child view controller</code> 中，会先调用 <code>viewDidLoad</code> 再调用 <code>willMoveToParentViewController</code> ，好不容易绑定好的界面和事件流，结果直接 <code>self.disposeBag = DisposeBag()</code> 就给解绑了，自然出了问题。</p>
<h2 id="Demo2:_Wiki">Demo2: <a href="https://github.com/ReactiveX/RxSwift/tree/master/RxExample/RxExample/Examples/WikipediaImageSearch" target="_blank" rel="external">Wiki</a></h2><p>为什么在第一篇开头我就说：我又要挖坑了？因为我预见到。。。这个系列可能还没来得及写完就出其他事情了=。=</p>
<p>果然。</p>
<p>接下来专心前端和推荐算法了。有缘我们坑里再见。。。</p>
<h2 id="Next">Next</h2><p>各种异步各种回调的好处是整个应用行云流水让人感觉十分舒适，坏处是和 RAC 一样断点调试基本就是噩梦：</p>
<p><img src="http://ww2.sinaimg.cn/large/61d238c7gw1ewdy2ss0l9j21kw0xdtlw.jpg" alt=""></p>
<p>参考文献：</p>
<ul>
<li><a href="http://reactivex.io/documentation/operators/replay.html" target="_blank" rel="external">replay</a></li>
<li><a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md" target="_blank" rel="external">Getting Started</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[万水千山总是情，留坑在此行不行=。=]]>
    
    </summary>
    
      <category term="RxSwift" scheme="http://blog.callmewhy.com/tags/RxSwift/"/>
    
      <category term="开发笔记" scheme="http://blog.callmewhy.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RxSwift 入坑手册 Part0 - 基础概念]]></title>
    <link href="http://blog.callmewhy.com/2015/09/21/rxswift-getting-started-0/"/>
    <id>http://blog.callmewhy.com/2015/09/21/rxswift-getting-started-0/</id>
    <published>2015-09-21T01:53:10.000Z</published>
    <updated>2015-10-02T06:28:21.000Z</updated>
    <content type="html"><![CDATA[<p>（前面的坑还没填完，我又来开坑了。。。Part 0 走起！）</p>
<p><a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="external">RxSwift</a> 是我在 Github 上关注已久的一个项目，今天花点时间过了一下它的示例代码，感觉很有意思。</p>
<p>我主要是通过项目里的 <a href="https://github.com/ReactiveX/RxSwift/tree/master/Rx.playground" target="_blank" rel="external">Rx.playground</a> 进行学习和了解的，这种方式确实便捷高效。只需要把文档用 <code>/*: */</code> 注释即可，直接用 Markdown 编写，简单方便。不过 Xcode7 中这种方式现在还不是很稳定，会有大量的空行，而且有个最大的问题就是阅读到中间然后切到其他文件再切回来的时候，阅读的进度条是从头开始的，并不能记录上次阅读的位置。心累。</p>
<p>下面是我的简单笔记，只是把学习过程中的收获记录下来，大部分内容来自于项目内的 playground 。注意！是<strong>很大部分</strong>！而且操场里图文并茂，很容易理解。所以，各位如果感兴趣，建议 clone 官方项目，跑个操场玩玩。</p>
<p>参考文献中罗列了我在学习过程中查阅的相关资料，可以作为补充阅读。</p>
<h2 id="SupportCode">SupportCode</h2><p>在进入正题之前，先看下项目里的 <code>SupportCode.swift</code> ，主要为 playground 提供了两个便利函数。</p>
<p>一个是 <code>example</code> 函数，专门用来写示例代码的，统一输出 log 便于标记浏览，同时还能保持变量不污染全局：</p>
<pre><code><span class="keyword">public</span> <span class="func"><span class="keyword">func</span> <span class="title">example</span><span class="params">(description: String, action: <span class="params">()</span></span></span> -&gt; ()) {
    <span class="built_in">print</span>(<span class="string">"\n--- <span class="subst">\(description)</span> example ---"</span>)
    action()
}
</code></pre><p>另一个是 <code>delay</code> 函数，通过 <code>dispatch_after</code> 用来演示延时的：</p>
<pre><code>public func delay<span class="function"><span class="params">(delay:Double, closure:()-&gt;())</span> {
    <span class="title">dispatch_after</span><span class="params">(
        dispatch_time(
            DISPATCH_TIME_NOW,
            Int64(delay * Double(NSEC_PER_SEC))
        ),
        dispatch_get_main_queue(), closure)</span>
}</span>
</code></pre><h2 id="Introduction">Introduction</h2><p>主要介绍了 Rx 的基础： <code>Observable</code> 。 <code>Observable&lt;Element&gt;</code> 是观察者模式中被观察的对象，相当于一个事件序列 (<code>GeneratorType</code>) ，会向订阅者发送新产生的事件信息。事件信息分为三种： </p>
<ul>
<li><code>.Next(value)</code> 表示新的事件数据。</li>
<li><code>.Completed</code> 表示事件序列的完结。</li>
<li><code>.Error</code> 同样表示完结，但是代表异常导致的完结。</li>
</ul>
<p>（打个岔：协议命名，想起来上午汤哥在<a href="http://weibo.com/1747002695/CBH3I4a1X?from=page_1005051747002695_profile&amp;wvr=6&amp;mod=weibotime&amp;type=comment" target="_blank" rel="external">微博</a>说的一段话：</p>
<blockquote>
<p>另外，我觉得 protocol 名字用形容词会更加语义分明，比如 Swift : Flyable, Killable, Visible。全用名词的话显得比较生硬，比如 Swift : Head, Wings, Ass。</p>
</blockquote>
<h3 id="empty">empty</h3><p><code>empty</code> 是一个空的序列，它只发送 <code>.Completed</code> 消息。</p>
<pre><code>example(<span class="string">"empty"</span>) {
    <span class="keyword">let</span> emptySequence: Observable&lt;<span class="built_in">Int</span>&gt; = <span class="literal">empty</span>()

    <span class="keyword">let</span> subscription = emptySequence
        .subscribe { event <span class="keyword">in</span>
            print(event)
        }
}

--- <span class="literal">empty</span> example ---
Completed
</code></pre><h3 id="never">never</h3><p><code>never</code> 是没有任何元素、也不会发送任何事件的空序列。</p>
<pre><code>example(<span class="string">"never"</span>) {
    <span class="keyword">let</span> neverSequence: <span class="typename">Observable</span>&lt;String&gt; = never()

    <span class="keyword">let</span> subscription = neverSequence
        .subscribe { _ <span class="keyword">in</span>
            <span class="keyword">print</span>(<span class="string">"This block is never called."</span>)
        }
}

--- never example ---
</code></pre><h3 id="just">just</h3><p><code>just</code> 是只包含一个元素的序列，它会先发送 <code>.Next(value)</code> ，然后发送 <code>.Completed</code> 。</p>
<pre><code>example(<span class="string">"just"</span>) {
    <span class="keyword">let</span> singleElementSequence = just(<span class="number">32</span>)

    <span class="keyword">let</span> subscription = singleElementSequence
        .subscribe { <span class="function"><span class="keyword">event</span> <span class="keyword">in</span>
            <span class="title">print</span>(<span class="params"><span class="keyword">event</span></span>)
        }
}

--- just example ---
<span class="title">Next</span>(<span class="params"><span class="number">32</span></span>)
Completed</span>
</code></pre><h3 id="sequenceOf">sequenceOf</h3><p><code>sequenceOf</code> 可以把一系列元素转换成事件序列。</p>
<pre><code>example(<span class="string">"sequenceOf"</span>) {
    <span class="keyword">let</span> sequenceOfElements/* : Observable&lt;<span class="built_in">Int</span>&gt; */ = sequenceOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)

    <span class="keyword">let</span> subscription = sequenceOfElements
        .subscribe { event <span class="keyword">in</span>
            print(event)
        }
}

--- sequenceOf example ---
<span class="keyword">Next</span>(<span class="number">0</span>)
<span class="keyword">Next</span>(<span class="number">1</span>)
<span class="keyword">Next</span>(<span class="number">2</span>)
<span class="keyword">Next</span>(<span class="number">3</span>)
Completed
</code></pre><h3 id="form">form</h3><p><code>form</code> 是通过 <code>asObservable()</code> 方法把 Swift 中的序列 (<code>SequenceType</code>) 转换成事件序列。 </p>
<pre><code><span class="function"><span class="title">example</span><span class="params">(<span class="string">"from"</span>)</span> {
    <span class="title">let</span> <span class="title">sequenceFromArray</span> = [1, 2, 3, 4, 5].<span class="title">asObservable</span><span class="params">()</span>

    <span class="title">let</span> <span class="title">subscription</span> = <span class="title">sequenceFromArray</span>
        .<span class="title">subscribe</span> { <span class="title">event</span> <span class="title">in</span>
            <span class="title">print</span><span class="params">(event)</span>
        }
}

--- <span class="title">from</span> <span class="title">example</span> ---
N<span class="title">ext</span><span class="params">(<span class="number">1</span>)</span>
N<span class="title">ext</span><span class="params">(<span class="number">2</span>)</span>
N<span class="title">ext</span><span class="params">(<span class="number">3</span>)</span>
N<span class="title">ext</span><span class="params">(<span class="number">4</span>)</span>
N<span class="title">ext</span><span class="params">(<span class="number">5</span>)</span>
C<span class="title">ompleted</span></span>
</code></pre><h3 id="create">create</h3><p><code>create</code> 可以通过闭包创建序列，通过 <code>.on(e: Event)</code> 添加事件。</p>
<pre><code>example(<span class="string">"create"</span>) {
    <span class="keyword">let</span> myJust = { <span class="function"><span class="params">(singleElement: Int)</span> -&gt;</span> Observable&lt;Int&gt; <span class="keyword">in</span>
        <span class="keyword">return</span> create { observer <span class="keyword">in</span>
            observer.<span class="literal">on</span>(.Next(singleElement))
            observer.<span class="literal">on</span>(.Completed)

            <span class="keyword">return</span> NopDisposable.instance
        }
    }

    <span class="keyword">let</span> subscription = myJust(<span class="number">5</span>)
        .subscribe { event <span class="keyword">in</span>
            <span class="built_in">print</span>(event)
        }
}

--- create example ---
Next(<span class="number">5</span>)
Completed
</code></pre><h3 id="failWith">failWith</h3><p><code>failWith</code> 创建一个没有元素的序列，只会发送失败 (<code>.Error</code>) 事件。</p>
<pre><code>example(<span class="string">"failWith"</span>) {
    <span class="keyword">let</span> <span class="keyword">error</span> = NSError(domain: <span class="string">"Test"</span>, code: -<span class="number">1</span>, userInfo: nil)

    <span class="keyword">let</span> erroredSequence: Observable&lt;<span class="built_in">Int</span>&gt; = failWith(<span class="keyword">error</span>)

    <span class="keyword">let</span> subscription = erroredSequence
        .subscribe { event <span class="keyword">in</span>
            print(event)
        }
}

--- failWith example ---
<span class="keyword">Error</span>(<span class="keyword">Error</span> Domain=Test Code=-<span class="number">1</span> <span class="string">"The operation couldn’t be completed. (Test error -1.)"</span>)
</code></pre><h3 id="deferred">deferred</h3><p><code>deferred</code> 会等到有订阅者的时候再通过工厂方法创建 <code>Observable</code> 对象，每个订阅者订阅的对象都是内容相同而完全独立的序列。</p>
<pre><code>example(<span class="string">"deferred"</span>) {
    let deferredSequence: Observable&lt;<span class="keyword">Int</span>&gt; = deferred {
        <span class="keyword">print</span>(<span class="string">"creating"</span>)
        <span class="keyword">return</span> create { observer in
            <span class="keyword">print</span>(<span class="string">"emmiting"</span>)
            observer.on(.<span class="keyword">Next</span>(<span class="number">0</span>))
            observer.on(.<span class="keyword">Next</span>(<span class="number">1</span>))
            observer.on(.<span class="keyword">Next</span>(<span class="number">2</span>))

            <span class="keyword">return</span> NopDisposable.instance
        }
    }

    <span class="keyword">print</span>(<span class="string">"go"</span>)

    deferredSequence
        .subscribe { event in
            <span class="keyword">print</span>(event)
    }

    deferredSequence
        .subscribe { event in
            <span class="keyword">print</span>(event)
        }
}

--- deferred example ---
go
creating
emmiting
<span class="keyword">Next</span>(<span class="number">0</span>)
<span class="keyword">Next</span>(<span class="number">1</span>)
<span class="keyword">Next</span>(<span class="number">2</span>)
creating
emmiting
<span class="keyword">Next</span>(<span class="number">0</span>)
<span class="keyword">Next</span>(<span class="number">1</span>)
<span class="keyword">Next</span>(<span class="number">2</span>)
</code></pre><p>为什么需要 <code>defferd</code> 这样一个奇怪的家伙呢？其实这相当于是一种延时加载，因为在添加监听的时候数据未必加载完毕，例如下面这个例子：</p>
<pre><code>example(<span class="string">"TestDeferred"</span>) {
    <span class="keyword">var</span> <span class="keyword">value</span>: String? = nil
    <span class="keyword">var</span> subscription: Observable&lt;String?&gt; = just(<span class="keyword">value</span>)

    <span class="comment">// got value</span>
    <span class="keyword">value</span> = <span class="string">"Hello!"</span>

    subscription.subscribe { <span class="function"><span class="keyword">event</span> <span class="keyword">in</span>
        <span class="title">print</span>(<span class="params"><span class="keyword">event</span></span>)
    }
}

--- TestDeferred example ---
<span class="title">Next</span>(<span class="params">nil</span>)
Completed</span>
</code></pre><p>如果使用 <code>deffered</code> 则可以正常显示想要的数据：</p>
<pre><code>example(<span class="string">"TestDeferred"</span>) {
    <span class="keyword">var</span> <span class="keyword">value</span>: String? = nil
    <span class="keyword">var</span> subscription: Observable&lt;String?&gt; = deferred {
        <span class="keyword">return</span> just(<span class="keyword">value</span>)
    }

    <span class="comment">// got value</span>
    <span class="keyword">value</span> = <span class="string">"Hello!"</span>

    subscription.subscribe { <span class="function"><span class="keyword">event</span> <span class="keyword">in</span>
        <span class="title">print</span>(<span class="params"><span class="keyword">event</span></span>)
    }

}

--- TestDeferred example ---
<span class="title">Next</span>(<span class="params">Optional(<span class="string">"Hello!"</span></span>))
Completed</span>
</code></pre><h2 id="Subjects">Subjects</h2><p>接下来是关于 <code>Subject</code> 的内容。 <code>Subject</code> 可以看做是一种代理和桥梁。它既是订阅者又是订阅源，这意味着它既可以订阅其他 <code>Observable</code> 对象，同时又可以对它的订阅者们发送事件。</p>
<p>如果把 <code>Observable</code> 理解成不断输出事件的水管，那 <code>Subject</code> 就是套在上面的水龙头。它既怼着一根不断出水的水管，同时也向外面输送着新鲜水源。如果你直接用水杯接着水管的水，那可能导出来什么王水胶水完全把持不住；如果你在水龙头下面接着水，那你可以随心所欲的调成你想要的水速和水温。</p>
<p>（好吧上面一段文档里没有，是我瞎掰的，如果理解错了还望打脸(￣ε(#￣)☆╰╮(￣▽￣///))</p>
<p>在开始下面的代码之前，先定义一个辅助函数用于输出数据： </p>
<pre><code><span class="func"><span class="keyword">func</span> <span class="title">writeSequenceToConsole</span><span class="generics">&lt;O: ObservableType&gt;</span><span class="params">(name: String, sequence: O)</span></span> {
    sequence
        .subscribe { e <span class="keyword">in</span>
            <span class="built_in">print</span>(<span class="string">"Subscription: <span class="subst">\(name)</span>, event: <span class="subst">\(e)</span>"</span>)
        }
}
</code></pre><h3 id="PublishSubject">PublishSubject</h3><p><code>PublishSubject</code> 会发送订阅者从订阅之后的事件序列。</p>
<pre><code>example(<span class="string">"PublishSubject"</span>) {
    <span class="keyword">let</span> subject = PublishSubject&lt;<span class="built_in">String</span>&gt;()
    writeSequenceToConsole(<span class="string">"1"</span>, sequence: subject)
    subject.<span class="keyword">on</span>(.<span class="keyword">Next</span>(<span class="string">"a"</span>))
    subject.<span class="keyword">on</span>(.<span class="keyword">Next</span>(<span class="string">"b"</span>))
    writeSequenceToConsole(<span class="string">"2"</span>, sequence: subject)
    subject.<span class="keyword">on</span>(.<span class="keyword">Next</span>(<span class="string">"c"</span>))
    subject.<span class="keyword">on</span>(.<span class="keyword">Next</span>(<span class="string">"d"</span>))
}


--- PublishSubject example ---
Subscription: <span class="number">1</span>, event: <span class="keyword">Next</span>(a)
Subscription: <span class="number">1</span>, event: <span class="keyword">Next</span>(b)
Subscription: <span class="number">1</span>, event: <span class="keyword">Next</span>(c)
Subscription: <span class="number">2</span>, event: <span class="keyword">Next</span>(c)
Subscription: <span class="number">1</span>, event: <span class="keyword">Next</span>(d)
Subscription: <span class="number">2</span>, event: <span class="keyword">Next</span>(d)
</code></pre><h3 id="ReplaySubject">ReplaySubject</h3><p><code>ReplaySubject</code> 在新的订阅对象订阅的时候会补发所有已经发送过的数据队列， <code>bufferSize</code> 是缓冲区的大小，决定了补发队列的最大值。如果 <code>bufferSize</code> 是1，那么新的订阅者出现的时候就会补发上一个事件，如果是2，则补两个，以此类推。</p>
<pre><code>example(<span class="string">"ReplaySubject"</span>) {
    let subject = ReplaySubject&lt;String&gt;.create(<span class="string">bufferSize:</span> <span class="number">1</span>)

    writeSequenceToConsole(<span class="string">"1"</span>, <span class="string">sequence:</span> subject)
    subject.on(.Next(<span class="string">"a"</span>))
    subject.on(.Next(<span class="string">"b"</span>))
    writeSequenceToConsole(<span class="string">"2"</span>, <span class="string">sequence:</span> subject)
    subject.on(.Next(<span class="string">"c"</span>))
    subject.on(.Next(<span class="string">"d"</span>))
}

--- ReplaySubject example ---
<span class="string">Subscription:</span> <span class="number">1</span>, <span class="string">event:</span> Next(a)
<span class="string">Subscription:</span> <span class="number">1</span>, <span class="string">event:</span> Next(b)
<span class="string">Subscription:</span> <span class="number">2</span>, <span class="string">event:</span> Next(b) <span class="comment">// 补了一个 b</span>
<span class="string">Subscription:</span> <span class="number">1</span>, <span class="string">event:</span> Next(c)
<span class="string">Subscription:</span> <span class="number">2</span>, <span class="string">event:</span> Next(c)
<span class="string">Subscription:</span> <span class="number">1</span>, <span class="string">event:</span> Next(d)
<span class="string">Subscription:</span> <span class="number">2</span>, <span class="string">event:</span> Next(d)
</code></pre><h3 id="BehaviorSubject">BehaviorSubject</h3><p><code>BehaviorSubject</code> 在新的订阅对象订阅的时候会发送最近发送的事件，如果没有则发送一个默认值。</p>
<pre><code>example(<span class="string">"BehaviorSubject"</span>) {
    let subject = BehaviorSubject(<span class="string">value:</span> <span class="string">"z"</span>)
    writeSequenceToConsole(<span class="string">"1"</span>, <span class="string">sequence:</span> subject)
    subject.on(.Next(<span class="string">"a"</span>))
    subject.on(.Next(<span class="string">"b"</span>))
    writeSequenceToConsole(<span class="string">"2"</span>, <span class="string">sequence:</span> subject)
    subject.on(.Next(<span class="string">"c"</span>))
    subject.on(.Completed)
}

--- BehaviorSubject example ---
<span class="string">Subscription:</span> <span class="number">1</span>, <span class="string">event:</span> Next(z)
<span class="string">Subscription:</span> <span class="number">1</span>, <span class="string">event:</span> Next(a)
<span class="string">Subscription:</span> <span class="number">1</span>, <span class="string">event:</span> Next(b)
<span class="string">Subscription:</span> <span class="number">2</span>, <span class="string">event:</span> Next(b)
<span class="string">Subscription:</span> <span class="number">1</span>, <span class="string">event:</span> Next(c)
<span class="string">Subscription:</span> <span class="number">2</span>, <span class="string">event:</span> Next(c)
<span class="string">Subscription:</span> <span class="number">1</span>, <span class="string">event:</span> Completed
<span class="string">Subscription:</span> <span class="number">2</span>, <span class="string">event:</span> Completed
</code></pre><h3 id="Variable">Variable</h3><p><code>Variable</code> 是基于 <code>BehaviorSubject</code> 的一层封装，它的优势是：不会被显式终结。即：不会收到 <code>.Completed</code> 和 <code>.Error</code> 这类的终结事件，它会主动在析构的时候发送 <code>.Complete</code> 。</p>
<pre><code>example(<span class="string">"Variable"</span>) {
    <span class="keyword">let</span> <span class="annotation">variable</span> = Variable(<span class="string">"z"</span>)
    writeSequenceToConsole(<span class="string">"1"</span>, sequence: <span class="annotation">variable</span>)
    <span class="annotation">variable</span>.<span class="keyword">value</span> = <span class="string">"a"</span>
    <span class="annotation">variable</span>.<span class="keyword">value</span> = <span class="string">"b
    writeSequenceToConsole("</span><span class="number">2</span><span class="string">", sequence: variable)
    variable.value = "</span>c<span class="string">"
}

--- Variable example ---
Subscription: 1, event: Next(z)
Subscription: 1, event: Next(a)
Subscription: 1, event: Next(b)
Subscription: 2, event: Next(b)
Subscription: 1, event: Next(c)
Subscription: 2, event: Next(c)
Subscription: 1, event: Completed
Subscription: 2, event: Completed</span>
</code></pre><h2 id="Transform">Transform</h2><p>我们可以对序列做一些转换，类似于 Swift 中 <code>CollectionType</code> 的各种转换。在以前的坑中曾经提到过，可以参考：<a href="http://blog.callmewhy.com/2015/05/11/functional-reactive-programming-1/#函数式的函数/">函数式的函数</a>。</p>
<h3 id="map">map</h3><p><code>map</code> 就是对每个元素都用函数做一次转换，挨个映射一遍。</p>
<pre><code>example(<span class="string">"map"</span>) {
    let originalSequence = sequenceOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)

    originalSequence
        .map { <span class="variable">$0</span> * <span class="number">2</span> }
        .subscribe { print(<span class="variable">$0</span>) }
}

--- <span class="keyword">map</span> example ---
Next(<span class="number">2</span>)
Next(<span class="number">4</span>)
Next(<span class="number">6</span>)
Completed
</code></pre><h3 id="flatMap">flatMap</h3><p><code>map</code> 在做转换的时候很容易出现『升维』的情况，即：转变之后，从一个序列变成了一个序列的序列。</p>
<p>什么是『升维』？在集合中我们可以举这样一个例子，我有一个好友列表 <code>[p1, p2, p3]</code>，那么如果要获取我好友的好友的列表，可以这样做：</p>
<pre><code>myFriends.<span class="keyword">map</span> { <span class="variable">$0</span>.getFriends() }
</code></pre><p>结果就成了 <code>[[p1-1, p1-2, p1-3], [p2-1], [p3-1, p3-2]]</code> ，这就成了好友的好友列表的列表了。这就是一个『升维』的例子。</p>
<p>（以上内容文档中依旧没有，依旧是我瞎掰的，依旧欢迎有错误当面打脸(￣ε(#￣)☆╰╮(￣▽￣///))</p>
<p>在 Swift 中，我们可以用 <code>flatMap</code> 过滤掉 <code>map</code> 之后的 <code>nil</code> 结果。在 Rx 中， <code>flatMap</code> 可以把一个序列转换成一组序列，然后再把这一组序列『拍扁』成一个序列。</p>
<pre><code><span class="function"><span class="title">example</span><span class="params">(<span class="string">"flatMap"</span>)</span> {
    <span class="title">let</span> <span class="title">sequenceInt</span> = <span class="title">sequenceOf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span>
    <span class="title">let</span> <span class="title">sequenceString</span> = <span class="title">sequenceOf</span><span class="params">(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"--"</span>)</span>

    <span class="title">sequenceInt</span>
        .<span class="title">flatMap</span> { <span class="title">int</span> <span class="title">in</span>
            <span class="title">sequenceString</span>
        }
        .<span class="title">subscribe</span> {
            <span class="title">print</span><span class="params">($<span class="number">0</span>)</span>
        }
}

--- <span class="title">flatMap</span> <span class="title">example</span> ---
N<span class="title">ext</span><span class="params">(<span class="variable">A</span>)</span>
N<span class="title">ext</span><span class="params">(<span class="variable">B</span>)</span>
N<span class="title">ext</span><span class="params">(--)</span>
N<span class="title">ext</span><span class="params">(<span class="variable">A</span>)</span>
N<span class="title">ext</span><span class="params">(<span class="variable">B</span>)</span>
N<span class="title">ext</span><span class="params">(--)</span>
N<span class="title">ext</span><span class="params">(<span class="variable">A</span>)</span>
N<span class="title">ext</span><span class="params">(<span class="variable">B</span>)</span>
N<span class="title">ext</span><span class="params">(--)</span>
C<span class="title">ompleted</span></span>
</code></pre><h3 id="scan">scan</h3><p><code>scan</code> 有点像 <code>reduce</code> ，它会把每次的运算结果累积起来，作为下一次运算的输入值。</p>
<pre><code>example(<span class="string">"scan"</span>) {
    let sequenceToSum = sequenceOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)

    sequenceToSum
        .scan(<span class="number">0</span>) { acum, elem in
            acum + elem
        }
        .subscribe {
            print($<span class="number">0</span>)
        }
}

--- scan example ---
Next(<span class="number">0</span>)
Next(<span class="number">1</span>)
Next(<span class="number">3</span>)
Next(<span class="number">6</span>)
Next(<span class="number">10</span>)
Next(<span class="number">15</span>)
Completed
</code></pre><h2 id="Filtering">Filtering</h2><p>除了上面的各种转换，我们还可以对序列进行过滤。</p>
<h3 id="filter">filter</h3><p><code>filter</code> 只会让符合条件的元素通过。</p>
<pre><code>example(<span class="string">"filter"</span>) {
    let subscription = sequenceOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)
        .filter {
            $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span>
        }
        .subscribe {
            print($<span class="number">0</span>)
        }
}

--- filter example ---
Next(<span class="number">0</span>)
Next(<span class="number">2</span>)
Next(<span class="number">4</span>)
Next(<span class="number">6</span>)
Next(<span class="number">8</span>)
Completed
</code></pre><h3 id="distinctUntilChanged">distinctUntilChanged</h3><p><code>distinctUntilChanged</code> 会废弃掉重复的事件。</p>
<pre><code>example(<span class="string">"distinctUntilChanged"</span>) {
    let subscription = sequenceOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>)
        .distinctUntilChanged()
        .subscribe {
            print($<span class="number">0</span>)
        }
}

--- distinctUntilChanged example ---
Next(<span class="number">1</span>)
Next(<span class="number">2</span>)
Next(<span class="number">3</span>)
Next(<span class="number">1</span>)
Next(<span class="number">4</span>)
Completed
</code></pre><h3 id="take">take</h3><p><code>take</code> 只获取序列中的前 n 个事件，在满足数量之后会自动 <code>.Completed</code> 。</p>
<pre><code>example(<span class="string">"take"</span>) {
    let subscription = sequenceOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)
        .take(<span class="number">3</span>)
        .subscribe {
            print($<span class="number">0</span>)
        }
}

--- take example ---
Next(<span class="number">1</span>)
Next(<span class="number">2</span>)
Next(<span class="number">3</span>)
Completed
</code></pre><h2 id="Combining">Combining</h2><p>这部分是关于序列的运算，可以将多个序列源进行组合拼装成一个新的事件序列。</p>
<h3 id="startWith">startWith</h3><p><code>startWith</code> 会在队列开始之前插入一个事件元素。</p>
<pre><code>example(<span class="string">"startWith"</span>) {
    let subscription = sequenceOf(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)
        .startWith(<span class="number">3</span>)
        .subscribe {
            print($<span class="number">0</span>)
        }
}

--- startWith example ---
Next(<span class="number">3</span>)
Next(<span class="number">4</span>)
Next(<span class="number">5</span>)
Next(<span class="number">6</span>)
Completed
</code></pre><h3 id="combineLatest">combineLatest</h3><p>如果存在两条事件队列，需要同时监听，那么每当有新的事件发生的时候，<code>combineLatest</code> 会将每个队列的最新的一个元素进行合并。</p>
<pre><code>example(<span class="string">"combineLatest 1"</span>) {
    <span class="keyword">let</span> intOb1 = PublishSubject&lt;<span class="built_in">String</span>&gt;()
    <span class="keyword">let</span> intOb2 = PublishSubject&lt;<span class="built_in">Int</span>&gt;()

    combineLatest(intOb1, intOb2) {
        <span class="string">"\($0) \($1)"</span>
        }
        .subscribe {
            print($<span class="number">0</span>)
        }

    intOb1.<span class="keyword">on</span>(.<span class="keyword">Next</span>(<span class="string">"A"</span>))
    intOb2.<span class="keyword">on</span>(.<span class="keyword">Next</span>(<span class="number">1</span>))
    intOb1.<span class="keyword">on</span>(.<span class="keyword">Next</span>(<span class="string">"B"</span>))
    intOb2.<span class="keyword">on</span>(.<span class="keyword">Next</span>(<span class="number">2</span>))
}

--- combineLatest <span class="number">1</span> example ---
<span class="keyword">Next</span>(A <span class="number">1</span>)
<span class="keyword">Next</span>(B <span class="number">1</span>)
<span class="keyword">Next</span>(B <span class="number">2</span>)
</code></pre><h3 id="zip">zip</h3><p><code>zip</code> 人如其名，就是合并两条队列用的，不过它会等到两个队列的元素一一对应地凑齐了之后再合并，正如<a href="http://weibo.com/mrgreenhand" target="_blank" rel="external">百折不撓的米斯特菜</a>所提醒的， <code>zip</code> 就像是拉链一样，两根拉链拉着拉着合并到了一根上：</p>
<pre><code>example(<span class="string">"zip 1"</span>) {
    <span class="keyword">let</span> intOb1 = PublishSubject&lt;<span class="built_in">String</span>&gt;()
    <span class="keyword">let</span> intOb2 = PublishSubject&lt;<span class="built_in">Int</span>&gt;()
    zip(intOb1, intOb2) {
        <span class="string">"\($0) \($1)"</span>
        }
        .subscribe {
            print($<span class="number">0</span>)
        }
    intOb1.<span class="keyword">on</span>(.<span class="keyword">Next</span>(<span class="string">"A"</span>))
    intOb2.<span class="keyword">on</span>(.<span class="keyword">Next</span>(<span class="number">1</span>))
    intOb1.<span class="keyword">on</span>(.<span class="keyword">Next</span>(<span class="string">"B"</span>))
    intOb1.<span class="keyword">on</span>(.<span class="keyword">Next</span>(<span class="string">"C"</span>))
    intOb2.<span class="keyword">on</span>(.<span class="keyword">Next</span>(<span class="number">2</span>))
}

--- zip <span class="number">1</span> example ---
<span class="keyword">Next</span>(A <span class="number">1</span>)
<span class="keyword">Next</span>(B <span class="number">2</span>)
</code></pre><h3 id="marge">marge</h3><p><code>merge</code> 就是 merge 啦，把两个队列按照顺序组合在一起。</p>
<pre><code>example(<span class="string">"merge 1"</span>) {
    <span class="keyword">let</span> subject1 = PublishSubject&lt;<span class="built_in">Int</span>&gt;()
    <span class="keyword">let</span> subject2 = PublishSubject&lt;<span class="built_in">Int</span>&gt;()

    sequenceOf(subject1, subject2)
        .merge()
        .subscribeNext { <span class="built_in">int</span> <span class="keyword">in</span>
            print(<span class="built_in">int</span>)
        }

    subject1.<span class="keyword">on</span>(.<span class="keyword">Next</span>(<span class="number">1</span>))
    subject1.<span class="keyword">on</span>(.<span class="keyword">Next</span>(<span class="number">2</span>))
    subject2.<span class="keyword">on</span>(.<span class="keyword">Next</span>(<span class="number">3</span>))
    subject1.<span class="keyword">on</span>(.<span class="keyword">Next</span>(<span class="number">4</span>))
    subject2.<span class="keyword">on</span>(.<span class="keyword">Next</span>(<span class="number">5</span>))
}

--- merge <span class="number">1</span> example ---
<span class="number">1</span>
<span class="number">2</span>
<span class="number">3</span>
<span class="number">4</span>
<span class="number">5</span>
</code></pre><h3 id="switch">switch</h3><p>当你的事件序列是一个事件序列的序列 (<code>Observable&lt;Observable&lt;T&gt;&gt;</code>) 的时候，（可以理解成二维序列？），可以使用 <code>switch</code> 将序列的序列平铺成一维，并且在出现新的序列的时候，自动切换到最新的那个序列上。和 <code>merge</code> 相似的是，它也是起到了将多个序列『拍平』成一条序列的作用。</p>
<pre><code>example(<span class="string">"switchLatest"</span>) {
    let var1 = Variable(<span class="number">0</span>)

    let var2 = Variable(<span class="number">200</span>)

    <span class="comment">// var3 is like an Observable&lt;Observable&lt;Int&gt;&gt;</span>
    let var3 = Variable(var1)

    let d = var3
        .switchLatest()
        .subscribe {
            print($<span class="number">0</span>)
        }

    var1.value = <span class="number">1</span>
    var1.value = <span class="number">2</span>
    var1.value = <span class="number">3</span>
    var1.value = <span class="number">4</span>

    var3.value = var2
    var2.value = <span class="number">201</span>
    var1.value = <span class="number">5</span>

    var3.value = var1
    var2.value = <span class="number">202</span>
    var1.value = <span class="number">6</span>
}

--- switchLatest example ---
Next(<span class="number">0</span>)
Next(<span class="number">1</span>)
Next(<span class="number">2</span>)
Next(<span class="number">3</span>)
Next(<span class="number">4</span>)
Next(<span class="number">200</span>)
Next(<span class="number">201</span>)
Next(<span class="number">5</span>)
Next(<span class="number">6</span>)
</code></pre><p>注意，虽然都是『拍平』，但是和 <code>flatmap</code> 是不同的， <code>flatmap</code> 是将一条序列变成另一条序列，而这变换过程会让维度变高，所以需要『拍平』，而 <code>switch</code> 是将本来二维的序列（序列的序列）拍平成了一维的序列。</p>
<h2 id="Error_Handling">Error Handling</h2><p>在事件序列中，遇到异常也是很正常的事情，有以下几种处理异常的手段。</p>
<h3 id="catchError">catchError</h3><p><code>catchError</code> 可以捕获异常事件，并且在后面无缝接上另一段事件序列，丝毫没有异常的痕迹。</p>
<pre><code>example(<span class="string">"catchError 1"</span>) {
    <span class="keyword">let</span> sequenceThatFails = PublishSubject&lt;<span class="built_in">Int</span>&gt;()
    <span class="keyword">let</span> recoverySequence = sequenceOf(<span class="number">100</span>, <span class="number">200</span>)

    sequenceThatFails
        .catchError { <span class="keyword">error</span> <span class="keyword">in</span>
            return recoverySequence
        }
        .subscribe {
            print($<span class="number">0</span>)
        }

    sequenceThatFails.<span class="keyword">on</span>(.<span class="keyword">Next</span>(<span class="number">1</span>))
    sequenceThatFails.<span class="keyword">on</span>(.<span class="keyword">Next</span>(<span class="number">2</span>))
    sequenceThatFails.<span class="keyword">on</span>(.<span class="keyword">Error</span>(NSError(domain: <span class="string">"Test"</span>, code: <span class="number">0</span>, userInfo: nil)))
}

--- catchError <span class="number">1</span> example ---
<span class="keyword">Next</span>(<span class="number">1</span>)
<span class="keyword">Next</span>(<span class="number">2</span>)
<span class="keyword">Next</span>(<span class="number">100</span>)
<span class="keyword">Next</span>(<span class="number">200</span>)
Completed
</code></pre><h3 id="retry">retry</h3><p><code>retry</code> 顾名思义，就是在出现异常的时候会再去从头订阅事件序列，妄图通过『从头再来』解决异常。</p>
<pre><code>example(<span class="string">"retry"</span>) {
    <span class="keyword">var</span> <span class="keyword">count</span> = 1 <span class="comment">// bad practice, only for example purposes</span>
    let funnyLookingSequence: Observable&lt;Int&gt; = create { observer <span class="keyword">in</span>
        let <span class="keyword">error</span> = NSError(domain: <span class="string">"Test"</span>, code: 0, userInfo: nil)
        observer.<span class="keyword">on</span>(.Next(0))
        observer.<span class="keyword">on</span>(.Next(1))
        <span class="keyword">if</span> <span class="keyword">count</span> &lt; 2 {
            observer.<span class="keyword">on</span>(.<span class="keyword">Error</span>(<span class="keyword">error</span>))
            <span class="keyword">count</span>++
        }
        observer.<span class="keyword">on</span>(.Next(2))
        observer.<span class="keyword">on</span>(.Completed)

        <span class="keyword">return</span> NopDisposable.instance
    }

    funnyLookingSequence
        .retry()
        .subscribe {
            <span class="keyword">print</span>(<span class="label">$0</span>)
        }
}

--- retry example ---
Next(0)
Next(1)
Next(0)
Next(1)
Next(2)
Completed
</code></pre><h2 id="Utility">Utility</h2><p>这里列举了针对事件序列的一些方法。</p>
<h3 id="subscribe">subscribe</h3><p><code>subscribe</code> 在前面已经接触过了，有新的事件就会触发。</p>
<pre><code>example(<span class="string">"subscribe"</span>) {
    let sequenceOfInts = PublishSubject&lt;Int&gt;()

    sequenceOfInts
        .subscribe {
            print(<span class="variable">$0</span>)
        }

    sequenceOfInts.on(.Next(<span class="number">1</span>))
    sequenceOfInts.on(.Completed)
}

--- subscribe example ---
Next(<span class="number">1</span>)
Completed
</code></pre><h3 id="subscribeNext">subscribeNext</h3><p><code>subscribeNext</code> 也是订阅，但是只订阅 <code>.Next</code> 事件。</p>
<pre><code>example(<span class="string">"subscribeNext"</span>) {
    let sequenceOfInts = PublishSubject&lt;Int&gt;()

    sequenceOfInts
        .subscribeNext {
            print(<span class="variable">$0</span>)
        }

    sequenceOfInts.on(.Next(<span class="number">1</span>))
    sequenceOfInts.on(.Completed)
}

--- subscribeNext example ---
<span class="number">1</span>
</code></pre><h3 id="subscribeCompleted">subscribeCompleted</h3><p><code>subscribeCompleted</code> 是只订阅 <code>.Completed</code> 完成事件。</p>
<pre><code><span class="function"><span class="title">example</span><span class="params">(<span class="string">"subscribeCompleted"</span>)</span> {
    <span class="title">let</span> <span class="title">sequenceOfInts</span> = P<span class="title">ublishSubject</span>&lt;I<span class="title">nt</span>&gt;<span class="params">()</span>

    <span class="title">sequenceOfInts</span>
        .<span class="title">subscribeCompleted</span> {
            <span class="title">print</span><span class="params">(<span class="string">"It's completed"</span>)</span>
        }

    <span class="title">sequenceOfInts</span>.<span class="title">on</span><span class="params">(.<span class="variable">Next</span>(<span class="number">1</span>)</span>)
    <span class="title">sequenceOfInts</span>.<span class="title">on</span><span class="params">(.<span class="variable">Completed</span>)</span>
}

--- <span class="title">subscribeCompleted</span> <span class="title">example</span> ---
I<span class="title">t's</span> <span class="title">completed</span></span>
</code></pre><h3 id="subscribeError">subscribeError</h3><p><code>subscribeError</code> 只订阅 <code>.Error</code> 失败事件。</p>
<pre><code>example(<span class="string">"subscribeError"</span>) {
    <span class="keyword">let</span> sequenceOfInts = PublishSubject&lt;<span class="built_in">Int</span>&gt;()

    sequenceOfInts
        .subscribeError { <span class="keyword">error</span> <span class="keyword">in</span>
            print(<span class="keyword">error</span>)
        }

    sequenceOfInts.<span class="keyword">on</span>(.<span class="keyword">Next</span>(<span class="number">1</span>))
    sequenceOfInts.<span class="keyword">on</span>(.<span class="keyword">Error</span>(NSError(domain: <span class="string">"Examples"</span>, code: -<span class="number">1</span>, userInfo: nil)))
}

--- subscribeError example ---
<span class="keyword">Error</span> Domain=Examples Code=-<span class="number">1</span> <span class="string">"The operation couldn’t be completed. (Examples error -1.)"</span>
</code></pre><h3 id="doOn">doOn</h3><p><code>doOn</code> 可以监听事件，并且在事件发生之前调用。</p>
<pre><code><span class="function"><span class="title">example</span><span class="params">(<span class="string">"doOn"</span>)</span> {
    <span class="title">let</span> <span class="title">sequenceOfInts</span> = P<span class="title">ublishSubject</span>&lt;I<span class="title">nt</span>&gt;<span class="params">()</span>

    <span class="title">sequenceOfInts</span>
        .<span class="title">doOn</span> {
            <span class="title">print</span><span class="params">(<span class="string">"Intercepted event \($0)"</span>)</span>
        }
        .<span class="title">subscribe</span> {
            <span class="title">print</span><span class="params">($<span class="number">0</span>)</span>
        }

    <span class="title">sequenceOfInts</span>.<span class="title">on</span><span class="params">(.<span class="variable">Next</span>(<span class="number">1</span>)</span>)
    <span class="title">sequenceOfInts</span>.<span class="title">on</span><span class="params">(.<span class="variable">Completed</span>)</span>
}

--- <span class="title">doOn</span> <span class="title">example</span> ---
I<span class="title">ntercepted</span> <span class="title">event</span> N<span class="title">ext</span><span class="params">(<span class="number">1</span>)</span>
N<span class="title">ext</span><span class="params">(<span class="number">1</span>)</span>
I<span class="title">ntercepted</span> <span class="title">event</span> C<span class="title">ompleted</span>
C<span class="title">ompleted</span></span>
</code></pre><h2 id="Conditional">Conditional</h2><p>我们可以对多个事件序列做一些复杂的逻辑判断。</p>
<h3 id="takeUntil">takeUntil</h3><p><code>takeUntil</code> 其实就是 <code>take</code> ，它会在终于等到那个事件之后触发 <code>.Completed</code> 事件。</p>
<pre><code>example(<span class="string">"takeUntil"</span>) {
    <span class="keyword">let</span> originalSequence = PublishSubject&lt;<span class="built_in">Int</span>&gt;()
    <span class="keyword">let</span> whenThisSendsNextWorldStops = PublishSubject&lt;<span class="built_in">Int</span>&gt;()

    originalSequence
        .takeUntil(whenThisSendsNextWorldStops)
        .subscribe {
            print($<span class="number">0</span>)
        }

    originalSequence.<span class="keyword">on</span>(.<span class="keyword">Next</span>(<span class="number">1</span>))
    originalSequence.<span class="keyword">on</span>(.<span class="keyword">Next</span>(<span class="number">2</span>))

    whenThisSendsNextWorldStops.<span class="keyword">on</span>(.<span class="keyword">Next</span>(<span class="number">1</span>))

    originalSequence.<span class="keyword">on</span>(.<span class="keyword">Next</span>(<span class="number">3</span>))
}

--- takeUntil example ---
<span class="keyword">Next</span>(<span class="number">1</span>)
<span class="keyword">Next</span>(<span class="number">2</span>)
Completed
</code></pre><h3 id="takeWhile">takeWhile</h3><p><code>takeWhile</code> 则是可以通过状态语句判断是否继续 <code>take</code> 。</p>
<pre><code>example(<span class="string">"takeWhile"</span>) {
    <span class="keyword">let</span> sequence = PublishSubject&lt;<span class="built_in">Int</span>&gt;()
    sequence
        .takeWhile { <span class="built_in">int</span> <span class="keyword">in</span>
            <span class="built_in">int</span> &lt; <span class="number">2</span>
        }
        .subscribe {
            print($<span class="number">0</span>)
        }
    sequence.<span class="keyword">on</span>(.<span class="keyword">Next</span>(<span class="number">1</span>))
    sequence.<span class="keyword">on</span>(.<span class="keyword">Next</span>(<span class="number">2</span>))
    sequence.<span class="keyword">on</span>(.<span class="keyword">Next</span>(<span class="number">3</span>))
}

--- takeWhile example ---
<span class="keyword">Next</span>(<span class="number">1</span>)
Completed
</code></pre><h2 id="Aggregate">Aggregate</h2><p>我们可以对事件序列做一些集合运算。</p>
<h3 id="concat">concat</h3><p><code>concat</code> 可以把多个事件序列合并起来。 </p>
<pre><code>example(<span class="string">"concat"</span>) {
    let var1 = BehaviorSubject(value: <span class="number">0</span>)
    let var2 = BehaviorSubject(value: <span class="number">200</span>)

    <span class="comment">// var3 is like an Observable&lt;Observable&lt;Int&gt;&gt;</span>
    let var3 = BehaviorSubject(value: var1)

    let d = var3
        .concat()
        .subscribe {
            print($<span class="number">0</span>)
        }

    var1.on(.Next(<span class="number">1</span>))
    var1.on(.Next(<span class="number">2</span>))

    var3.on(.Next(var2))

    var2.on(.Next(<span class="number">201</span>))

    var1.on(.Next(<span class="number">3</span>))
    var1.on(.Completed)

    var2.on(.Next(<span class="number">202</span>))
}

--- concat example ---
Next(<span class="number">0</span>)
Next(<span class="number">1</span>)
Next(<span class="number">2</span>)
Next(<span class="number">3</span>)
Next(<span class="number">201</span>)
Next(<span class="number">202</span>)
</code></pre><h3 id="reduce">reduce</h3><p>这里的 <code>reduce</code> 和 <code>CollectionType</code> 中的 <code>reduce</code> 是一个意思，都是指通过对一系列数据的运算最后生成一个结果。</p>
<pre><code>example(<span class="string">"reduce"</span>) {
    sequenceOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)
        .reduce(<span class="number">0</span>, +)
        .subscribe {
            print($<span class="number">0</span>)
        }
}

--- reduce example ---
Next(<span class="number">45</span>)
Completed
</code></pre><h2 id="Connectable">Connectable</h2><p>坑待填，Xcode 里这个操场跑不起来了。</p>
<h2 id="Next">Next</h2><p>基础入门大概就是这些了，有了前面 《<a href="http://blog.callmewhy.com/2015/05/11/functional-reactive-programming-1/">Functional Reactive Programming in Swift - Part 1</a>》 的铺垫，似乎理解起来十分愉快，不过还是不够深入，在下一章会在具体项目中操练起来。</p>
<p>操练起来！跑个操场吧少年！</p>
<p>Run the playground in your Xcode!</p>
<hr>
<p>参考文献：</p>
<ul>
<li><a href="http://reactivex.io/intro.html" target="_blank" rel="external">ReactiveX</a></li>
<li><a href="http://neilpa.me/rac-marbles/" target="_blank" rel="external">RAC Marbles</a></li>
<li><a href="http://reactivex.io/documentation/operators/defer.html" target="_blank" rel="external">defer</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2011/08/a_detailed_explanation_of_jquery_deferred_object.html" target="_blank" rel="external">jQuery 的 deferred 对象详解</a></li>
<li><a href="http://blog.allenm.me/2012/01/jquery_deferred_promise_method/" target="_blank" rel="external">jQuery deferred 对象的 promise 方法</a></li>
<li><a href="http://blog.danlew.net/2015/07/23/deferring-observable-code-until-subscription-in-rxjava/" target="_blank" rel="external">Deferring Observable code until subscription in RxJava</a></li>
<li><a href="http://davesexton.com/blog/post/To-Use-Subject-Or-Not-To-Use-Subject.aspx" target="_blank" rel="external">To Use Subject Or Not To Use Subject?</a></li>
<li><a href="http://reactivex.io/documentation/operators/flatmap.html" target="_blank" rel="external">flatmap</a></li>
<li><a href="http://blog.danlew.net/2014/09/22/grokking-rxjava-part-2/" target="_blank" rel="external">Grokking RxJava, Part 2: Operator, Operator</a></li>
<li><a href="http://www.introtorx.com/Content/v1.0.10621.0/08_Transformation.html#SelectMany" target="_blank" rel="external">Transformation - Select Many</a></li>
<li><a href="http://fernandocejas.com/2015/01/11/rxjava-observable-tranformation-concatmap-vs-flatmap/" target="_blank" rel="external">RxJava Observable tranformation: concatMap() vs flatMap()</a></li>
<li><a href="http://jschneider.io/2014/11/26/Recursive-Observables-with-RxJava.html" target="_blank" rel="external">Recursive Observables with RxJava</a></li>
<li><a href="http://www.introtorx.com/Content/v1.0.10621.0/12_CombiningSequences.html" target="_blank" rel="external">Combining sequences</a></li>
<li><a href="http://reactivex.io/documentation/operators/switch.html" target="_blank" rel="external">switch</a></li>
<li><a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md" target="_blank" rel="external">RxSwift Getting Started</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[滚滚长江都是水，万事万物皆是流。]]>
    
    </summary>
    
      <category term="RxSwift" scheme="http://blog.callmewhy.com/tags/RxSwift/"/>
    
      <category term="开发笔记" scheme="http://blog.callmewhy.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用 Yeoman + AngularJS + Gulp 搭建 Web 应用]]></title>
    <link href="http://blog.callmewhy.com/2015/09/18/use-yeoman-with-angular-and-gulp/"/>
    <id>http://blog.callmewhy.com/2015/09/18/use-yeoman-with-angular-and-gulp/</id>
    <published>2015-09-18T01:28:43.000Z</published>
    <updated>2015-09-20T00:17:05.000Z</updated>
    <content type="html"><![CDATA[<p>最近在做一个简单的资源管理系统，以前都是 PHP+jQuery+Bootstrap 的组合，这一次想尝试一些没接触过的东西。在这里简单的总结一下在开发过程中用到的框架和工具。</p>
<p>总结的比较简单，新手上路，多多指教！各位如果感兴趣可以进入各个项目的主页深入了解。</p>
<p>另外，由于我曾经是一名 iOS 程序员（啊现在也是），在文章中可能会情不自禁地乱入一些 iOS 开发相关的东西，可以直接无视我。。。</p>
<h2 id="npm"><a href="https://www.npmjs.com/" target="_blank" rel="external">npm</a></h2><p>npm 是 NodeJS 的包管理工具，建议使用 <a href="https://github.com/tj/n" target="_blank" rel="external">n</a> 管理 NodeJS 版本，无痛体验 NodeJS 4.0 和 0.12 版本。</p>
<p>同时考虑到国内的网络环境，可以考虑使用 taobao 的 <a href="https://npm.taobao.org/" target="_blank" rel="external">npm 镜像</a>。</p>
<p>虽然 homebrew 是神器，但是还是不推荐使用 homebrew 安装 npm ，原因可见：<a href="https://gist.github.com/DanHerbert/9520689" target="_blank" rel="external">Fixing npm On Mac OS X for Homebrew Users</a>。用 npm 去管理 npm 再好不过了。</p>
<h2 id="Yeoman"><a href="http://yeoman.io/" target="_blank" rel="external">Yeoman</a></h2><p>在做开发的时候，各种文件的归类和摆放是一个很常见的问题，例如业务逻辑文件放在 app 文件夹，模板文件放在 template 文件夹，每次新建项目都要做一些重复的工作。</p>
<p>Yeoman 是一款脚手架工具，可以轻松地为你搭建一个项目的大体框架。可以通过 npm 安装：</p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> yo bower grunt-cli gulp</span>
</code></pre><p>安装完成之后，输入 <code>yo</code> 就可以开始搭建一个项目啦。不过似乎用了 taobao 的 npm 镜像之后，用 yo 安装 generator 会出现一些问题，可以直接用 npm 安装，例如安装 webapp 模板：</p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> generator-webapp</span>
</code></pre><p>接下来可以试着用 <code>yo webapp</code> 创建一个新项目，生成的目录结构是这样的：</p>
<pre><code>├── <span class="class">.bowerrc</span>
...
├── <span class="class">.editorconfig</span>
├── app
    ...
    ├── fonts
    ├── images
    ├── scripts
    │   └── main<span class="class">.js</span>
    └── styles
        └── main<span class="class">.css</span>
├── bower<span class="class">.json</span>
└── test
</code></pre><p>可以看到，不仅是 styles 和 scripts 这样的目录结构，包括 .editorconfig 和 .bowerrc 也是自动生成了。</p>
<p>在 iOS 里也有类似的脚手架：<a href="https://github.com/thoughtbot/liftoff" target="_blank" rel="external">liftoff</a>，不过似乎 Xcode7 遇到一些问题，等日后摸索一番再来汇报。</p>
<h2 id="Bower"><a href="http://bower.io/" target="_blank" rel="external">Bower</a></h2><p>两年前有幸看到了一系列很有意思的文章：<a href="http://segmentfault.com/a/1190000000349384" target="_blank" rel="external">30 天学习 30 种新技术系列</a>，当时跟着玩了一圈感觉十分好玩。就像是《七天七语言》和《七天七并发模型》一样，世界那么大，一起去看看。</p>
<p>第一次接触 Bower 就是缘于这其中的第一篇：<a href="http://segmentfault.com/a/1190000000349555" target="_blank" rel="external">Day 1: Bower —— 管理你的客户端依赖关系</a>。</p>
<p>使用方法很简单，首先通过 npm 安装 bower (前面安装 yo 的时候其实已经安装了)：</p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> bower</span>
</code></pre><p>然后就是无脑的 install 了，比如我要装个 Bootstrap ：</p>
<pre><code>bower <span class="operator"><span class="keyword">install</span> <span class="comment">--save bootstrap</span></span>
</code></pre><p>嗯就是这么简单。</p>
<p>在 iOS 中类似的依赖管理工具有 <a href="https://cocoapods.org/" target="_blank" rel="external">Cocoapods</a> 和 <a href="https://github.com/Carthage/Carthage" target="_blank" rel="external">Carthage</a> 。</p>
<h2 id="Angular"><a href="https://angularjs.org/" target="_blank" rel="external">Angular</a></h2><p>Angular 的种种好处就不多说了，双向绑定、依赖注入、指令系统、模板、路由，各种各种。再配合上 <a href="http://angular-ui.github.io/" target="_blank" rel="external">angular-ui</a>，写起项目来十分酸爽。</p>
<p>简单的演示一个小例子，通过 <a href="https://leancloud.cn/" target="_blank" rel="external">LeanCloud</a> 的 JS SDK 加载并显示数据：</p>
<p><img src="http://ww3.sinaimg.cn/large/61d238c7gw1ew6t3ecbaaj21kw0gzwjs.jpg" alt=""></p>
<p>首先定义一个 Provider ，添加获取数据的方法：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">getItems</span>(<span class="params">className, completion</span>) </span>{
    <span class="keyword">var</span> query = <span class="keyword">new</span> AV.Query(AV.Object.extend(<span class="string">'Article'</span>));
    query.find({
        success: <span class="function"><span class="keyword">function</span>(<span class="params">results</span>) </span>{
            <span class="keyword">var</span> r = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(results));
            completion(r);
        }
    })
}
</code></pre><p>然后定义界面：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"text-center"</span>&gt;
    &lt;<span class="keyword">div</span> ui-grid=<span class="string">"article.gridOptions"</span> ui-grid-edit <span class="type">class</span>=<span class="string">"grid"</span>&gt;&lt;/<span class="keyword">div</span>&gt;
&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>再通过 Controller 加载数据：</p>
<pre><code>/** @ngInject */
<span class="keyword">function</span> ArticleController(<span class="variable">$scope</span>, AVOS) {
    var vm = this;

    vm.gridOptions = {
        data: []
    };

    AVOS.getItems(<span class="string">'Article'</span>, function(result) {
        <span class="variable">$scope</span>.<span class="variable">$apply</span>(function(){
            vm.gridOptions.data = result.map(function(item) {
                return {
                    <span class="string">'index'</span>: item.index,
                    <span class="string">'content'</span>: item.content
                };
            });
        });
    });
}
</code></pre><p>和以前用 JS 直接操作 DOM 相比，ViewModel 的逻辑更加友好，做起数据加载刷新的时候尤其顺手。</p>
<h2 id="Gulp"><a href="http://gulpjs.com/" target="_blank" rel="external">Gulp</a></h2><p>前端项目经常需要进行许多次的类似任务，例如编译 Less ，压缩代码等等。这样单调而重复的任务，我们可以通过工具来完成。 gulp 就是一个不错的选择。</p>
<p>gulp 是一个基于流的构建工具，个人感觉比 grunt 更简单清晰，也解决了 grunt 插件职责不明的问题。</p>
<p>什么是『基于流』呢？可以看下一个简单示例：</p>
<pre><code>gulp.src(<span class="symbol">'client</span>/templates/*.jade')
    .pipe(jade<span class="literal">()</span>)
    .pipe(minify<span class="literal">()</span>)
    .pipe(gulp.dest(<span class="symbol">'build</span>/minified_templates'));
</code></pre><p>可以看到这样一个链式调用的结构，除了开头和结尾，每一个命令的输出都是下一个命令的输入。先把任务分解成一个一个的小模块，然后再各取所需，组装起来。</p>
<p>具体的教程可以参考官方文档，只需要了解 <code>gulp.src</code> 、 <code>gulp.dest</code> 、 <code>gulp.task</code> 、 <code>gulp.watch</code> 这几个基础 API 即可。</p>
<h2 id="DaoCloud"><a href="https://daocloud.io/" target="_blank" rel="external">DaoCloud </a></h2><p>为了避免每次都重复的部署新服务器，我们可以把项目通过 Docker 打包成应用，然后直接部署。DaoCloud 提供了一个容器云平台，可以直接部署 Docker 应用。</p>
<p>在我的新项目 Lastone 里，只要在根目录加上 Dockerfile 即可：</p>
<pre><code><span class="built_in">FROM</span> ubuntu:<span class="number">14.04</span>
<span class="built_in">MAINTAINER</span> callmewhy whywanghai@gmail.com

<span class="built_in">RUN</span> <span class="bash">apt-get update
</span><span class="built_in">RUN</span> <span class="bash">apt-get install -y nginx
</span>
<span class="built_in">ADD</span> <span class="bash">./www/lastone/dist /usr/share/nginx/html/lastone
</span>
<span class="built_in">EXPOSE</span> <span class="number">80</span>
CMD [<span class="string">"nginx"</span>, <span class="string">"-g"</span>, <span class="string">"daemon off;"</span>]
</code></pre><p>Dockerfile 的命令可以阅读 <a href="https://docs.docker.com/reference/builder/" target="_blank" rel="external">Dockerfile reference</a>。</p>
<p>Daocloud 默认是每次在代码库中 push 一个 tag 就会自动构建一次，所以基本不用操什么心，而且有一个永久免费的份额，基本够玩耍使用了。</p>
<h2 id="Next">Next</h2><p>以上就是这次折腾的一些笔记啦。下一个小项目准备试一下 <a href="https://facebook.github.io/react/" target="_blank" rel="external">React</a>。</p>
<p>最近准备做一些小项目，到处玩一玩，如果大家有什么有趣的东西欢迎分享给我。（纯洁的微笑：]</p>
]]></content>
    <summary type="html">
    <![CDATA[一个戴帽子的老男人，请带我飞！]]>
    
    </summary>
    
      <category term="Yeoman" scheme="http://blog.callmewhy.com/tags/Yeoman/"/>
    
      <category term="开发笔记" scheme="http://blog.callmewhy.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Uther 小记 - 一个简单地蠢萌机器人]]></title>
    <link href="http://blog.callmewhy.com/2015/08/09/how-to-make-uther/"/>
    <id>http://blog.callmewhy.com/2015/08/09/how-to-make-uther/</id>
    <published>2015-08-09T15:19:37.000Z</published>
    <updated>2015-09-14T13:32:32.000Z</updated>
    <content type="html"><![CDATA[<p>前阵子做了一个简单地蠢萌机器人 Uther ，主要实现以下功能：</p>
<ul>
<li>收到消息后解析情感并返回对应情感的颜文字</li>
<li>使用动画切换颜文字</li>
<li>显示并可编辑历史消息</li>
</ul>
<p>花了一周时间做了 1.0 然后上线，现在 1.2 版本刚刚审核通过。简单分享一下 Uther 从诞生到上线的过程。</p>
<p>代码开源在 Github: <a href="https://github.com/callmewhy/uther" target="_blank" rel="external">Uther</a>。比较粗糙，没有仔细整理，各位见笑啦。</p>
<p>AppStore 下载地址： <a href="https://itunes.apple.com/cn/app/uther/id1024104920" target="_blank" rel="external">Uther</a>。</p>
<h2 id="Project">Project</h2><p>对于一个全新的 iOS 的项目，我的流程主要分为以下几步。</p>
<h3 id="Xcode">Xcode</h3><p>这就不啰嗦了，直接创建一个 Swift 项目即可。不过我一般不会勾选 Xcode 自带的 git 选项，而会在后面手动配置。</p>
<h3 id="Git">Git</h3><p>通过 <code>git init</code> 初始化仓库，然后在 <a href="http://gitignore.io/" target="_blank" rel="external">gitignore.io</a> 找上对应的配置，填入 <code>.gitignore</code> 文件。至此， git 初始化完毕。可以提交一次 <code>commit</code> 保存。注意，个人习惯把 Pods 文件夹目录也放到 <code>.gitignore</code> 中，如果使用自动生成的配置文件，取消那一行注释即可。</p>
<h3 id="Cocoapods">Cocoapods</h3><p>创建 Podfile 文件，然后通过 <code>def</code> 按照模块定义，然后再配置各个 <code>target</code> ：</p>
<pre><code>platform <span class="symbol">:ios</span>, <span class="string">'8.0'</span>
use_frameworks!

<span class="function"><span class="keyword">def</span> <span class="title">import_networking</span></span>
    pod <span class="string">'Alamofire'</span>
    pod <span class="string">'Moya'</span>
<span class="keyword">end</span>

target <span class="string">'__placeholder__'</span> <span class="keyword">do</span>
    import_networking
<span class="keyword">end</span>
</code></pre><h3 id="Font">Font</h3><p>字体我以前一直用的是 Consolas ，后来在微博看到了汤哥的推荐从此成了 <a href="https://github.com/larsenwork/monoid" target="_blank" rel="external">Monoid</a> 的忠实粉丝。</p>
<h2 id="Develop">Develop</h2><h3 id="Folder">Folder</h3><p>开发过程中，我的文件夹目录一般如下：</p>
<pre><code>General
    <span class="string">|- Macro</span>
    <span class="string">|- Models</span>
    <span class="string">|- Tools</span>
        <span class="string">|- LOG.swift</span>
        <span class="string">|- GCD.swift</span>
    <span class="string">|- Models</span>

Sections
    <span class="string">|- Main</span>
        <span class="string">|- Preview</span>
        <span class="string">|- Setting</span>
    <span class="string">|- User</span>

Resources
</code></pre><h3 id="Tool">Tool</h3><p>接下来聊一聊项目中的通用工具类。</p>
<h4 id="GCD">GCD</h4><p>项目中使用 <a href="https://github.com/nghialv/GCD" target="_blank" rel="external">GCD</a> 这个库，封装了一些常见操作。然后定义了一个简单的 struct 封装一下常用的两个方法：</p>
<pre><code><span class="class"><span class="keyword">struct</span> <span class="title">GCD</span> </span>{
    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">async_in_worker</span><span class="params">(closure: GCDClosure)</span></span> {
        gcd.async(.<span class="type">Default</span>, closure: closure)
    }
    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">async_in_main</span><span class="params">(closure: GCDClosure)</span></span> {
        gcd.async(.<span class="type">Main</span>, closure: closure)
    }
}
</code></pre><h4 id="LOG">LOG</h4><p>项目中使用 <code>XCGLogger</code> 作为 Log 工具，配置起来十分方便，声明一个全局常量即可：</p>
<pre><code>let <span class="string">log:</span> XCGLogger = {
    let log = XCGLogger.defaultInstance()
    let <span class="string">logPath :</span> NSURL = cacheDirectory.URLByAppendingPathComponent(<span class="string">"XCGLogger.Log"</span>)
    log.setup(<span class="string">logLevel:</span> .Debug, <span class="string">showThreadName:</span> <span class="literal">true</span>, <span class="string">showLogLevel:</span> <span class="literal">true</span>, <span class="string">showFileNames:</span> <span class="literal">true</span>, <span class="string">showLineNumbers:</span> <span class="literal">false</span>, <span class="string">writeToFile:</span> logPath, <span class="string">fileLogLevel:</span> .Info)
    log.xcodeColorsEnabled = <span class="literal">true</span>
    log.xcodeColors = [
        .<span class="string">Verbose:</span> .lightGrey,
        .<span class="string">Debug:</span> .darkGrey,
        .<span class="string">Info:</span> .darkGreen,
        .<span class="string">Warning:</span> .orange,
        .<span class="string">Error:</span> .red,
        .<span class="string">Severe:</span> .whiteOnRed
    ]

    <span class="keyword">return</span> log
}()
</code></pre><h4 id="DB">DB</h4><p>数据库方面，我使用的是 <a href="https://github.com/stephencelis/SQLite.swift" target="_blank" rel="external">SQLite.swift</a> 。可以用泛型方便的拼接各种 SQL 语句：</p>
<pre><code><span class="keyword">typealias</span> <span class="type">Pid</span> = <span class="type">Int64</span>

<span class="class"><span class="keyword">struct</span> <span class="title">DB</span> </span>{
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">let</span> db = <span class="type">SQLite</span>.<span class="type">Database</span>(documentsDirectory.<span class="type">URLByAppendingPathComponent</span>(<span class="string">"uther.db"</span>).absoluteString!)

    <span class="class"><span class="keyword">struct</span> <span class="title">MessageDB</span> </span>{
        <span class="keyword">static</span> <span class="keyword">let</span> table = db[<span class="string">"message"</span>]
        <span class="comment">// 唯一索引，主键</span>
        <span class="keyword">static</span> <span class="keyword">let</span> pid = <span class="type">Expression</span>&lt;<span class="type">Pid</span>&gt;(<span class="string">"pid"</span>)
        <span class="comment">// 消息创建的时间</span>
        <span class="keyword">static</span> <span class="keyword">let</span> createdTime = <span class="type">Expression</span>&lt;<span class="type">NSTimeInterval</span>&gt;(<span class="string">"created_time"</span>)
        <span class="comment">// 消息的内容</span>
        <span class="keyword">static</span> <span class="keyword">let</span> content = <span class="type">Expression</span>&lt;<span class="type">String</span>&gt;(<span class="string">"content"</span>)
    }

    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">setupDatabase</span><span class="params">()</span></span> {
        db.create(table: <span class="type">MessageDB</span>.table, ifNotExists: <span class="literal">true</span>) { t <span class="keyword">in</span>
            t.column(<span class="type">MessageDB</span>.pid, primaryKey: <span class="literal">true</span>)
            t.column(<span class="type">MessageDB</span>.createdTime)
            t.column(<span class="type">MessageDB</span>.content)
        }
    }
}
</code></pre><h3 id="Flurry">Flurry</h3><p>使用 Flurry 做一些简单的统计，通过 extension 添加了一些代码。</p>
<p>比如一个全局配置的静态方法：</p>
<pre><code><span class="class"><span class="keyword">extension</span> <span class="title">Flurry</span> </span>{
    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">start</span><span class="params">()</span></span> {
        <span class="type">Flurry</span>.setUserID(<span class="type">Keychain</span>.userId);
        <span class="type">Flurry</span>.startSession(<span class="string">"YOUR_SESSION_ID"</span>);
    }

}
</code></pre><p>比如通过 enum 打一些 error log ：</p>
<pre><code><span class="comment">// ERROR</span>
<span class="class"><span class="keyword">extension</span> <span class="title">Flurry</span> </span>{
    <span class="class"><span class="keyword">enum</span> <span class="title">Error</span>: <span class="title">String</span> </span>{
        <span class="keyword">case</span> <span class="type">Setup</span>   = <span class="string">"SetupError"</span>
        <span class="keyword">case</span> <span class="type">Wenzhi</span>  = <span class="string">"WenzhiError"</span>
        <span class="func"><span class="keyword">func</span> <span class="title">logError</span><span class="params">(message: String)</span></span> {
            <span class="keyword">let</span> error = <span class="type">NSError</span>(domain: <span class="string">"com.callmewhy.uther"</span>, code: <span class="number">1001</span>, userInfo: [<span class="string">"Message"</span>: message])
            <span class="type">Flurry</span>.logError(<span class="keyword">self</span>.rawValue, message: message, error: error)
            log.error(message)
        }
    }
}
</code></pre><p>比如内嵌个 struct 来统计 Message 相关的行为数据：</p>
<pre><code><span class="comment">// MESSAGE</span>
<span class="class"><span class="keyword">extension</span> <span class="title">Flurry</span> </span>{
    <span class="class"><span class="keyword">struct</span> <span class="title">Message</span> </span>{
        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">let</span> send     = <span class="string">"Send Message"</span>
        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">let</span> receive  = <span class="string">"Receive Positive"</span>

        <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">sendMessage</span><span class="params">(l: Int)</span></span> {
            <span class="type">Flurry</span>.logEvent(send, withParameters: [<span class="string">"MessageLength"</span>: l])
        }

        <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">receivePositive</span><span class="params">(p: Double)</span></span> {
            <span class="type">Flurry</span>.logEvent(receive, withParameters: [<span class="string">"MessagePositive"</span>: p])
        }
    }

}
</code></pre><h3 id="Localization">Localization</h3><p>我们可以通过 extension 给 string 加上 Localization 的属性，返回本地化之后的字符串：</p>
<pre><code><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>{
    <span class="keyword">var</span> localized: <span class="type">String</span> {
        <span class="keyword">let</span> s = <span class="type">NSLocalizedString</span>(<span class="keyword">self</span>, tableName: <span class="literal">nil</span>, bundle: <span class="type">NSBundle</span>.mainBundle(), value: <span class="string">""</span>, comment: <span class="string">""</span>)
        <span class="keyword">return</span> s
    }
}
</code></pre><p>使用的时候直接调用 <code>&quot;LOCALIZATION_KEY&quot;.localized</code> 即可。</p>
<h3 id="Network">Network</h3><p>网络方面使用 Moya 作为业务和 Alamofire 的中间层。以前是自己做了个 <code>WhyEngine</code> 封装了 <code>Task</code> 和 <code>Request</code> ，后来有了 <a href="https://github.com/Moya/Moya" target="_blank" rel="external"><code>Moya</code></a> 就简单多了：</p>
<pre><code><span class="comment">// MARK: - MoyaProvider</span>
<span class="keyword">let</span> endpointResolver = { (endpoint: <span class="type">Endpoint</span>&lt;<span class="type">Sentiment</span>&gt;) -&gt; (<span class="type">NSURLRequest</span>) <span class="keyword">in</span>
    <span class="keyword">let</span> request: <span class="type">NSMutableURLRequest</span> = endpoint.urlRequest.mutableCopy() <span class="keyword">as</span>! <span class="type">NSMutableURLRequest</span>
    request.timeoutInterval = <span class="number">2.0</span>
    <span class="keyword">return</span> request
}
<span class="keyword">let</span> <span class="type">SentimentProvider</span> = <span class="type">MoyaProvider</span>(endpointResolver: endpointResolver)

<span class="comment">// <span class="doctag">TODO:</span> extension MoyaTarget to handle respose</span>
<span class="class"><span class="keyword">extension</span> <span class="title">MoyaProvider</span> </span>{
    <span class="keyword">typealias</span> positiveHandler = <span class="type">PositiveValue</span>? -&gt; <span class="type">Void</span>
    <span class="func"><span class="keyword">func</span> <span class="title">requestPositive</span><span class="params">(endpoint: T, completion: positiveHandler)</span></span> -&gt; <span class="type">Cancellable</span> {
        ...
    }
}

<span class="comment">// MARK: - MoyaTarget</span>
<span class="class"><span class="keyword">extension</span> <span class="title">Sentiment</span>: <span class="title">MoyaTarget</span> </span>{
    <span class="keyword">public</span> <span class="keyword">var</span> baseURL: <span class="type">NSURL</span> {
        <span class="keyword">return</span> <span class="type">NSURL</span>(string: <span class="string">"https://wenzhi.api.qcloud.com"</span>)!
    }

    <span class="keyword">public</span> <span class="keyword">var</span> path: <span class="type">String</span> {
        <span class="keyword">return</span> <span class="string">"api/sentiment/"</span>
    }
}
</code></pre><p>后面等上了 Swift2.0 可以扩展协议，就可以直接用 <code>MoyaTarget</code> 直接处理 <code>Response</code> 了。想直接把返回结果封装成 JSON 也很简单：</p>
<pre><code><span class="class"><span class="keyword">extension</span> <span class="title">MoyaProvider</span> </span>{
    <span class="func"><span class="keyword">func</span> <span class="title">requestJSON</span><span class="params">(endpoint: T, completion: <span class="params">(JSON?)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Cancellable</span> {
        <span class="keyword">return</span> <span class="keyword">self</span>.request(endpoint) { (data, status, response, error) <span class="keyword">in</span>
            <span class="keyword">if</span> <span class="keyword">let</span> d = data {
                <span class="keyword">let</span> json = <span class="type">JSON</span>(data: d)
                log.debug(<span class="string">"<span class="subst">\(json)</span>"</span>)
                completion(json)
            } <span class="keyword">else</span> {
                log.error(<span class="string">"<span class="subst">\(error)</span>"</span>)
                completion(<span class="literal">nil</span>)
            }
        }
    }
}
</code></pre><h2 id="小结">小结</h2><p>前面做过几个 Swift 项目，不过都是练练手的 Demo 级别。 Uther 算是第一个完全的 Swift 项目，没有任何 objc 的代码。这感觉真是爽，干净利落。 </p>
<p>Swift 的最佳实践还在探索中，Uther 项目有很多可以继续改进的地方。接下来的项目准备融入一些函数式编程的元素，进一步感受各种有趣的编程范型。</p>
<p>欢迎讨论，多多指教~</p>
]]></content>
    <summary type="html">
    <![CDATA[一个简单的 Swift 项目。]]>
    
    </summary>
    
      <category term="Uther" scheme="http://blog.callmewhy.com/tags/Uther/"/>
    
      <category term="开发笔记" scheme="http://blog.callmewhy.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 中的 NSTimer]]></title>
    <link href="http://blog.callmewhy.com/2015/07/06/weak-timer-in-ios/"/>
    <id>http://blog.callmewhy.com/2015/07/06/weak-timer-in-ios/</id>
    <published>2015-07-05T16:40:42.000Z</published>
    <updated>2015-07-21T06:20:32.000Z</updated>
    <content type="html"><![CDATA[<p>前阵子在整理公司项目的时候，发现老代码在使用 <code>NSTimer</code> 时出现了内存泄露。然后整理了一些 <code>NSTimer</code> 的相关内容。比较简单，各位见笑啦。</p>
<h2 id="NSTimer">NSTimer</h2><h3 id="fire">fire</h3><p>我们先用 <code>NSTimer</code> 来做个简单的计时器，每隔5秒钟在控制台输出 Fire 。比较想当然的做法是这样的：</p>
<pre><code><span class="class"><span class="keyword">@interface</span> <span class="title">DetailViewController</span> ()</span>
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSTimer</span> *timer;
<span class="keyword">@end</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">DetailViewController</span></span>
- (<span class="keyword">IBAction</span>)fireButtonPressed:(<span class="keyword">id</span>)sender {
    _timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">3.0</span>f
                                              target:<span class="keyword">self</span>
                                            selector:<span class="keyword">@selector</span>(timerFire:)
                                            userInfo:<span class="literal">nil</span>
                                             repeats:<span class="literal">YES</span>];
    [_timer fire];
}

-(<span class="keyword">void</span>)timerFire:(<span class="keyword">id</span>)userinfo {
    <span class="built_in">NSLog</span>(<span class="string">@"Fire"</span>);
}
<span class="keyword">@end</span>
</code></pre><p>运行之后确实在控制台每隔3秒钟输出一次 Fire ，然而当我们从这个界面跳转到其他界面的时候却发现：控制台还在源源不断的输出着 Fire 。看来 <code>Timer</code> 并没有停止。</p>
<h3 id="invalidate">invalidate</h3><p>既然没有停止，那我们在 <code>DemoViewController</code> 的 <code>dealloc</code> 里加上 <code>invalidate</code> 的方法：</p>
<pre><code>-(<span class="keyword">void</span>)dealloc {
    [_timer invalidate];
    <span class="built_in">NSLog</span>(<span class="string">@"%@ dealloc"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> class]));
}
</code></pre><p>再次运行，还是没有停止。原因是 <code>Timer</code> 添加到 <code>Runloop</code> 的时候，会被 <code>Runloop</code> 强引用：</p>
<blockquote>
<p>Note in particular that run loops maintain strong references to their timers, so you don’t have to maintain your own strong reference to a timer after you have added it to a run loop. </p>
</blockquote>
<p>然后 <code>Timer</code> 又会有一个对 <code>Target</code> 的强引用（也就是 self ）：</p>
<blockquote>
<p>Target is the object to which to send the message specified by aSelector when the timer fires. The timer maintains a strong reference to target until it (the timer) is invalidated.</p>
</blockquote>
<p>也就是说 <code>NSTimer</code> 强引用了 <code>self</code> ，导致 <code>self</code> 一直不能被释放掉，所以也就走不到 <code>self</code> 的 <code>dealloc</code> 里。</p>
<p>既然如此，那我们可以再加个 <code>invalidate</code> 按钮：</p>
<pre><code><span class="tag">-</span> (IBAction)<span class="tag">invalidateButtonPressed</span>:(id)<span class="tag">sender</span> {
    <span class="attr_selector">[_timer invalidate]</span>;
}
</code></pre><p>嗯这样就可以了。（在 <a href="http://stackoverflow.com/questions/15170518/how-to-stop-invalidate-nstimer" target="_blank" rel="external">SOF</a> 上有人说该在 <code>invalidate</code> 之后执行 <code>_timer = nil</code> ，未能理解为什么，如果你知道原因可以告诉我：）</p>
<p>在 <code>invalidate</code> 方法的文档里还有这这样一段话：</p>
<blockquote>
<p>You must send this message from the thread on which the timer was installed. If you send this message from another thread, the input source associated with the timer may not be removed from its run loop, which could prevent the thread from exiting properly.</p>
</blockquote>
<p><code>NSTimer</code> 在哪个线程创建就要在哪个线程停止，否则会导致资源不能被正确的释放。看起来各种坑还不少。</p>
<h3 id="dealloc">dealloc</h3><p>那么问题来了：如果我就是想让这个 <code>NSTimer</code> 一直输出，直到 <code>DemoViewController</code> 销毁了才停止，我该如何让它停止呢？</p>
<ul>
<li>NSTimer 被 Runloop 强引用了，如果要释放就要调用 <code>invalidate</code> 方法。</li>
<li>但是我想在 <code>DemoViewController</code> 的 <code>dealloc</code> 里调用 <code>invalidate</code> 方法，但是 <code>self</code> 被 <code>NSTimer</code> 强引用了。</li>
<li>所以我还是要释放 <code>NSTimer</code> 先，然而不调用 <code>invalidate</code> 方法就不能释放它。</li>
<li>然而你不进入到 <code>dealloc</code> 方法里我又不能调用 <code>invalidate</code> 方法。</li>
<li>嗯…</li>
</ul>
<p><img src="http://ww4.sinaimg.cn/large/61d238c7gw1ettf9re22uj20fu08owf3.jpg" alt=""></p>
<h2 id="HWWeakTimer">HWWeakTimer</h2><h3 id="weakSelf">weakSelf</h3><p>问题的关键就在于 <code>self</code> 被 <code>NSTimer</code> 强引用了，如果我们能打破这个强引用问题自然而然就解决了。所以一个很简单的想法就是：<code>weakSelf</code>：</p>
<pre><code>__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;
_timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">3.0</span>f
                                          target:weakSelf
                                        selector:<span class="keyword">@selector</span>(timerFire:)
                                        userInfo:<span class="literal">nil</span>
                                         repeats:<span class="literal">YES</span>];
</code></pre><p>然而这并没有什么卵用，这里的 <code>__weak</code> 和 <code>__strong</code> 唯一的区别就是：如果在这两行代码执行的期间 <code>self</code> 被释放了， <code>NSTimer</code> 的 <code>target</code> 会变成 <code>nil</code> 。</p>
<h3 id="target">target</h3><p>既然没办法通过 <code>__weak</code> 把 <code>self</code> 抽离出来，我们可以造个假的 <code>target</code> 给 <code>NSTimer</code> 。这个假的 <code>target</code> 类似于一个中间的代理人，它做的唯一的工作就是挺身而出接下了 <code>NSTimer</code> 的强引用。类声明如下：</p>
<pre><code><span class="variable">@interface</span> <span class="attribute">HWWeakTimerTarget </span>: NSObject
<span class="variable">@property</span> (nonatomic, weak) id target;
<span class="variable">@property</span> (nonatomic, assign) SEL selector;
<span class="variable">@property</span> (nonatomic, weak) NSTimer* timer;
<span class="variable">@end</span>

<span class="variable">@implementation</span> HWWeakTimerTarget
- (void) <span class="attribute">fire</span>:(NSTimer *)timer {
    <span class="tag">if</span>(self.target) {
        <span class="attr_selector">[self.target performSelector:self.selector withObject:timer.userInfo]</span>;
    } else {
        <span class="attr_selector">[self.timer invalidate]</span>;
    }
}
<span class="variable">@end</span>
</code></pre><p>然后我们再封装个假的 <code>scheduledTimerWithTimeInterval</code> 方法，但是在调用的时候已经偷梁换柱了：</p>
<pre><code>+ <span class="list">(<span class="keyword">NSTimer</span> <span class="variable">*) scheduledTimerWithTimeInterval:(NSTimeInterval)interval
                                      target:(id)aTarget
                                    selector:(SEL)aSelector
                                    userInfo:(id)userInfo
                                     repeats:(BOOL)repeats {
    HWWeakTimerTarget*</span> timerTarget = [[HWWeakTimerTarget alloc] init]<span class="comment">;</span>
    timerTarget.target = aTarget<span class="comment">;</span>
    timerTarget.selector = aSelector<span class="comment">;</span>
    timerTarget.timer = [NSTimer scheduledTimerWithTimeInterval<span class="keyword">:interval</span>
                                                         target<span class="keyword">:timerTarget</span>
                                                       selector:@selector<span class="list">(<span class="keyword">fire</span>:)</span>
                                                       userInfo<span class="keyword">:userInfo</span>
                                                        repeats<span class="keyword">:repeats</span>]<span class="comment">;</span>
    return timerTarget.timer<span class="comment">;</span>
}</span>
</code></pre><p>再次运行，问题解决。</p>
<h3 id="block">block</h3><p>如果能用 <code>block</code> 来调用 <code>NSTimer</code> 那岂不是更好了。我们可以这样来实现：</p>
<pre><code>+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval
                                      <span class="built_in">block</span>:(HWTimerHandler)<span class="built_in">block</span>
                                   <span class="keyword">user</span>Info:(id)<span class="keyword">user</span>Info
                                    repeats:(BOOL)repeats {
    return [<span class="literal">self</span> scheduledTimerWithTimeInterval:interval
                                         target:<span class="literal">self</span>
                                       selector:@selector(_timerBlockInvoke:)
                                       <span class="keyword">user</span>Info:@[[<span class="built_in">block</span> copy], <span class="keyword">user</span>Info]
                                        repeats:repeats];
}

+ (void)_timerBlockInvoke:(NSArray*)<span class="keyword">user</span>Info {
    HWTimerHandler <span class="built_in">block</span> = <span class="keyword">user</span>Info[<span class="number">0</span>];
    id info = <span class="keyword">user</span>Info[<span class="number">1</span>];
    // or `!<span class="built_in">block</span> ?: <span class="built_in">block</span>();` @sunnyxx
    if (<span class="built_in">block</span>) {
        <span class="built_in">block</span>(info);
    }
}
</code></pre><p>这样我们就可以直接在 <code>block</code> 里写相关逻辑了：</p>
<pre><code>- (IBAction)<span class="string">fireButtonPressed:</span>(id)sender {
    _timer = [HWWeakTimer <span class="string">scheduledTimerWithTimeInterval:</span><span class="number">3.0</span>f <span class="string">block:</span>^(id userInfo) {
        NSLog(@<span class="string">"%@"</span>, userInfo);
    } <span class="string">userInfo:</span>@<span class="string">"Fire"</span> <span class="string">repeats:</span>YES];
    [_timer fire];
}
</code></pre><p>嗯就是这样。</p>
<h2 id="More">More</h2><p>把上面的的代码简单的封装到了 <a href="https://github.com/ChatGame/HWWeakTimer" target="_blank" rel="external"><code>HWWeakTimer</code></a> 中，欢迎试用。</p>
<h2 id="More_More">More More</h2><p>感谢 <a href="http://weibo.com/easyios" target="_blank" rel="external">@代码不会写</a> 和 @<a href="http://weibo.com/msching" target="_blank" rel="external">程寅zju</a> 的提醒，提供了另一个更为简洁的<a href="https://github.com/easyui/EZToolKit/blob/master/EZToolKit/EZCategory/NSTimer%2BEZ_Helper.m" target="_blank" rel="external">方案</a>：</p>
<pre><code><span class="comment">//</span>
<span class="comment">//  NSTimer+EZ_Helper.m</span>
<span class="comment">//  EZToolKit</span>
<span class="comment">//</span>
<span class="comment">//  Created by yangjun zhu on 15/5/20.</span>
<span class="comment">//  Copyright (c) 2015年 Cactus. All rights reserved.</span>
<span class="comment">//</span>

<span class="preprocessor">#import <span class="title">"NSTimer+EZ_Helper.h"</span></span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">NSTimer</span> (<span class="title">EZ_Helper</span>)</span>
+ (<span class="built_in">NSTimer</span> *)ez_scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)inTimeInterval block:(<span class="keyword">void</span> (^)())inBlock repeats:(<span class="built_in">BOOL</span>)inRepeats
{
    <span class="keyword">void</span> (^block)() = [inBlock <span class="keyword">copy</span>];
    <span class="built_in">NSTimer</span> * timer = [<span class="keyword">self</span> scheduledTimerWithTimeInterval:inTimeInterval target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(__executeTimerBlock:) userInfo:block repeats:inRepeats];
    <span class="keyword">return</span> timer;
}

+ (<span class="built_in">NSTimer</span> *)ez_timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)inTimeInterval block:(<span class="keyword">void</span> (^)())inBlock repeats:(<span class="built_in">BOOL</span>)inRepeats
{
    <span class="keyword">void</span> (^block)() = [inBlock <span class="keyword">copy</span>];
    <span class="built_in">NSTimer</span> * timer = [<span class="keyword">self</span> timerWithTimeInterval:inTimeInterval target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(__executeTimerBlock:) userInfo:block repeats:inRepeats];
    <span class="keyword">return</span> timer;
}

+ (<span class="keyword">void</span>)__executeTimerBlock:(<span class="built_in">NSTimer</span> *)inTimer;
{
    <span class="keyword">if</span>([inTimer userInfo])
    {
        <span class="keyword">void</span> (^block)() = (<span class="keyword">void</span> (^)())[inTimer userInfo];
        block();
    }
}
<span class="keyword">@end</span>
</code></pre><hr>
<p>参考文献：</p>
<ul>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSTimer_Class/" target="_blank" rel="external">NStimer</a></li>
<li><a href="http://stackoverflow.com/questions/15170518/how-to-stop-invalidate-nstimer" target="_blank" rel="external">How to stop/invalidate NStimer</a></li>
<li><a href="http://stackoverflow.com/questions/16821736/weak-reference-to-nstimer-target-to-prevent-retain-cycle" target="_blank" rel="external">Weak Reference to NSTimer Target To Prevent Retain Cycle</a></li>
<li><a href="http://stackoverflow.com/questions/7017281/performselector-may-cause-a-leak-because-its-selector-is-unknown" target="_blank" rel="external">performSelector may cause a leak because its selector is unknown</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[Timer ！放开那个 self 让我来！]]>
    
    </summary>
    
      <category term="Timer" scheme="http://blog.callmewhy.com/tags/Timer/"/>
    
      <category term="开发笔记" scheme="http://blog.callmewhy.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Clojure 每日练习]]></title>
    <link href="http://blog.callmewhy.com/2015/06/29/4clojure-everyday/"/>
    <id>http://blog.callmewhy.com/2015/06/29/4clojure-everyday/</id>
    <published>2015-06-29T11:59:42.000Z</published>
    <updated>2015-12-07T02:15:49.000Z</updated>
    <content type="html"><![CDATA[<p>最近公司的 iOS 项目进入 Debug 阶段，有些沉闷。于是乎从今天开始，尝试每天做一些 Clojure 的练习，找找刺激。<a href="http://www.4clojure.com/" target="_blank" rel="external">4clojure</a> 是个不错的网站，上面有很多 Clojure 的小题目，可以学习并巩固 Clojure 的知识。在每一题后面都附上了一段代码，包含：注释了的题目、我的答案和其他人的参考答案，欢迎一起讨论~</p>
<h3 id="#001:_Nothing_but_the_Truth"><a href="http://www.4clojure.com/problem/1" target="_blank" rel="external">#001: Nothing but the Truth</a></h3><pre><code><span class="comment">;; This is a clojure form.</span>
<span class="comment">;; Enter a value which will make the form evaluate to true.</span>
<span class="comment">;; Don't over think it!</span>
<span class="comment">;; Hint: true is equal to true.</span>
<span class="comment">;; (= __ true)</span>

<span class="list">(<span class="keyword"><span class="built_in">=</span></span> <span class="list">(<span class="keyword"><span class="built_in">+</span></span> <span class="number">1</span> <span class="number">1</span>)</span> <span class="number">2</span>)</span>

<span class="list">(<span class="keyword"><span class="built_in">not</span></span> <span class="literal">false</span>)</span>
</code></pre><h3 id="#002:_Simple_Math"><a href="http://www.4clojure.com/problem/2" target="_blank" rel="external">#002: Simple Math</a></h3><pre><code>;; If you are<span class="instruction"> not </span>familiar with polish notation
;; , simple arithmetic might seem confusing.
;; Note: Enter only enough to<span class="instruction"> fill </span>in the blank
;; In this case, a single number.
;;<span class="function"> (</span>=<span class="function"> (</span>- 10<span class="function"> (</span>* 2 3<span class="function">)</span><span class="function">)</span> __<span class="function">)</span>

4
</code></pre><h3 id="#003:_Intro_to_Strings"><a href="http://www.4clojure.com/problem/3" target="_blank" rel="external">#003: Intro to Strings</a></h3><pre><code><span class="comment">;; Clojure strings are Java strings.  </span>
<span class="comment">;; This means that you can use any of the Java string methods on Clojure strings.</span>
<span class="comment">;; (= __ (.toUpperCase "hello world"))</span>

<span class="string">"HELLO WORLD"</span>

<span class="list">(<span class="keyword"><span class="built_in">reify</span></span> Object <span class="list">(<span class="keyword">equals</span> <span class="collection">[_ _]</span> <span class="list">(<span class="keyword"><span class="built_in">=</span></span> _)</span>)</span>)</span> <span class="comment">;; 花样炫技</span>
</code></pre><h3 id="#004:_Intro_to_Lists"><a href="http://www.4clojure.com/problem/4" target="_blank" rel="external">#004: Intro to Lists</a></h3><pre><code>;; Lists can be constructed with either a function or a quoted form.
;; (= (list _<span class="emphasis">_) '(:a :b :c))

</span><span class="attribute">:a :b</span> :c
</code></pre><h3 id="#005:_Lists:_conj"><a href="http://www.4clojure.com/problem/5" target="_blank" rel="external">#005: Lists: conj</a></h3><pre><code>;; <span class="keyword">When</span> operating <span class="keyword">on</span> a list, the conj <span class="keyword">function</span> will <span class="keyword">return</span>
;; a <span class="keyword">new</span> list <span class="keyword">with</span> one <span class="keyword">or</span> more items <span class="string">"added"</span> <span class="keyword">to</span> the front.
;; (= __ (conj <span class="comment">'(2 3 4) 1))</span>

<span class="comment">'(1 2 3 4)</span>
</code></pre><h3 id="#006:_Intro_to_Vectors"><a href="http://www.4clojure.com/problem/6" target="_blank" rel="external">#006: Intro to Vectors</a></h3><pre><code>;; Vectors can be constructed several ways.  You can compare them with lists.
;; (= [_<span class="emphasis">_] (list :a :b :c) (vec '(:a :b :c)) (vector :a :b :c))

</span><span class="attribute">:a :b</span> :c
</code></pre><h3 id="#007:_Vectors:_conj"><a href="http://www.4clojure.com/problem/7" target="_blank" rel="external">#007: Vectors: conj</a></h3><pre><code>;; When operating on a Vector, the conj function will <span class="keyword">return</span> a <span class="keyword">new</span> <span class="built_in">vector</span> with one or
;; more items <span class="string">"added"</span> to the end.
;; (= __ (conj [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>] <span class="number">4</span>))

[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]
</code></pre><h3 id="#008:_Intro_to_Sets"><a href="http://www.4clojure.com/problem/8" target="_blank" rel="external">#008: Intro to Sets</a></h3><pre><code><span class="comment">;; Sets are collections of unique values.</span>
<span class="comment">;; (= __ (set '(:a :a :b :c :c :c :c :d :d)))</span>

<span class="comment">#{:a :b :c :d}</span>
</code></pre><h3 id="#009:_Sets:_conj"><a href="http://www.4clojure.com/problem/9" target="_blank" rel="external">#009: Sets: conj</a></h3><pre><code>;; When operating on a <span class="built_in">set</span>, the conj function returns a <span class="keyword">new</span> <span class="built_in">set</span> with one or more keys
;; <span class="string">"added"</span>.
;; (= <span class="preprocessor">#{<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>} (conj #{<span class="number">1</span> <span class="number">4</span> <span class="number">3</span>} __))</span>

<span class="number">2</span>
</code></pre><h3 id="#010:_Intro_to_Maps"><a href="http://www.4clojure.com/problem/10" target="_blank" rel="external">#010: Intro to Maps</a></h3><pre><code><span class="comment">;; Maps store key-value pairs.  Both maps and keywords can be used as lookup functions.</span>
<span class="comment">;; Commas can be used to make maps more readable, but they are not required.</span>
<span class="comment">;; (= __ ((hash-map :a 10, :b 20, :c 30) :b))</span>

20
</code></pre><h3 id="#011:_Maps:_conj"><a href="http://www.4clojure.com/problem/11" target="_blank" rel="external">#011: Maps: conj</a></h3><pre><code>;; When operating on a <span class="built_in">map</span>, the conj function returns a <span class="keyword">new</span> <span class="built_in">map</span> with one or more
;; key-value pairs <span class="string">"added"</span>.
;; (= {:a <span class="number">1</span>, :b <span class="number">2</span>, :c <span class="number">3</span>} (conj {:a <span class="number">1</span>} __ [:c <span class="number">3</span>]))

{:b <span class="number">2</span>}

[:b <span class="number">2</span>]
</code></pre><h3 id="#012:_Intro_to_Sequences"><a href="http://www.4clojure.com/problem/12" target="_blank" rel="external">#012: Intro to Sequences</a></h3><pre><code>;; All Clojure collections support sequencing.  You can operate <span class="function_start"><span class="keyword">on</span></span> sequences <span class="keyword">with</span>
;; functions like <span class="keyword">first</span>, <span class="keyword">second</span>, <span class="keyword">and</span> <span class="keyword">last</span>.
;; (= __ (<span class="keyword">first</span> '(<span class="number">3</span> <span class="number">2</span> <span class="number">1</span>)))

<span class="number">3</span>
</code></pre><h3 id="#013:_Intro_to_Sequences"><a href="http://www.4clojure.com/problem/13" target="_blank" rel="external">#013: Intro to Sequences</a></h3><pre><code>;; The rest function will <span class="keyword">return</span> all the items of a sequence except the first.
;; (= __ (rest [<span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span>]))
(= [<span class="number">20</span> <span class="number">30</span> <span class="number">40</span>] (rest [<span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span>]))

[<span class="number">20</span> <span class="number">30</span> <span class="number">40</span>]
</code></pre><h3 id="#014:_Intro_to_Functions"><a href="http://www.4clojure.com/problem/14" target="_blank" rel="external">#014: Intro to Functions</a></h3><pre><code>;; Clojure has many different ways to create functions.
;;<span class="function"> (</span>= __<span class="function"> (</span>(fn<span class="instruction"> add-five </span><span class="keyword">[</span>x]<span class="function"> (</span>+ x 5<span class="function">)</span><span class="function">)</span> 3<span class="function">)</span><span class="function">)</span>

8
</code></pre><h3 id="#015:_Double_Down"><a href="http://www.4clojure.com/problem/15" target="_blank" rel="external">#015: Double Down</a></h3><pre><code><span class="comment">;; Write a function which doubles a number.</span>
<span class="comment">;; (= (__ 2) 4)</span>

#<span class="list">(<span class="keyword">*</span> <span class="number">2</span> %)</span>

* <span class="number">2</span>
<span class="list">(<span class="keyword">fn</span> [x] <span class="list">(<span class="keyword">*</span> x <span class="number">2</span>)</span>)</span>
<span class="list">(<span class="keyword">partial</span> <span class="variable">* 2)
#(+ % %)</span></span>
</code></pre><h3 id="#016:_Hello_World"><a href="http://www.4clojure.com/problem/16" target="_blank" rel="external">#016: Hello World</a></h3><pre><code><span class="comment">;; Write a function which returns a personalized greeting.</span>
<span class="comment">;; (= (__ "Dave") "Hello, Dave!")</span>

#<span class="list">(<span class="keyword">str</span> <span class="string">"Hello, "</span> % <span class="string">"!"</span>)</span>

<span class="list">(<span class="keyword">fn</span> [n] <span class="list">(<span class="keyword">str</span> <span class="string">"Hello, "</span> n <span class="string">"!"</span>)</span>)</span>
#<span class="list">(<span class="keyword">str</span> <span class="string">"Hello, "</span> % \!)</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[函数式的启迪，小括号的逆袭。]]>
    
    </summary>
    
      <category term="Clojure" scheme="http://blog.callmewhy.com/tags/Clojure/"/>
    
      <category term="记录笔记" scheme="http://blog.callmewhy.com/categories/%E8%AE%B0%E5%BD%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用函数式的 Swift 实现图片转字符画的功能]]></title>
    <link href="http://blog.callmewhy.com/2015/06/07/creating-ascii-art-in-functional-swift/"/>
    <id>http://blog.callmewhy.com/2015/06/07/creating-ascii-art-in-functional-swift/</id>
    <published>2015-06-07T08:54:43.000Z</published>
    <updated>2015-06-25T06:54:04.000Z</updated>
    <content type="html"><![CDATA[<p>今天整理 Pocket 中待看的文章，看到这篇《<a href="http://ijoshsmith.com/2015/04/29/creating-ascii-art-in-functional-swift/" target="_blank" rel="external">Creating ASCII art in functional Swift</a>》，讲解如何用 Swift 将图片转成 ASCII 字符。具体原理文中讲解的很详细，不再赘述，但是标题中的 <strong>in functional Swift</strong> 让我很感兴趣，想知道 <code>functional</code> 到底体现在哪里，于是下载 <a href="https://github.com/ijoshsmith/swift-ascii-art" target="_blank" rel="external">swift-ascii-art</a> 源码一探究竟。</p>
<h2 id="Pixel">Pixel</h2><p>图片是由各个像素点组成的，在代码中像素通过 <code>Pixel</code> 这个 <code>struct</code> 实现。每个像素分配了4个字节，这4个字节 (2^8 = 256) 分别用来存储 RBGA 的值。</p>
<h3 id="createPixelMatrix">createPixelMatrix</h3><p>可以通过 <code>createPixelMatrix</code> 这个静态方法创建一个 <code>width</code> * <code>height</code> 像素矩阵：</p>
<pre><code><span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">createPixelMatrix</span><span class="params">(width: Int, <span class="number">_</span> height: Int)</span></span> -&gt; [[<span class="type">Pixel</span>]] {
    <span class="keyword">return</span> <span class="built_in">map</span>(<span class="number">0</span>..&lt;height) { row <span class="keyword">in</span>
        <span class="built_in">map</span>(<span class="number">0</span>..&lt;width) { col <span class="keyword">in</span>
            <span class="keyword">let</span> offset = (width * row + col) * <span class="type">Pixel</span>.bytesPerPixel
            <span class="keyword">return</span> <span class="type">Pixel</span>(offset)
        }
    }
}
</code></pre><p>和传统方法中使用 <code>for</code> 循环来创建多维数组有所不同的是，这里是通过 <code>map</code> 函数实现的。在 Swift 2.0 中， <code>map</code> 函数已经被干掉了，只能作为方法调用。</p>
<h3 id="intensityFromPixelPointer">intensityFromPixelPointer</h3><p><code>intensityFromPixelPointer</code> 方法计算并返回像素点的亮度值，代码如下：</p>
<pre><code><span class="func"><span class="keyword">func</span> <span class="title">intensityFromPixelPointer</span><span class="params">(pointer: PixelPointer)</span></span> -&gt; <span class="type">Double</span> {
    <span class="keyword">let</span>
    red   = pointer[offset + <span class="number">0</span>],
    green = pointer[offset + <span class="number">1</span>],
    blue  = pointer[offset + <span class="number">2</span>]
    <span class="keyword">return</span> <span class="type">Pixel</span>.calculateIntensity(red, green, blue)
}

<span class="keyword">private</span> <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">calculateIntensity</span><span class="params">(r: UInt8, <span class="number">_</span> g: UInt8, <span class="number">_</span> b: UInt8)</span></span> -&gt; <span class="type">Double</span> {
    <span class="keyword">let</span>
    redWeight   = <span class="number">0.229</span>,
    greenWeight = <span class="number">0.587</span>,
    blueWeight  = <span class="number">0.114</span>,
    weightedMax = <span class="number">255.0</span> * redWeight   +
                  <span class="number">255.0</span> * greenWeight +
                  <span class="number">255.0</span> * blueWeight,
    weightedSum = <span class="type">Double</span>(r) * redWeight   +
                  <span class="type">Double</span>(g) * greenWeight +
                  <span class="type">Double</span>(b) * blueWeight
    <span class="keyword">return</span> weightedSum / weightedMax
}
</code></pre><p><code>calculateIntensity</code> 方法基于 <a href="https://en.wikipedia.org/wiki/Grayscale#Luma_coding_in_video_systems" target="_blank" rel="external">Y’UV</a> 编码获取某个像素的亮度 (intensity) ：</p>
<blockquote>
<p>Y’ =  0.299 R’ + 0.587 G’ + 0.114 B’</p>
</blockquote>
<p>YUV 是一种颜色编码方法，Y 表示亮度， UV 用来表示色差， U 和 V 是构成彩色的两个分量。它的优点是可以利用人眼的特性来降低数字彩色图像所需要的存储容量。我们通过这个公式获取到的 Y 就是亮度的值。</p>
<h3 id="Offset">Offset</h3><p><code>Pixel</code> 中其实只存了一个值： <code>offset</code> 。 <code>Pixel.createPixelMatrix</code> 创建出来的矩阵是这样的：</p>
<pre><code>[[<span class="number">0</span>, <span class="number">4</span>, <span class="number">8</span>, ...], ...]
</code></pre><p>并没有像想象中那样存储了每个像素相关数据，而更像是一个转换工具，计算 <code>PixelPointer</code> 的灰度值。</p>
<h2 id="AsciiArtist">AsciiArtist</h2><p><code>AsciiArtist</code> 里封装了一些生成字符画的方法。</p>
<h3 id="createAsciiArt">createAsciiArt</h3><p><code>createAsciiArt</code> 方法就是创建字符画：</p>
<pre><code><span class="func"><span class="keyword">func</span> <span class="title">createAsciiArt</span><span class="params">()</span></span> -&gt; <span class="type">String</span> {
    <span class="keyword">let</span>
    <span class="comment">// 加载图片数据，获取指针对象</span>
    dataProvider = <span class="type">CGImageGetDataProvider</span>(image.<span class="type">CGImage</span>),
    pixelData    = <span class="type">CGDataProviderCopyData</span>(dataProvider),
    pixelPointer = <span class="type">CFDataGetBytePtr</span>(pixelData),
    <span class="comment">// 将图片转成亮度值矩阵</span>
    intensities  = intensityMatrixFromPixelPointer(pixelPointer),
    <span class="comment">// 将亮度值转成对应字符</span>
    symbolMatrix = symbolMatrixFromIntensityMatrix(intensities)
    <span class="keyword">return</span> <span class="built_in">join</span>(<span class="string">"\n"</span>, symbolMatrix)
}
</code></pre><p>其中 <code>CFDataGetBytePtr</code> 函数返回了图像的字节数组指针，数组里每个元素都是一个字节，即 0~255 的整数。每4个字节组成了一个 <code>Pixel</code> ，分别对应着 RGBA 的值。</p>
<h3 id="intensityMatrixFromPixelPointer">intensityMatrixFromPixelPointer</h3><p><code>intensityMatrixFromPixelPointer</code> 这个方法是通过 <code>PixelPointer</code> 生成对应的亮度值矩阵：</p>
<pre><code><span class="keyword">private</span> func intensityMatrixFromPixelPointer(pointer: PixelPointer) -&gt; [[Double]]
{
    let
    <span class="variable">width</span>  = Int(<span class="built_in">image</span>.<span class="built_in">size</span>.<span class="variable">width</span>),
    <span class="variable">height</span> = Int(<span class="built_in">image</span>.<span class="built_in">size</span>.<span class="variable">height</span>),
    matrix = Pixel.createPixelMatrix(<span class="variable">width</span>, <span class="variable">height</span>)
    <span class="keyword">return</span> matrix.<span class="built_in">map</span> { pixelRow in
        pixelRow.<span class="built_in">map</span> { pixel in
            pixel.intensityFromPixelPointer(pointer)
        }
    }
}
</code></pre><p>首先通过 <code>Pixel.createPixelMatrix</code> 方法创建了一个空的二维数组，用来存放数值。然后用两个 <code>map</code> 嵌套遍历里面的所有元素，将像素 (<code>pixel</code>) 转换成亮度 (<code>intensity</code>) 的值。</p>
<h3 id="symbolMatrixFromIntensityMatrix">symbolMatrixFromIntensityMatrix</h3><p><code>symbolMatrixFromIntensityMatrix</code> 函数将亮度值数组转换成字符画数组：</p>
<pre><code>private func symbolMatrixFromIntensityMatrix(matrix: [[Double]]) -&gt; [String]
{
    return matrix.map { intensityRow in
        intensityRow.reduce(<span class="string">""</span>) {
            <span class="variable">$0</span> + self.symbolFromIntensity(<span class="variable">$1</span>)
        }
    }
}
</code></pre><p><code>map</code> + <code>reduce</code> 成功实现了字符串的累加，每次 <code>reduce</code> 都是通过 <code>symbolFromIntensity</code> 方法获取到亮度值对应的字符。 <code>symbolFromIntensity</code> 方法如下：</p>
<pre><code><span class="keyword">private</span> func symbolFromIntensity(intensity: <span class="type">Double</span>) -&gt; String
{
    <span class="keyword">assert</span>(<span class="number">0.0</span> &lt;= intensity &amp;&amp; intensity &lt;= <span class="number">1.0</span>)

    let
    factor = palette.symbols.<span class="built_in">count</span> - <span class="number">1</span>,
    <span class="keyword">value</span>  = <span class="keyword">round</span>(intensity * <span class="type">Double</span>(factor)),
    <span class="built_in">index</span>  = <span class="built_in">Int</span>(<span class="keyword">value</span>)
    <span class="keyword">return</span> palette.symbols[<span class="built_in">index</span>]
}
</code></pre><p>传入 <code>intensity</code> ，在确保了值的范围是 0 ~ 1 之后，通过 <code>AsciiPalette</code> 将它转换成对应的字符，输出 <code>sumbol</code> 。</p>
<h2 id="AsciiPalette">AsciiPalette</h2><p><code>AsciiPalette</code> 是用来将数值转换成字符的工具，像是一个字符画里的调色板一样，根据不同的颜色生成字符。</p>
<h3 id="loadSymbols">loadSymbols</h3><p><code>loadSymbols</code> 加载了所有的字符：</p>
<pre><code><span class="keyword">private</span> <span class="func"><span class="keyword">func</span> <span class="title">loadSymbols</span><span class="params">()</span></span> -&gt; [<span class="type">String</span>]
{
    <span class="keyword">return</span> symbolsSortedByIntensityForAsciiCodes(<span class="number">32</span>...<span class="number">126</span>) <span class="comment">// from ' ' to '~'</span>
}
</code></pre><p>可以看到，我们选用的字符范围是 32 ~ 126 的字符，接下来就是通过 <code>symbolsSortedByIntensityForAsciiCodes</code> 方法将这些字符按照亮度进行排序。比如 <code>&amp;</code> 符号肯定代表着比 <code>.</code> 暗的区域，那么它是如何比较的呢？请看排序方法。</p>
<h3 id="symbolsSortedByIntensityForAsciiCodes">symbolsSortedByIntensityForAsciiCodes</h3><p><code>symbolsSortedByIntensityForAsciiCodes</code> 方法实现了字符串的生成和排序：</p>
<pre><code>private func symbolsSortedByIntensityForAsciiCodes(codes: Range&lt;Int&gt;) -&gt; [String]
{
    let
    // 通过 Ascii 码生成字符数组备用
    symbols          = codes.map { self.symbolFromAsciiCode(<span class="variable">$0</span>) },
    // 将字符绘制出来，把字符数组转换成图片数组，用于比较亮度
    symbolImages     = symbols.map { UIImage.imageOfSymbol(<span class="variable">$0</span>, self.font) },
    // 将图片数组转换成亮度值数组，亮度值的表现形式是图片中白色像素的个数
    whitePixelCounts = symbolImages.map { self.countWhitePixelsInImage(<span class="variable">$0</span>) },
    // 将字符数组通过亮度值就行排序
    sortedSymbols    = sortByIntensity(symbols, whitePixelCounts)
    return sortedSymbols
}
</code></pre><p>其中， <code>sortByIntensity</code> 这个排序方法如下：</p>
<pre><code><span class="keyword">private</span> <span class="func"><span class="keyword">func</span> <span class="title">sortByIntensity</span><span class="params">(symbols: [String], <span class="number">_</span> whitePixelCounts: [Int])</span></span> -&gt; [<span class="type">String</span>]
{
    <span class="keyword">let</span>
    <span class="comment">// 用字典建立 白色像素数目 和 字符 之间的关系</span>
    mappings      = <span class="type">NSDictionary</span>(objects: symbols, forKeys: whitePixelCounts),
    <span class="comment">// 白色像素数目数组去重</span>
    uniqueCounts  = <span class="type">Set</span>(whitePixelCounts),
    <span class="comment">// 白色像素数目数组排序</span>
    sortedCounts  = sorted(uniqueCounts),
    <span class="comment">// 利用前面的字典映射，将排序后的白色像素数目转换成对应的字符，从而输出有序数组</span>
    sortedSymbols = sortedCounts.<span class="built_in">map</span> { mappings[$<span class="number">0</span>] <span class="keyword">as</span>! <span class="type">String</span> }
    <span class="keyword">return</span> sortedSymbols
}
</code></pre><h2 id="小结">小结</h2><p>简单了过了一下项目，可以隐约感觉到一些函数式风格的气息，主要体现在一下几个方面：</p>
<ul>
<li><code>map</code> <code>reduce</code> 等函数的应用恰到好处，自如处理数组的转换和拼接。</li>
<li>通过 <code>input</code> 和 <code>output</code> 进行数据处理，比如 <code>sortByIntensity</code> 方法和 <code>symbolFromIntensity</code> 方法。</li>
<li>很少有状态和属性，更多的是直接的函数转换，函数逻辑不依赖外部变量，只依赖于传入的参数</li>
</ul>
<p>代码感觉简单轻快。通过这个简单的小例子，验证了前面在 <a href="http://blog.callmewhy.com/2015/05/11/functional-reactive-programming-1/#函数式的特性">函数式的特性</a> 中学习到的东西。</p>
<p>感觉很赞！</p>
<hr>
<p>参考文献：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Grayscale#Luma_coding_in_video_systems" target="_blank" rel="external">Luma Coding in Video Systems</a></li>
<li><a href="http://ijoshsmith.com/2015/04/29/creating-ascii-art-in-functional-swift/" target="_blank" rel="external">Creating ASCII art in functional Swift</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[如何更 Functional 地写 Swift 代码，希望此文可以带来启发。]]>
    
    </summary>
    
      <category term="Swift" scheme="http://blog.callmewhy.com/tags/Swift/"/>
    
      <category term="开发笔记" scheme="http://blog.callmewhy.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hybrid App 探索之旅]]></title>
    <link href="http://blog.callmewhy.com/2015/05/31/web-and-native/"/>
    <id>http://blog.callmewhy.com/2015/05/31/web-and-native/</id>
    <published>2015-05-31T05:13:57.000Z</published>
    <updated>2015-05-31T12:20:17.000Z</updated>
    <content type="html"><![CDATA[<p>最近公司的项目想尝试在 Native App 中嵌入 Web 界面，以实现一些简单功能的多终端复用。刚好周末花点时间整理一下以前学习 Hybrid App 时的笔记。</p>
<h2 id="背景介绍">背景介绍</h2><p>Hybrid 的原意是混合的， Hybrid App 就是指 Web 和 Native 杂交的产物。愿景是能兼具 Native App 的良好交互体验和 Web App 的跨平台优势。</p>
<p>Hybrid App 和网站有些相似，也是基于 HTML 、 CSS 、 JS 这类 Web 技术进行开发。唯一的区别在于 Hybrid App 是利用各个平台的 WebView 嵌入到原生应用中。</p>
<h2 id="HTML_+_JS_+_CSS">HTML + JS + CSS</h2><p>我们可以利用 HTML + JS + CSS 开发一个最简单的 Hybrid App ，直接在 Native App 里放个 WebView ，然后用 WebView 加载存储在本地的网页就可以了。先在项目中新建一个 index.html ，里面的代码如下：</p>
<pre><code><span class="tag">&lt;<span class="title">html</span>&gt;</span>
    <span class="tag">&lt;<span class="title">body</span>&gt;</span>
        <span class="tag">&lt;<span class="title">h1</span>&gt;</span>Hello, WHY!<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</code></pre><p>然后在某个 <code>UIViewController</code> 中加载这个 html 文件：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>{

    <span class="preprocessor">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> webview: <span class="type">UIWebView</span>!

    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> {
        <span class="keyword">super</span>.viewDidLoad()

        <span class="keyword">let</span> path = <span class="type">NSBundle</span>.mainBundle().pathForResource(<span class="string">"index"</span>, ofType: <span class="string">"html"</span>)
        <span class="keyword">let</span> url = <span class="type">NSURL</span>(fileURLWithPath: path!)
        <span class="keyword">let</span> req = <span class="type">NSURLRequest</span>(<span class="type">URL</span>: url!)
        webview.loadRequest(req)
    }
}
</code></pre><p>加载结果如下：</p>
<p><img src="http://ww4.sinaimg.cn/large/61d238c7jw1esnfigb6naj20lu0d1tba.jpg" alt=""></p>
<p>OK! 看起来很棒！一切都是 So Easy 啊！但是有种略无力的感觉，比如想做本地缓存，比如获取通讯录中的联系人，这些在 Native 里很常见的功能，在 Web 中并不是很好实现。</p>
<h2 id="Cordova"><a href="http://cordova.apache.org/" target="_blank" rel="external">Cordova</a></h2><p>Cordova 是一套设备 API 的集合，允许移动应用的开发者使用 JavaScript 来访问本地设备的功能，比如摄像头、加速计等等。如今大部分 Hybrid App 是利用 Cordova 进行开发的。Cordova 的前身是大名鼎鼎的 PhoneGap 。 PhoneGap 被 Adobe 收购了，但是剥离了核心代码贡献给 Apache ， Apache 将这个项目命名为 Cordova 。</p>
<p>我们用 Cordova 搞个 Hello World 感受一下，具体的使用方法请参见<a href="http://cordova.apache.org/docs/en/5.0.0/index.html" target="_blank" rel="external">官方文档</a>。</p>
<p>在这里推荐使用淘宝镜像 <a href="https://npm.taobao.org/" target="_blank" rel="external">cnpm</a> 安装：</p>
<pre><code>sudo cnpm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> cordova</span>
</code></pre><p>安装完成之后创建一个 HelloWorld 项目：</p>
<pre><code>cordova create hello com<span class="class">.example</span><span class="class">.hello</span> HelloWorld
</code></pre><p>添加 iOS 平台：</p>
<pre><code>cordova <span class="built_in">platform</span> <span class="built_in">add</span> ios
</code></pre><p>这时的项目目录是这样的：</p>
<p><img src="http://ww1.sinaimg.cn/large/61d238c7jw1esnji3u54gj20aw0cndh7.jpg" alt=""></p>
<p>我们可以用 iOS 模拟器跑一下这个项目。首先安装 ios-sim ：</p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> ios-sim</span>
</code></pre><p>然后在模拟器上运行：</p>
<pre><code>cordova <span class="built_in">emulate</span> ios
</code></pre><p>运行效果截图：</p>
<p><img src="http://ww3.sinaimg.cn/large/61d238c7jw1esnk01di6uj20fn0sfq41.jpg" alt=""></p>
<p>看起来还不错。开发的时候我们只需要开发 www 文件夹中的内容即可：</p>
<p><img src="http://ww1.sinaimg.cn/large/61d238c7gw1esnor3viccj210x0ihn4n.jpg" alt=""></p>
<p>以上便是如何从零创建 Cordova 应用的步骤。如果想在现有项目中使用 Cordova 可以参见这篇 《<a href="http://outof.me/embedding-cordovalib-in-your-iosphonegap-app-project/" target="_blank" rel="external">Embedding CordovaLib in Your iOS App Project</a>》</p>
<p>不过至此我们并不能满足，虽然 Cordova 帮我们省了很多工作，比如创建项目、添加平台支持、各种原生接口的封装，但是当真正用于 Hybrid App 开发的时候还是比较乏力，比如导航栏、开关按钮、提示框，这些移动应用中很常见的 UI 控件，在 Web 中并不常见。</p>
<h2 id="Ionic"><a href="http://ionicframework.com/" target="_blank" rel="external">Ionic</a></h2><p>Ionic 是一个基于 Cordova 和 HTML5 的 UI 框架，类似于前端的 <a href="http://getbootstrap.com/" target="_blank" rel="external">Bootstrap</a> 和 <a href="http://foundation.zurb.com/" target="_blank" rel="external">Foundation</a> ，封装了移动应用中的一些常见控件，例如导航栏、侧滑菜单等等。得益于 HTML5 ，我们可以轻松的调用一些系统的接口。</p>
<p>有了 Ionic 我们可以快速实现一些在移动应用中十分常见的功能。</p>
<p>例如时间选择器：</p>
<p><img src="http://ww2.sinaimg.cn/large/61d238c7jw1esnovctp90j20xe0r6agk.jpg" alt=""></p>
<p>例如简单的网格布局：</p>
<p><img src="http://ww1.sinaimg.cn/large/61d238c7jw1esnoxgc128j20yi0m07c0.jpg" alt=""></p>
<p>例如做一个选项卡菜单：</p>
<p><img src="http://ww4.sinaimg.cn/large/61d238c7jw1esnozxfm8cj21080pbtga.jpg" alt=""></p>
<p>并且还提供了海量 <a href="http://ionicons.com/" target="_blank" rel="external">icon</a> ，可以说基本满足了一个移动应用的入门级需求。</p>
<h2 id="小结">小结</h2><p>在我看来， Hybrid App 的优势是开发成本低，在团队人力资源有限又急着上线，或者确实对交互要求不高 (比如只是做个简单的论坛浏览) 的时候， Hybrid App 确实是个不错的选择。</p>
<p>然而 Web App 说到底还是 Web ，它可以用来开发移动应用，但它并不擅长开发移动应用。性能上的瓶颈始终是不可逾越的鸿沟。虽然有 Ionic 和 jQuery Mobile 这样的 UI 框架，省了很多重复的界面开发工作，但是如果仔细对比，在交互体验上和 Native 还是有着比较大的差距。</p>
<p>所以 iOS 和 Android 的程序员们不用紧张，饭碗暂时还没丢。</p>
<hr>
<p>参考文献：</p>
<ul>
<li><a href="http://developer.telerik.com/featured/what-is-a-hybrid-mobile-app/" target="_blank" rel="external">What is a Hybrid Mobile App?</a></li>
<li><a href="http://www.sitepoint.com/top-7-hybrid-mobile-app-frameworks/" target="_blank" rel="external">The Top 7 Hybrid Mobile App Frameworks</a></li>
<li><a href="http://www.infoq.com/cn/articles/hybrid-app-development-combat" target="_blank" rel="external">Hybrid App开发实战</a></li>
<li><a href="http://www.infoq.com/cn/presentations/trend-of-mobile-phone-game-technology-native-html5-2d-3d" target="_blank" rel="external">手机游戏技术走向之我见: Native vs. HTML5</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[蛋糕看起来太诱人，实在忍不住咬一口。]]>
    
    </summary>
    
      <category term="Web" scheme="http://blog.callmewhy.com/tags/Web/"/>
    
      <category term="开发笔记" scheme="http://blog.callmewhy.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Chun 阅读笔记 - 如何做一个图片缓存库]]></title>
    <link href="http://blog.callmewhy.com/2015/05/25/note-about-chun/"/>
    <id>http://blog.callmewhy.com/2015/05/25/note-about-chun/</id>
    <published>2015-05-25T15:05:21.000Z</published>
    <updated>2015-05-26T04:02:32.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/yechunjun/Chun" target="_blank" rel="external">Chun</a> 是 <a href="http://chun.tips/" target="_blank" rel="external">叶纯俊</a> 在 Github 上开源的一个图片缓存库，基于 Swift 编写。学习 Swift 有一段时间了，记录一些阅读源码的一些收获。</p>
<h3 id="代码组织">代码组织</h3><p>Swift 中通过 <code>extension</code> 组织代码会让整个类更加清晰可读，尤其是对于 <code>UITableViewDataSource</code> 和 <code>UITableViewDelegate</code> 这种情况。在 <code>Chun</code> 这个项目中的 Demo 文件就是这样的：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>{
    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> {
        <span class="keyword">super</span>.viewDidLoad()
        ...
    }
}

<span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UITableViewDataSource</span>, <span class="title">UITableViewDelegate</span> </span>{
    <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> {
        ...
    }
    <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> {
        ...
    }
    <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">CGFloat</span> {
        ...
    }
}
</code></pre><p>在 <code>viewDidLoad</code> 中，为了避免初始化代码过长导致难以阅读，可以通过内嵌函数将代码分段：</p>
<pre><code><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> {
    <span class="keyword">super</span>.viewDidLoad()

    <span class="func"><span class="keyword">func</span> <span class="title">loadTableView</span><span class="params">()</span></span> {
        ...
    }

    loadTableView()
}
</code></pre><h3 id="添加属性">添加属性</h3><p>在给 <code>UIImageView</code> 加载图片的时候，我们最好可以在对象中存储它所要加载的 URL ，可以通过 <code>AssociatedObject</code> 来实现。在 Swift 中，可以用一个私有计算量来封装一下：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">var</span> imageURLForChun: <span class="type">NSURL</span>? {
    <span class="keyword">get</span> {
        <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, &amp;key) <span class="keyword">as</span>? <span class="type">NSURL</span>
    }
    <span class="keyword">set</span> (url) {
        objc_setAssociatedObject(<span class="keyword">self</span>, &amp;key, url, <span class="type">UInt</span>(<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>))
    }
}
</code></pre><p>这样在调用的时候就和真实属性没什么区别了：</p>
<pre><code><span class="keyword">if</span> <span class="keyword">let</span> imageURL = <span class="built_in">self</span><span class="built_in">.</span>imageURLForChun {
    <span class="attribute">...</span>
}
</code></pre><h3 id="weak_和_unowned">weak 和 unowned</h3><p>在避免循环强引用的时候，如果某些时候引用没有值，那就用 <code>weak</code> ，如果引用总是有值，则用 <code>unowned</code> 。</p>
<p>在 <code>Chun</code> 这个项目中，获取图片之后的回调里用的是 <code>weak</code> ，因为有可能图片加载完了但是 <code>UIImageView</code> 已经销毁了：</p>
<pre><code>Chun.sharedInstance.fetchImageWithURL(url, complete: { [<span class="link_label">weak self</span>](<span class="link_url">result: Result</span>) -&gt; Void in
<span class="code">    ...</span>
})
</code></pre><p>然后在查询本地缓存的时候，用的是 <code>unowned</code> ，因为这里的 <code>self</code> 是单例，永远不会销毁：</p>
<pre><code>cache.diskImageExistsWithKey(key, completion: { [<span class="link_label">unowned self</span>](<span class="link_url">exist: Bool, diskURL: NSURL?</span>) -&gt; Void in
<span class="code">    ...</span>
})
</code></pre><h3 id="枚举的正确打开方式">枚举的正确打开方式</h3><p>使用枚举来表示返回结果是个不错的方案，在<a href="http://blog.callmewhy.com/2015/04/20/error-handling-in-swift/">面向轨道编程 - Swift 中的异常处理</a>中有过详细的探讨。在 <code>Chun</code> 中是这样使用的：</p>
<pre><code>public <span class="class"><span class="keyword">enum</span> <span class="title">Result</span> {</span>
    <span class="keyword">case</span> <span class="constant">Success</span>(<span class="symbol">image:</span> <span class="constant">UIImage</span>, <span class="symbol">fetchedImageURL:</span> <span class="constant">NSURL</span>)
    <span class="keyword">case</span> <span class="constant">Error</span>(<span class="symbol">error:</span> <span class="constant">NSError</span>)
}
</code></pre><p>加载图片完成之后的回调则是这样：</p>
<pre><code>public func fetchImageWithURL(url: <span class="type">NSURL</span>, complete: (<span class="type">Result</span>) -&gt; <span class="type">Void</span>) {
    <span class="keyword">let</span> key = cacheKeyForRemoteURL(url)
    <span class="keyword">if</span> <span class="keyword">let</span> image = cache.imageForMemeoryCacheWithKey(key) {
        <span class="keyword">let</span> <span class="literal">result</span> = <span class="type">Result</span>.<span class="type">Success</span>(image: image, fetchedImageURL: url)
        complete(<span class="literal">result</span>)
    } <span class="keyword">else</span> {
        ...
    }
}
</code></pre><h3 id="图片渲染">图片渲染</h3><p>直接从网上下载获取到的图片并不能直接使用，先解码成位图然后再渲染可以减少开销：</p>
<pre><code>func decodedImageWithImage(image: <span class="built_in">UIImage</span>) -&gt; <span class="built_in">UIImage</span> {
    <span class="keyword">if</span> image<span class="variable">.images</span> != <span class="literal">nil</span> {
        <span class="keyword">return</span> image
    }
    let imageRef = image<span class="variable">.CGImage</span>
    let imageSize: <span class="built_in">CGSize</span> = <span class="built_in">CGSizeMake</span>(<span class="built_in">CGFloat</span>(<span class="built_in">CGImageGetWidth</span>(imageRef)), <span class="built_in">CGFloat</span>(<span class="built_in">CGImageGetHeight</span>(imageRef)))
    let imageRect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, imageSize<span class="variable">.width</span>, imageSize<span class="variable">.height</span>)
    let colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>()

    let originalBitmapInfo = <span class="built_in">CGImageGetBitmapInfo</span>(imageRef)
    let alphaInfo = <span class="built_in">CGImageGetAlphaInfo</span>(imageRef)

    var bitmapInfo = originalBitmapInfo
    <span class="keyword">switch</span> (alphaInfo) {
    <span class="keyword">case</span> <span class="variable">.None</span>:
        bitmapInfo &amp;= ~<span class="built_in">CGBitmapInfo</span><span class="variable">.AlphaInfoMask</span>
        bitmapInfo |= <span class="built_in">CGBitmapInfo</span>(<span class="built_in">CGImageAlphaInfo</span><span class="variable">.NoneSkipFirst</span><span class="variable">.rawValue</span>)
    <span class="keyword">case</span> <span class="variable">.PremultipliedFirst</span>, <span class="variable">.PremultipliedLast</span>, <span class="variable">.NoneSkipFirst</span>, <span class="variable">.NoneSkipLast</span>:
        <span class="keyword">break</span>
    <span class="keyword">case</span> <span class="variable">.Only</span>, <span class="variable">.Last</span>, <span class="variable">.First</span>:
        <span class="keyword">return</span> image
    }

    <span class="keyword">if</span> let context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">nil</span>, <span class="built_in">CGImageGetWidth</span>(imageRef), <span class="built_in">CGImageGetHeight</span>(imageRef), <span class="built_in">CGImageGetBitsPerComponent</span>(imageRef), <span class="number">0</span> , colorSpace, bitmapInfo) {
        <span class="built_in">CGContextDrawImage</span>(context, imageRect, imageRef)
        let decompressedImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(context)
        <span class="keyword">if</span> let decompressedImage = <span class="built_in">UIImage</span>(<span class="built_in">CGImage</span>: decompressedImageRef, scale: image<span class="variable">.scale</span>, orientation: image<span class="variable">.imageOrientation</span>) {
            <span class="keyword">return</span> decompressedImage
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> image
        }
    } <span class="keyword">else</span> {
        <span class="keyword">return</span> image
    }
}
</code></pre><h3 id="从_NSData判断图片类型">从 NSData判断图片类型</h3><p>在判断图片格式的时候，通过不同格式的第一个字节进行判断，在 <code>contentTypeForImageData(data: NSData) -&gt; String?</code> 方法里实现了获取 <code>NSData</code> 类型的方法：</p>
<pre><code><span class="func"><span class="keyword">func</span> <span class="title">contentTypeForImageData</span><span class="params">(data: NSData)</span></span> -&gt; <span class="type">String</span>? {
    <span class="keyword">var</span> value : <span class="type">Int16</span> = <span class="number">0</span>
    <span class="keyword">if</span> data.length &gt;= <span class="built_in">sizeof</span>(<span class="type">Int16</span>) {
        data.getBytes(&amp;value, length:<span class="number">1</span>)
        <span class="keyword">switch</span> (value) {
        <span class="keyword">case</span> <span class="number">0xff</span>:
            <span class="keyword">return</span> <span class="string">"image/jpeg"</span>
        <span class="keyword">case</span> <span class="number">0x89</span>:
            <span class="keyword">return</span> <span class="string">"image/png"</span>
        <span class="keyword">case</span> <span class="number">0x47</span>:
            <span class="keyword">return</span> <span class="string">"image/gif"</span>
        <span class="keyword">case</span> <span class="number">0x49</span>:
            <span class="keyword">return</span> <span class="string">"image/tiff"</span>
        <span class="keyword">case</span> <span class="number">0x4D</span>:
            <span class="keyword">return</span> <span class="string">"image/tiff"</span>
        <span class="keyword">case</span> <span class="number">0x52</span>:
            <span class="keyword">if</span> (data.length &lt; <span class="number">12</span>) {
                <span class="keyword">return</span> <span class="literal">nil</span>
            }
            <span class="keyword">if</span> <span class="keyword">let</span> temp = <span class="type">NSString</span>(data: data.subdataWithRange(<span class="type">NSMakeRange</span>(<span class="number">0</span>, <span class="number">12</span>)), encoding: <span class="type">NSASCIIStringEncoding</span>) {
                <span class="keyword">if</span> (temp.hasPrefix(<span class="string">"RIFF"</span>) &amp;&amp; temp.hasSuffix(<span class="string">"WEBP"</span>)) {
                    <span class="keyword">return</span> <span class="string">"image/webp"</span>
                }
            }
            <span class="keyword">return</span> <span class="literal">nil</span>
        <span class="keyword">default</span>:
            <span class="keyword">return</span> <span class="literal">nil</span>
        }
    }
    <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="literal">nil</span>
    }
} 
</code></pre><p>判断的依据是不同图片格式的前几个字节都是特殊且唯一的，具体在 <a href="http://www.astro.keele.ac.uk/oldusers/rno/Computing/File_magic.html" target="_blank" rel="external">File magic numbers</a> 里有个比较完整的表，可以对照看下。比如 <code>jpeg</code> 的前四个字节都是 <code>ff d8 ff e0</code> 。</p>
<h3 id="Fetcher_的玩儿法">Fetcher 的玩儿法</h3><p>在获取图片的时候都是通过 <code>Fetcher</code> 获取，根据任务不同，区分是从服务器下载还是从本地加载。</p>
<p>首先是 <code>ImageFetcher</code> 这个大基类，封装了一些基本的属性和方法：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">ImageFetcher</span> </span>{

    <span class="keyword">typealias</span> <span class="type">CompeltionClosure</span> = (<span class="type">FetcherResult</span>) -&gt; <span class="type">Void</span>

    <span class="keyword">let</span> imageURL: <span class="type">NSURL</span>

    <span class="keyword">init</span>(imageURL: <span class="type">NSURL</span>) {
        <span class="keyword">self</span>.imageURL = imageURL
    }

    <span class="keyword">deinit</span> {
        <span class="keyword">self</span>.completion = <span class="literal">nil</span>
    }

    <span class="keyword">var</span> cancelled = <span class="literal">false</span>

    <span class="keyword">var</span> completion: <span class="type">CompeltionClosure</span>?

    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">fetchImage</span><span class="params">(url: NSURL, completion: CompeltionClosure?)</span></span> -&gt; <span class="type">ImageFetcher</span> {
        <span class="keyword">var</span> fetcher: <span class="type">ImageFetcher</span>
        <span class="keyword">if</span> url.fileURL {
            fetcher = <span class="type">DiskImageFetcher</span>(imageURL: url)
        } <span class="keyword">else</span> {
            fetcher = <span class="type">RemoteImageFetcher</span>(imageURL: url)
        }
        fetcher.completion = completion
        fetcher.startFetch()
        <span class="keyword">return</span> fetcher
    }

    <span class="func"><span class="keyword">func</span> <span class="title">cancelFetch</span><span class="params">()</span></span> {
        <span class="keyword">self</span>.cancelled = <span class="literal">true</span>
    }

    <span class="func"><span class="keyword">func</span> <span class="title">startFetch</span><span class="params">()</span></span> {
        <span class="built_in">fatalError</span>(<span class="string">"Subclass need to override this method called: \"startFetch\" "</span>)
    }

    <span class="keyword">final</span> <span class="func"><span class="keyword">func</span> <span class="title">failedWithError</span><span class="params">(error: NSError)</span></span> {
    }

    <span class="keyword">final</span> <span class="func"><span class="keyword">func</span> <span class="title">succeedWithData</span><span class="params">(imageData: NSData)</span></span> {
    }
}
</code></pre><p>在 <code>fetchImage</code> 这个方法里，通过 <code>url.fileURL</code> 判断是网络请求还是本地请求，然后初始化不同的 <code>fetcher</code> 。然后对于一定需要子类实现的方法，用 <code>fatalError</code> 报错提醒；对于一定不能让子类重写的方法，用 <code>final</code> 保护起来。比如请求成功之后的回调方法 <code>succeedWithData(imageData: NSData)</code> ：</p>
<pre><code>final func succeedWithData(<span class="attribute">imageData</span>: NSData) {

    dispatch_async<span class="function"><span class="params">(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), { [weak self]() -&gt; Void <span class="keyword">in</span>
        <span class="keyword">if</span> <span class="keyword">let</span> strongSelf = self {
            <span class="keyword">var</span> finalImage: UIImage!

            <span class="keyword">if</span> <span class="keyword">let</span> image = imageWithData(imageData) {
                finalImage = scaledImage(image)
                finalImage = decodedImageWithImage(finalImage)
                dispatch_main_async_safe {
                    <span class="keyword">if</span> !strongSelf.cancelled {
                        <span class="keyword">if</span> <span class="keyword">let</span> completionClosure = strongSelf.completion {
                            <span class="keyword">let</span> result = FetcherResult.Success(image: finalImage, imageData: imageData)
                            completionClosure(result)
                        }
                    }
                }
            } <span class="keyword">else</span> {
                <span class="keyword">let</span> error = NSError(domain: CHUN_ERROR_DOMAIN, code: <span class="number">404</span>, userInfo: [NSLocalizedDescriptionKey: <span class="string">"create Image with data failed"</span>])
                strongSelf.failedWithError(error)
            }
        }
    })</span>
}</span>
</code></pre><p>不管是从本地加载还是从远程获取的，最终的返回结果都是 <code>NSData</code> ，所以在这里统一处理。然后对于取消了的事件，其实并没有取消下载任务，而是在下载成功之后通过 <code>strongSelf.cancelled</code> 判断是不是要调用加载成功的回调方法。</p>
<p>然后再分别看下本地加载和网络获取的部分。本地加载相对而言简单一些，通过 <code>NSData(contentsOfURL: self.imageURL)</code> 就可以加载图片了。然后对于网络请求则使用了 <code>NSURLSession</code> 来实现。 对 <code>NSURLSession</code> 不熟悉的同学可以阅读《<a href="http://objccn.io/issue-5-4/" target="_blank" rel="external">从 NSURLConnection 到 NSURLSession</a>》了解一下。</p>
<p>网络请求成功之后做了如下操作：</p>
<ul>
<li>检查 <code>self</code> 是否还活着</li>
<li>检查当前任务是否被取消了</li>
<li>检查回调的 <code>error</code> 是否不为空</li>
<li>获取 <code>response</code> 并查看状态码是否为 <code>200</code> </li>
</ul>
<p>在一切正常的前提下，还进行了如下操作：</p>
<pre><code>let expected = response.expectedContentLength
var <span class="string">validateLengthOfData:</span> Bool {
    <span class="keyword">if</span> expected &gt; -<span class="number">1</span> {
        <span class="keyword">if</span> Int64(data!.length) &gt;= expected {
            <span class="keyword">return</span> <span class="literal">true</span>
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> <span class="literal">false</span>
        }
    }
    <span class="keyword">return</span> <span class="literal">true</span>
}

<span class="keyword">if</span> validateLengthOfData {
    strongSelf.succeedWithData(data!)
    <span class="keyword">return</span>
} <span class="keyword">else</span> {

    let error = NSError(<span class="string">domain:</span> CHUN_ERROR_DOMAIN, <span class="string">code:</span> response.statusCode, <span class="string">userInfo:</span> [<span class="string">NSLocalizedDescriptionKey:</span> <span class="string">"Received bytes are not fit with expected"</span>])
    strongSelf.failedWithError(error)
    <span class="keyword">return</span>
}
</code></pre><p>主要是检查实际获取到的数据大小是否等于应有大小，通过 <code>validateLengthOfData</code> 这个计算量标记是否校验通过。</p>
<h3 id="缓存">缓存</h3><p>图片的缓存都是通过 <code>ImageCache</code> 这个类进行统一处理。初始化的时候新建了 <code>ioQueue</code> 这个用来专门进行 IO 操作的队列，然后用 <code>NSCache</code> 在内存中缓存图片。对于 <code>NSCache</code> 在 <code>NSHipster</code> 上有些<a href="http://nshipster.cn/nscache/" target="_blank" rel="external">吐槽</a>，但这并没有太大影响，基本可以满足日常开发的需要。</p>
<h3 id="系统事件的处理">系统事件的处理</h3><p>在收到 <code>UIApplicationDidEnterBackgroundNotification</code> 的通知的时候，做了 <code>backgroundCleanDisk</code> 的处理：</p>
<pre><code><span class="label">private</span> func <span class="keyword">backgroundCleanDisk() </span>{

    let application = UIApplication.sharedApplication()
    var <span class="keyword">backgroundTask: </span>UIBackgroundTaskIdentifier!
    <span class="keyword">backgroundTask </span>= application.<span class="keyword">beginBackgroundTaskWithExpirationHandler </span>{
        application.endBackgroundTask(<span class="keyword">backgroundTask)
</span>        <span class="keyword">backgroundTask </span>= UIBackgroundTaskInvalid
    }

    <span class="keyword">self.cleanDisk </span>{
        application.endBackgroundTask(<span class="keyword">backgroundTask)
</span>        <span class="keyword">backgroundTask </span>= UIBackgroundTaskInvalid
    }
}
</code></pre><p>通过 <code>beginBackgroundTaskWithExpirationHandler</code> 在退到后台之后清空了本地的过期文件。</p>
<h3 id="过期文件">过期文件</h3><p>判断过期文件的关键在于这个方法：</p>
<pre><code><span class="keyword">let</span> expirationDate = NSDate(timeIntervalSinceNow: ImageCache.defaultCacheMaxAge)
<span class="keyword">let</span> modificationDate = resourceValues[NSURLContentModificationDateKey] <span class="keyword">as</span>! NSDate

<span class="keyword">if</span> modificationDate.laterDate(expirationDate).isEqualToDate(expirationDate) {
    ...
}
</code></pre><p>通过遍历检查所有的过期文件，存到 <code>cacheFiles</code> 数组中，然后统一删除。</p>
<h3 id="小结">小结</h3><p>通过 <code>Chun</code> 这个项目学习了如何实现一个简单的图片缓存库，包括图片加载和本地缓存两个核心功能。然后通过 <code>public class</code> 把一些公用接口封装并暴露出去。也看到了很多 Swift 中的小技巧，总之就是， Excited 嗯！</p>
]]></content>
    <summary type="html">
    <![CDATA[优质的代码令人赏心悦目。]]>
    
    </summary>
    
      <category term="开发笔记" scheme="http://blog.callmewhy.com/tags/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="开发笔记" scheme="http://blog.callmewhy.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Functional Reactive Programming in Swift - Part 1]]></title>
    <link href="http://blog.callmewhy.com/2015/05/11/functional-reactive-programming-1/"/>
    <id>http://blog.callmewhy.com/2015/05/11/functional-reactive-programming-1/</id>
    <published>2015-05-11T11:53:37.000Z</published>
    <updated>2015-05-11T12:07:48.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>大四狗在毕业前夕终于撸完了毕业论文。把论文内容整理之后拆分成了三篇博客，希望和大家一起探索函数式反应型编程 (Functional Reactive Programming ， 缩写为 FRP) 的乐趣。</p>
<p>在第一章里，我们先了解一下，什么是 FRP 。</p>
<h2 id="函数式_-_Functional">函数式 - Functional</h2><p>函数式编程是一种编程范型，也就是指导如何编写程序的方法论。它强调函数必须被当成第一等公民对待，将电脑运算视为数学上的函数计算，并且避免使用程序状态以及易变对象。</p>
<p>例如 +1 这样一个简单的操作，传统的做法是这样的：</p>
<pre><code><span class="keyword">var</span> foo = <span class="number">0</span>
<span class="func"><span class="keyword">func</span> <span class="title">increment</span><span class="params">()</span></span> {
    foo++
}
</code></pre><p>函数式的写法是这样的：</p>
<pre><code><span class="func"><span class="keyword">func</span> <span class="title">increment</span><span class="params">(foo: Int)</span></span> -&gt; <span class="type">Int</span> {
    <span class="keyword">return</span> foo + <span class="number">1</span>
}
</code></pre><p>从这个例子中可以看到，函数式编程不依赖于外部的数据，而且也不修改外部数据的值，而是返回一个运算之后的新值。</p>
<h3 id="函数式的特性">函数式的特性</h3><p>函数式编程具有以下几个特性：</p>
<h4 id="特性1：函数是第一等公民">特性1：函数是第一等公民</h4><p>所谓 第一等公民 (first class) ，指的是函数与其他数据类型一样，处于平等地位。既可以赋值给其他变量，也可以作为参数传入另一个函数，或者作为别的函数的返回值。</p>
<p>比如我们可以用 map 将数组通过指定的函数映射成另一个数组：</p>
<pre><code>let increment = { <span class="keyword">return</span> $<span class="number">0</span> + <span class="number">1</span> }
[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="built_in">map</span>(increment)  <span class="comment">// [2,3,4]</span>
</code></pre><p>这里的 increment 便是作为一个函数传入的。这个技术可以让你的函数就像变量一样来使用。也就是说，你的函数可以像变量一样被创建、修改、传递，返回或是在函数中嵌套其他函数。</p>
<h4 id="特性2：数据是不可变的">特性2：数据是不可变的</h4><p>函数式语言里面的数据是不可修改的，只会返回新的值。这使得多个线程可以在不用锁的情况下并发地访问数据，因为数据本身并不会发生变化。</p>
<p>在 Clojure 这样的纯函数式语言中，变量默认是不可变的。如果想改变变量的值，可以通过 binding 进行动态绑定：</p>
<pre><code><span class="prompt">user=&gt;</span><span class="clojure"> <span class="list">(<span class="keyword"><span class="built_in">def</span></span> ^<span class="attribute">:dynamic</span> x <span class="number">1</span>)</span></span>
#’user/x

<span class="prompt">user=&gt;</span><span class="clojure"> <span class="list">(<span class="keyword"><span class="built_in">def</span></span> ^<span class="attribute">:dynamic</span> y <span class="number">2</span>)</span></span>
#’user/y

<span class="prompt">user=&gt;</span><span class="clojure"> <span class="list">(<span class="keyword"><span class="built_in">+</span></span> x y)</span></span>
3

<span class="prompt">user=&gt;</span><span class="clojure"> <span class="list">(<span class="keyword">binding</span> <span class="collection">[x <span class="number">4</span> y <span class="number">5</span>]</span>   <span class="comment">; 使用动态绑定覆盖原来绑定的值</span></span></span>
         (+ x y))
9

<span class="prompt">user=&gt;</span><span class="clojure"><span class="list"> <span class="list">(<span class="keyword"><span class="built_in">+</span></span> x y)</span></span></span>
3
</code></pre><h4 id="特性3：函数没有副作用">特性3：函数没有副作用</h4><p>副作用指的是函数内部与外部互动，产生了函数运算以外的其他结果。最典型的情况，就是修改全局变量的值：</p>
<pre><code><span class="keyword">var</span> foo = <span class="number">0</span>
<span class="func"><span class="keyword">func</span> <span class="title">increment</span><span class="params">()</span></span> {
    foo++
}
</code></pre><p>函数式编程强调函数运算没有副作用，意味着函数要保持独立。函数的所有功能就是返回一个新值，没有其他行为，尤其是不得修改外部变量的值。</p>
<h4 id="特性4：函数具有确定性">特性4：函数具有确定性</h4><p>函数的运行不依赖于外部变量和系统状态，只依赖于输入的参数。任何时候只要输入的参数相同，函数返回的新值总是相同的。</p>
<p>不确定性的函数示例：</p>
<pre><code><span class="keyword">let</span> foo = <span class="number">3</span>
<span class="keyword">var</span> i = <span class="number">0</span>
<span class="func"><span class="keyword">func</span> <span class="title">increment</span><span class="params">(value: Int)</span></span> -&gt; <span class="type">Int</span> {
    <span class="keyword">return</span> value + i
}

i = <span class="number">1</span>
increment(foo)    <span class="comment">// 4</span>
i = <span class="number">2</span>
increment(foo)    <span class="comment">// 5</span>
</code></pre><p>可以看到，不确定性函数的运行结果往往与系统状态有关，不同的状态之下，返回值是不一样的。</p>
<p>确定性的函数示例：</p>
<pre><code><span class="keyword">var</span> foo = <span class="number">3</span>
<span class="func"><span class="keyword">func</span> <span class="title">increment</span><span class="params">(value: Int, step: Int)</span></span> -&gt; <span class="type">Int</span>{
    <span class="keyword">return</span> value + step
}

increment(foo, <span class="number">1</span>)   <span class="comment">// 4</span>
increment(foo, <span class="number">2</span>)   <span class="comment">// 5</span>
</code></pre><p>函数的确定性有利于我们观察和理解程序的行为，因为它所依赖的东西只有参数本身。</p>
<h3 id="函数式的函数">函数式的函数</h3><p>在函数式编程中，有些函数是抬头不见低头见的常客。在合适的时机利用合适的函数，可以有效地缩短代码，并且让代码更可读。在这里我们提前了解一下他们。</p>
<h4 id="map">map</h4><p><code>map</code> 可以把一个数组按照一定的规则转换成另一个数组，定义如下：</p>
<pre><code><span class="func"><span class="keyword">func</span> <span class="title">map</span><span class="generics">&lt;U&gt;</span><span class="params">(transform: <span class="params">(T)</span></span></span> -&gt; <span class="type">U</span>) -&gt; <span class="type">U</span>[]
</code></pre><p>也就是说它接受一个函数叫做 <code>transform</code> ，然后这个函数可以把 T 类型的转换成 U 类型的并返回 (也就是 <code>(T) -&gt; U</code>)，最终 <code>map</code> 返回的是 U 类型的集合。</p>
<p>下面的表达式更有助于理解：</p>
<pre><code>[ x1, x2, ... , xn].<span class="function"><span class="title">map</span><span class="params">(f)</span></span> -&gt; [<span class="function"><span class="title">f</span><span class="params">(x1)</span></span>, <span class="function"><span class="title">f</span><span class="params">(x2)</span></span>, ... , <span class="function"><span class="title">f</span><span class="params">(xn)</span></span>]
</code></pre><p>如果用 <code>for in</code> 来实现，则需要这样：</p>
<pre><code>var newArray : Array&lt;T&gt; = []
<span class="keyword">for</span> <span class="property">item</span> <span class="keyword">in</span> oldArray {
    newArray += f(<span class="property">item</span>)
}
</code></pre><p>举个例子，我们可以这样把价格数组中的数字前面都加上 ￥ 符号：</p>
<pre><code><span class="tag">var</span> oldArray = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">45</span>,<span class="number">32</span>]
<span class="tag">var</span> newArray = oldArray.<span class="function"><span class="title">map</span><span class="params">({money in <span class="string">"￥\(money)"</span>})</span></span>

<span class="function"><span class="title">println</span><span class="params">(newArray)</span></span> <span class="comment">// [￥10, ￥20, ￥45, ￥32]</span>
</code></pre><p>如果你觉得 <code>money in</code> 也有点多余的话可以用 <code>$0</code> ：</p>
<pre><code>newArray = oldArray.<span class="function"><span class="title">map</span><span class="params">({<span class="string">"\($0)€"</span>})</span></span>
</code></pre><h4 id="filter">filter</h4><p>方法如其名， <code>filter</code> 起到的就是筛选的功能，参数是一个用来判断是否筛除的筛选闭包，定义如下：</p>
<pre><code><span class="func"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(includeElement: <span class="params">(T)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; [<span class="type">T</span>]
</code></pre><p>还是举个例子说明一下。首先先看下传统的 <code>for in</code> 实现的方法：</p>
<pre><code>var oldArray = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">45</span>,<span class="number">32</span>]
var filteredArray : Array&lt;Int&gt; = []
<span class="keyword">for</span> money in oldArray {
    <span class="keyword">if</span> (money &gt; <span class="number">30</span>) {
        filteredArray += money
    }
}
println(filteredArray)
</code></pre><p>奇怪的是这里的代码编译不通过：</p>
<pre><code>Playground execution <span class="attribute">failed</span>: &lt;EXPR&gt;:<span class="number">15</span>:<span class="number">9</span>: <span class="attribute">error</span>: <span class="string">'Array&lt;Int&gt;'</span> <span class="keyword">is</span> <span class="keyword">not</span> identical <span class="keyword">to</span> <span class="string">'UInt8'</span>
        filteredArray += money
</code></pre><p>发现原来是 <code>+=</code> 符号不能用于 <code>append</code> ，只能用于 <code>combine</code> ，在外面包个 <code>[]</code> 即可：</p>
<pre><code>var oldArray = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">45</span>,<span class="number">32</span>]
var filteredArray : Array&lt;Int&gt; = []
<span class="keyword">for</span> money in oldArray {
    <span class="keyword">if</span> (money &gt; <span class="number">30</span>) {
        filteredArray += [money]
    }
}
println(filteredArray) <span class="comment">// [45, 32]</span>
</code></pre><p>用 <code>filter</code> 可以这样实现：</p>
<pre><code>var oldArray = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">45</span>,<span class="number">32</span>]
var filteredArray  = oldArray.filter({
    <span class="keyword">return</span> $<span class="number">0</span> &gt; <span class="number">30</span>
})

println(filteredArray) <span class="comment">// [45, 32]</span>
</code></pre><p>少了很多代码。（你真的好短啊！</p>
<h4 id="reduce">reduce</h4><p><code>reduce</code> 函数解决了把数组中的值整合到某个独立对象的问题。定义如下：</p>
<pre><code><span class="func"><span class="keyword">func</span> <span class="title">reduce</span><span class="generics">&lt;U&gt;</span><span class="params">(initial: U, combine: <span class="params">(U, T)</span></span></span> -&gt; <span class="type">U</span>) -&gt; <span class="type">U</span>
</code></pre><p>好吧看起来略抽象。我们还是从 <code>for in</code> 开始。比如我们要把数组中的值都加起来放到 <code>sum</code> 里，那么传统做法是：</p>
<pre><code><span class="keyword">var</span> oldArray = [10,20,45,32]
<span class="keyword">var</span> <span class="keyword">sum</span> = 0
<span class="keyword">for</span> money <span class="keyword">in</span> oldArray {
    <span class="keyword">sum</span> = <span class="keyword">sum</span> + money
}
println(<span class="keyword">sum</span>) <span class="comment">// 107</span>
</code></pre><p><code>reduce</code> 有两个参数，一个是初始化的值，另一个是一个闭包，闭包有两个输入的参数，一个是原始值，一个是新进来的值，返回的新值也就是下一轮循环中的旧值。写几个小例子试一下：</p>
<pre><code>var oldArray = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">45</span>,<span class="number">32</span>]
var sum = <span class="number">0</span>
sum = oldArray.reduce(<span class="number">0</span>,{<span class="variable">$0</span> + <span class="variable">$1</span>}) // <span class="number">0</span>+<span class="number">10</span>+<span class="number">20</span>+<span class="number">45</span>+<span class="number">32</span> = <span class="number">107</span>
sum = oldArray.reduce(<span class="number">1</span>,{<span class="variable">$0</span> + <span class="variable">$1</span>}) // <span class="number">1</span>+<span class="number">10</span>+<span class="number">20</span>+<span class="number">45</span>+<span class="number">32</span> = <span class="number">108</span>
sum = oldArray.reduce(<span class="number">5</span>,{<span class="variable">$0</span> * <span class="variable">$1</span>}) // <span class="number">5</span>*<span class="number">10</span>*<span class="number">20</span>*<span class="number">45</span>*<span class="number">32</span> = <span class="number">1440000</span>
sum = oldArray.reduce(<span class="number">0</span>,+) // <span class="number">0</span>+<span class="number">10</span>+<span class="number">20</span>+<span class="number">45</span>+<span class="number">32</span> = <span class="number">107</span>
println(sum)
</code></pre><h3 id="函数式和指令式的比较">函数式和指令式的比较</h3><p>对于开发者们来说，大家最熟悉的编程范例之一应该是指令式编程。指令式编程是一种描述计算机所需作出的行为的编程范型。</p>
<p>我们通过一个简单的例子来演示两者的区别。比如我们需要将数组中的元素乘以2，然后取出大于10的结果。</p>
<p>指令式编程的写法如下：</p>
<pre><code><span class="keyword">var</span> source = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]
<span class="keyword">var</span> <span class="literal">result</span> = [<span class="type">Int</span>]()
<span class="keyword">for</span> i <span class="keyword">in</span> source {
    <span class="keyword">let</span> timesTwo = i * <span class="number">2</span>
    <span class="keyword">if</span> timesTwo &gt; <span class="number">10</span> {
        <span class="literal">result</span>.append(timesTwo)
    }
}
<span class="literal">result</span>  // [<span class="number">14</span>, <span class="number">18</span>]
</code></pre><p>函数式编程的写法如下：</p>
<pre><code><span class="keyword">var</span> source = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]
<span class="keyword">let</span> <span class="literal">result</span> = source.map { $<span class="number">0</span> * <span class="number">2</span> }
                   .filter { $<span class="number">0</span> &gt; <span class="number">10</span> }
<span class="literal">result</span>  // [<span class="number">14</span>, <span class="number">18</span>]
</code></pre><p>这个简单的例子并不是争论哪种范例更清晰，而是为了演示二者之间的区别。</p>
<p>在指令式编程里，我们给计算机下发了如下指令：</p>
<ul>
<li>遍历数组中的所有元素</li>
<li>在遍历中取出元素并乘以2</li>
<li>比较一下看看是否大于10</li>
<li>如果大于10则将它存到 result 数组中</li>
</ul>
<p>在函数式编程中，我们则是这样解决问题：</p>
<ul>
<li>将数组元素中的每个元素乘以2</li>
<li>在结果中选出大于10的元素</li>
</ul>
<p>指令式编程通过下达指令完成任务，侧重于具体流程以及状态变化；而函数式编程则专注于结果，以及为了得到结果需要做哪些转换。</p>
<h2 id="反应型_-_Reactive">反应型 - Reactive</h2><p>在日常开发中，我们经常需要监听某个属性，并且针对该属性的变化做一些处理。比如以下几个场景：</p>
<ul>
<li>用户在输入邮箱的时候，监测输入的内容并在界面上提示是否符合邮箱规范。</li>
<li>用户在修改用户名之后，所有显示用户名的界面都要改为新的用户名。</li>
</ul>
<p>外部输入信号的变化、事件的发生，这些都是典型的外部环境变化。根据外部环境的变化进行响应处理，直观上来讲像是一种自然地反应。我们可以将这种自动对变化作出响应的能力称为反应能力 (Reactive) 。</p>
<p>那么什么是反应型编程呢？</p>
<blockquote>
<p>Reactive programming is programming with asynchronous data streams.<br>反应型编程是异步数据流的编程。</p>
</blockquote>
<p>对于移动端来说，异步数据流的概念并不陌生，变量、点击事件、属性、缓存，这些就可以成为数据流。</p>
<p>我们可以通过一些简单的 ASCII 字符来演示如何将事件转换成数据流：</p>
<pre><code><span class="literal">-</span><span class="literal">-</span><span class="comment">a</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">b</span><span class="literal">-</span><span class="comment">c</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">d</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">X</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">|</span><span class="literal">-</span><span class="literal">-</span>&gt;

<span class="comment">a</span><span class="string">,</span> <span class="comment">b</span><span class="string">,</span> <span class="comment">c</span><span class="string">,</span> <span class="comment">d</span> <span class="comment">是具体的值，代表了某个事件</span>
<span class="comment">X</span> <span class="comment">表示发生了一个错误</span>
<span class="comment">|</span> <span class="comment">是这个流已经结束了的标记</span>
<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">是时间轴</span>
</code></pre><p>比如我们要统计用户点击鼠标的次数，那么可以这样：</p>
<pre><code>  <span class="comment">clickStream:</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">c</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">c</span><span class="literal">-</span><span class="literal">-</span><span class="comment">c</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">c</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">c</span><span class="literal">-</span><span class="literal">-</span>&gt;
               <span class="comment">vvvvv</span> <span class="comment">map(c</span> <span class="comment">becomes</span> <span class="comment">1)</span> <span class="comment">vvvv</span>
               <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">1</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">1</span><span class="literal">-</span><span class="literal">-</span><span class="comment">1</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">1</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">1</span><span class="literal">-</span><span class="literal">-</span>&gt;
               <span class="comment">vvvvvvvvv</span> <span class="comment">scan(</span><span class="literal">+</span><span class="comment">)</span> <span class="comment">vvvvvvvvv</span>
<span class="comment">counterStream:</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">1</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">2</span><span class="literal">-</span><span class="literal">-</span><span class="comment">3</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">4</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">5</span><span class="literal">-</span><span class="literal">-</span>&gt;
</code></pre><p>反应型编程就是基于这些数据流的编程。而函数式编程则相当于提供了一个工具箱，可以方便的对数据流进行合并、创建和过滤等操作。</p>
<h2 id="Swift">Swift</h2><p>Swift 是苹果公司在 2014 年推出的编程语言，用于编写 iOS 和 OS X 应用程序。它吸收了很多其它语言的语法特性，例如闭包、元组、泛型、结构体等等，这使得它的语法简洁而灵活。</p>
<p>Swift 本身并不是一门函数式语言，不过它有一些函数式的方法和特性，这让人不禁产生了使用 Swift 进行函数式编程的遐想。</p>
<p>和 Objective-C 相比， Swift 更接近于函数式，它支持以下特性：</p>
<ul>
<li><code>map</code> <code>reduce</code> 等函数式函数</li>
<li>函数是一等公民</li>
<li>模式匹配</li>
<li>…</li>
</ul>
<p>但是和真正的函数式语言相比， Swift 还差很多：</p>
<ul>
<li>没有 <code>flatmap</code></li>
<li>无法迅速取出 <code>head</code> 和 <code>tail</code></li>
<li>没有 <code>foldLeft</code></li>
<li>…</li>
</ul>
<p>我们并不能因为 Swift 中的一些函数式特性就把它归为函数式语言，但是我们可以利用这些特性进行函数式 Style 的编程。</p>
<h2 id="小结">小结</h2><p>终于花时间把前阵子炒得火热的函数式编程简单的了解了一圈，最大的感想便是：“原来代码可以这样写”。</p>
<p>在下一章中，我们将结合 Swift 和 RAC 写一写代码，一起体验 FRP 的魅力。</p>
<hr>
<p>参考文献：</p>
<ul>
<li><p>Wiki</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Programming_paradigm" target="_blank" rel="external">Programming paradigm</a></li>
<li><a href="http://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank" rel="external">Functional reactive programming</a></li>
</ul>
</li>
<li><p>Functional</p>
<ul>
<li><a href="http://blog.maybeapps.com/post/42894317939/input-and-output" target="_blank" rel="external">Input and Output</a></li>
<li><a href="http://stackoverflow.com/questions/13341937/whats-the-status-of-current-functional-reactive-programming-implementations" target="_blank" rel="external">What’s the status of current FRP implementations?</a></li>
<li><a href="http://learnxinyminutes.com/docs/clojure/" target="_blank" rel="external">Learn X in Y minutes - Where X=clojure</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/bb669144.aspx" target="_blank" rel="external">Functional Programming vs. Imperative Programming</a></li>
<li><a href="http://jamesonquave.com/blog/functional-programming-in-swift/" target="_blank" rel="external">Functional Programming in Swift</a></li>
<li><a href="http://robnapier.net/swift-is-not-functional" target="_blank" rel="external">Swift Is Not Functional</a></li>
<li><a href="http://code.martinrue.com/posts/functions-and-closures-in-swift" target="_blank" rel="external">Functions and Closures in Swift</a></li>
</ul>
</li>
<li><p>Reactive</p>
<ul>
<li><a href="https://leanpub.com/iosfrp/" target="_blank" rel="external">Functional Reactive Programming on iOS</a></li>
<li><a href="https://medium.com/swift-programming/reactive-swift-3b6050375534" target="_blank" rel="external">Reactive Swift</a></li>
<li><a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754" target="_blank" rel="external">The introduction to Reactive Programming you’ve been missing</a></li>
<li><a href="http://napora.org/a-swift-reaction/" target="_blank" rel="external">A Swift Reaction</a></li>
<li><a href="http://rasic.info/from-mvc-to-mvvm-in-swift/" target="_blank" rel="external">From MVC to MVVM in Swift</a></li>
<li><a href="http://rasic.info/bindings-generics-swift-and-mvvm/" target="_blank" rel="external">Bindings, Generics, Swift and MVVM</a></li>
<li><a href="http://www.teehanlax.com/blog/model-view-viewmodel-for-ios/" target="_blank" rel="external">Model-View-ViewModel for iOS</a></li>
<li><a href="https://speakerdeck.com/ashfurrow/functional-reactive-programming-in-swift" target="_blank" rel="external">Functional Reactive Programming in Swift</a></li>
</ul>
</li>
<li><p>中文博客</p>
<ul>
<li><a href="http://www.infoq.com/cn/articles/functional-reactive-programming" target="_blank" rel="external">函数式反应型编程(FRP) - 实时互动应用开发的新思路</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html" target="_blank" rel="external">函数式编程初探</a></li>
<li><a href="http://coolshell.cn/articles/10822.html" target="_blank" rel="external">函数式编程</a></li>
<li><a href="http://xumingming.sinaapp.com/302/clojure-functional-programming-for-the-jvm-clojure-tutorial/" target="_blank" rel="external">Clojure入门教程: Clojure – Functional Programming for the JVM中文版</a></li>
<li><a href="http://blog.leezhong.com/ios/2013/06/19/frp-reactivecocoa.html" target="_blank" rel="external">ReactiveCocoa 与 Functional Reactive Programming</a></li>
<li><a href="http://blog.zhaojie.me/2010/09/async-programming-and-reactive-framework.html" target="_blank" rel="external">异步编程与响应式框架</a></li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[换个思路，换个心情，写一些有趣的代码。]]>
    
    </summary>
    
      <category term="Reactive" scheme="http://blog.callmewhy.com/tags/Reactive/"/>
    
      <category term="开发笔记" scheme="http://blog.callmewhy.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[面向轨道编程 - Swift 中的异常处理]]></title>
    <link href="http://blog.callmewhy.com/2015/04/20/error-handling-in-swift/"/>
    <id>http://blog.callmewhy.com/2015/04/20/error-handling-in-swift/</id>
    <published>2015-04-20T12:06:35.000Z</published>
    <updated>2015-04-21T11:41:32.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题">问题</h2><p>在开发过程中，异常处理算是比较常见的问题了。</p>
<p>举一个比较常见的例子：用户修改注册的邮箱，大概分为以下几个步骤：</p>
<ul>
<li>接收到一个用户的请求：我要修改邮箱地址</li>
<li>验证一下请求是否合法，将请求进行格式转化</li>
<li>更新以前的邮箱地址记录</li>
<li>给新的邮箱地址发送验证邮件</li>
<li>将结果返回给用户</li>
</ul>
<p>上面的步骤如果一切顺利，那代码肯定干净利落，但是人生不如意十有八九，上面的步骤很容易出现问题：</p>
<ul>
<li>用户把邮箱地址填成了家庭地址</li>
<li>用户是个黑客，没登录就发送了更新请求</li>
<li>发送验证邮件的时候服务器爆炸了，发送邮件失败</li>
</ul>
<p>各种异常都会导致这次操作的失败。</p>
<h3 id="方案一">方案一</h3><p>在传统的处理方案里，一般是遇到异常就往上抛：</p>
<p><img src="http://segmentfault.com/img/bVlsK9" alt=""></p>
<p>这种方案想必大家都不陌生，比如下面这段代码：</p>
<pre><code><span class="type">NSError</span> *err = <span class="keyword">nil</span>;
<span class="type">CGFloat</span> <span class="literal">result</span> = [<span class="type">MathTool</span> divide:<span class="number">2</span>.<span class="number">5</span> by:<span class="number">3</span>.<span class="number">0</span> error:&amp;err];

<span class="keyword">if</span> (err) {
    <span class="type">NSLog</span>(@<span class="string">"%@"</span>, err)
} <span class="keyword">else</span> {
    [<span class="type">MathTool</span> doSomethingWithResult:<span class="literal">result</span>]
}
</code></pre><h3 id="方案二">方案二</h3><p>而另一种方案，则是将错误的结果继续往后传，在最后统一处理：</p>
<p><img src="http://segmentfault.com/img/bVlsLe" alt=""></p>
<p>这种方案有两个问题：</p>
<ul>
<li>在发生异常的时候，如何把异常继续传给下面的函数？</li>
<li>当整个流程结束的时候，一个函数如何输出多个结果？</li>
</ul>
<h2 id="车轨">车轨</h2><p>我们把方案二抽象出来，就像是一段车轨：</p>
<p><img src="http://segmentfault.com/img/bVlsNx" alt=""></p>
<p>对于同一个输入，会有 Success 和 Failure 两种输出结果，对于 Success 的情况，我们希望它能继续走到后面的流程里，而对于 Failure 的情况，它怎么处理并不重要，我们希望它能避开后面的流程：</p>
<p><img src="http://segmentfault.com/img/bVlsNC" alt=""></p>
<p>于是乎，两段车轨拼接的时候，便成了这样：</p>
<p><img src="http://segmentfault.com/img/bVlsNH" alt=""></p>
<p>那么三段什么的自然也不在话下了。我们把下面那根 Failure 的线路扩展一下，便会看到两条平行的线路，这便是“双轨模型” (Two Track Model) ，这是用“面向轨道编程”思想解决异常处理的理论基础。</p>
<p><img src="http://segmentfault.com/img/bVlsNK" alt=""></p>
<p>这就是 “面向轨道编程” 。一开始我觉得这概念应该只是来搞笑的，仔细想想似乎倒也是很贴切。将事件流当做两条平行的轨道，如果顺利则在上行轨道，继续传递给下个业务逻辑去处理，如果出现异常也不慌，直接扔到下行轨道，一直在下行轨道传递到终点，在最后统一处理。</p>
<p>这样处理使得整个流程变成了一条双进双出的流水线，有点像是 shell 里的 pipeline ，上一次的输出作为下一次的输入，十分顺畅。而且拼接起来也很方便，我们可以把三段拼接成一段暴露给其他对象使用：</p>
<p><img src="http://segmentfault.com/img/bVlsOy" alt=""></p>
<h2 id="实现">实现</h2><p>接下来看看在 Swift 中如何应用这种思路处理异常。</p>
<p>首先我们需要两种类型的输出结果：</p>
<ul>
<li>成功，返回某种类型的值</li>
<li>失败，返回一个 Error 对象或者失败的具体信息</li>
</ul>
<p>照着这个想法，我们可以定义一个 Result 枚举用做输出：</p>
<pre><code><span class="class"><span class="keyword">enum</span> <span class="title">Result</span>&lt;<span class="title">T</span>&gt; {</span>
    <span class="keyword">case</span> <span class="constant">Success</span>(<span class="constant">T</span>)
    <span class="keyword">case</span> <span class="constant">Failure</span>(<span class="constant">String</span>)
}
</code></pre><p>利用 Swift 的枚举特性，我们可以在成功的枚举值里关联一些返回值，然后在失败的情况下则带上失败的消息内容。不过 enum 目前还不支持泛型，我们可以在外面封装一个 <code>Box</code> 类来解决这个问题：</p>
<pre><code>final <span class="class"><span class="keyword">class</span> <span class="title">Box</span><span class="inheritance">&lt;<span class="parent">T</span></span>&gt; {</span>
    let <span class="symbol">value:</span> <span class="constant">T</span>
    init(<span class="symbol">value:</span> <span class="constant">T</span>) {
        <span class="keyword">self</span>.value = value
    }
}

<span class="class"><span class="keyword">enum</span> <span class="title">Result</span>&lt;<span class="title">T</span>&gt; {</span>
    <span class="keyword">case</span> <span class="constant">Success</span>(<span class="constant">Box</span>&lt;<span class="constant">T</span>&gt;)
    <span class="keyword">case</span> <span class="constant">Failure</span>(<span class="constant">String</span>)
}
</code></pre><p>再看下一开始我们举的那个例子，用这个枚举类重新写下就是这样的：</p>
<pre><code><span class="keyword">var</span> <span class="literal">result</span> = divide(<span class="number">2</span>.<span class="number">5</span>, by:<span class="number">3</span>)
switch <span class="literal">result</span> {
<span class="keyword">case</span> .<span class="type">Success</span>(<span class="keyword">let</span> value):
    doSomethingWithResult(value)
<span class="keyword">case</span> .<span class="type">Failure</span>(<span class="keyword">let</span> errString):
    println(errString)
}
</code></pre><p>“看起来好像也没什么嘛，你不还是用了个大括号处理两种情况嘛！”（嫌弃脸</p>
<p>确实正如这位热情的朋友所说，写完这个例子我也没觉得有什么优点，难道我就是来搞笑的？</p>
<p>“并不。”（严肃脸</p>
<h2 id="栗子">栗子</h2><p>接下来我们举个栗子玩一玩。为了更好的观赏效果，请允许我使用浮夸的写法和粗暴的命名举这个栗子。</p>
<p>比如对于即将输入的数字 x ，我们希望输出 <code>4 / (2 / x - 1)</code> 的计算结果。这里会有两处出错的可能，一个是 <code>(2 / x)</code> 时 <code>x</code> 为 0 ，另一个就是 <code>(2 / x - 1)</code> 为 0 的情况。</p>
<p>先看下传统写法：</p>
<pre><code><span class="keyword">let</span> errorStr = <span class="string">"输入错误，我很抱歉"</span>
func cal(<span class="keyword">value</span>: Float) {
    <span class="keyword">if</span> <span class="keyword">value</span> == <span class="number">0</span> {
        println(errorStr)
    } <span class="keyword">else</span> {
        <span class="keyword">let</span> <span class="keyword">value</span><span class="number">1</span> = <span class="number">2</span> / <span class="keyword">value</span>
        <span class="keyword">let</span> <span class="keyword">value</span><span class="number">2</span> = <span class="keyword">value</span><span class="number">1</span> - <span class="number">1</span>
        <span class="keyword">if</span> <span class="keyword">value</span><span class="number">2</span> == <span class="number">0</span> {
            println(errorStr)
        } <span class="keyword">else</span> {
            <span class="keyword">let</span> <span class="keyword">value</span><span class="number">3</span> = <span class="number">4</span> / <span class="keyword">value</span><span class="number">2</span>
            println(<span class="keyword">value</span><span class="number">3</span>)
        }
    }
}
cal(<span class="number">2</span>)    <span class="comment">// 输入错误，我很抱歉</span>
cal(<span class="number">1</span>)    <span class="comment">// 4.0</span>
cal(<span class="number">0</span>)    <span class="comment">// 输入错误，我很抱歉</span>
</code></pre><p>那么用面向轨道的思想怎么去解决这个问题呢？</p>
<p>大概是这个样子的：</p>
<pre><code><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>{
    <span class="keyword">let</span> value: <span class="type">T</span>
    <span class="keyword">init</span>(value: <span class="type">T</span>) {
        <span class="keyword">self</span>.value = value
    }
}

<span class="class"><span class="keyword">enum</span> <span class="title">Result</span>&lt;<span class="title">T</span>&gt; </span>{
    <span class="keyword">case</span> <span class="type">Success</span>(<span class="type">Box</span>&lt;<span class="type">T</span>&gt;)
    <span class="keyword">case</span> <span class="type">Failure</span>(<span class="type">String</span>)
}

<span class="keyword">let</span> errorStr = <span class="string">"输入错误，我很抱歉"</span>

<span class="func"><span class="keyword">func</span> <span class="title">cal</span><span class="params">(value: Float)</span></span> {
    <span class="func"><span class="keyword">func</span> <span class="title">cal1</span><span class="params">(value: Float)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Float</span>&gt; {
        <span class="keyword">if</span> value == <span class="number">0</span> {
            <span class="keyword">return</span> .<span class="type">Failure</span>(errorStr)
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> .<span class="type">Success</span>(<span class="type">Box</span>(value: <span class="number">2</span> / value))
        }
    }
    <span class="func"><span class="keyword">func</span> <span class="title">cal2</span><span class="params">(value: Result&lt;Float&gt;)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Float</span>&gt; {
        <span class="keyword">switch</span> value {
        <span class="keyword">case</span> .<span class="type">Success</span>(<span class="keyword">let</span> v):
            <span class="keyword">return</span> .<span class="type">Success</span>(<span class="type">Box</span>(value: v.value - <span class="number">1</span>))
        <span class="keyword">case</span> .<span class="type">Failure</span>(<span class="keyword">let</span> str):
            <span class="keyword">return</span> .<span class="type">Failure</span>(str)
        }
    }
    <span class="func"><span class="keyword">func</span> <span class="title">cal3</span><span class="params">(value: Result&lt;Float&gt;)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Float</span>&gt; {
        <span class="keyword">switch</span> value {
        <span class="keyword">case</span> .<span class="type">Success</span>(<span class="keyword">let</span> v):
            <span class="keyword">if</span> v.value == <span class="number">0</span> {
                <span class="keyword">return</span> .<span class="type">Failure</span>(errorStr)
            } <span class="keyword">else</span> {
                <span class="keyword">return</span> .<span class="type">Success</span>(<span class="type">Box</span>(value: <span class="number">4</span> / v.value))
            }
        <span class="keyword">case</span> .<span class="type">Failure</span>(<span class="keyword">let</span> str):
            <span class="keyword">return</span> .<span class="type">Failure</span>(str)
        }
    }

    <span class="keyword">let</span> r = cal3(cal2(cal1(value)))
    <span class="keyword">switch</span> r {
    <span class="keyword">case</span> .<span class="type">Success</span>(<span class="keyword">let</span> v):
        <span class="built_in">println</span>(v.value)
    <span class="keyword">case</span> .<span class="type">Failure</span>(<span class="keyword">let</span> s):
        <span class="built_in">println</span>(s)
    }   
}
cal(<span class="number">2</span>)    <span class="comment">// 输入错误，我很抱歉</span>
cal(<span class="number">1</span>)    <span class="comment">// 4.0</span>
cal(<span class="number">0</span>)    <span class="comment">// 输入错误，我很抱歉</span>
</code></pre><p>同学，放下手里的键盘，冷静下来，有话好好说。</p>
<h2 id="反思">反思</h2><p>面向轨道之后，代码量翻了两倍多，而且<del>似乎</del>变得更难读了。浪费了大家这么多时间结果就带来这么个玩意儿，实在是对不起观众们热情的掌声。</p>
<p>仔细看下上面的代码， <code>switch</code> 的操作重复而多余，都在重复着把 Success 和 Failure 分开的逻辑，实际上每个函数只需要处理 Success 的情况。我们在 <code>Result</code> 中加入 <code>funnel</code> 提前处理掉 Failure 的情况：</p>
<pre><code><span class="class"><span class="keyword">enum</span> <span class="title">Result</span>&lt;<span class="title">T</span>&gt; {</span>
    <span class="keyword">case</span> <span class="constant">Success</span>(<span class="constant">Box</span>&lt;<span class="constant">T</span>&gt;)
    <span class="keyword">case</span> <span class="constant">Failure</span>(<span class="constant">String</span>)

    func funnel&lt;<span class="constant">U</span>&gt;(<span class="symbol">f:</span><span class="constant">T</span> -&gt; <span class="constant">Result</span>&lt;<span class="constant">U</span>&gt;) -&gt; <span class="constant">Result</span>&lt;<span class="constant">U</span>&gt; {
        switch <span class="keyword">self</span> {
        <span class="keyword">case</span> <span class="constant">Success</span>(let value):
            <span class="keyword">return</span> f(value.value)
        <span class="keyword">case</span> <span class="constant">Failure</span>(let errString):
            <span class="keyword">return</span> <span class="constant">Result</span>&lt;<span class="constant">U</span>&gt;.<span class="constant">Failure</span>(errString)
        }
    }
}
</code></pre><p><code>funnel</code> 帮我们把上次的结果进行分流，只将 Success 的轨道对接到了下个业务上，而将 Failure 引到了下一个 Failure 轨道上。</p>
<p>接下来再回到栗子里，此时我们已经不再需要传入 Result 值了，只需要传入 value 即可：</p>
<pre><code><span class="func"><span class="keyword">func</span> <span class="title">cal</span><span class="params">(value: Float)</span></span> {
    <span class="func"><span class="keyword">func</span> <span class="title">cal1</span><span class="params">(v: Float)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Float</span>&gt; {
        <span class="keyword">if</span> v == <span class="number">0</span> {
            <span class="keyword">return</span> .<span class="type">Failure</span>(errorStr)
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> .<span class="type">Success</span>(<span class="type">Box</span>(<span class="number">2</span> / v))
        }
    }

    <span class="func"><span class="keyword">func</span> <span class="title">cal2</span><span class="params">(v: Float)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Float</span>&gt; {
        <span class="keyword">return</span> .<span class="type">Success</span>(<span class="type">Box</span>(v - <span class="number">1</span>))
    }

    <span class="func"><span class="keyword">func</span> <span class="title">cal3</span><span class="params">(v: Float)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Float</span>&gt; {
        <span class="keyword">if</span> v == <span class="number">0</span> {
            <span class="keyword">return</span> .<span class="type">Failure</span>(errorStr)
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> .<span class="type">Success</span>(<span class="type">Box</span>(<span class="number">4</span> / v))
        }
    }

    <span class="keyword">let</span> r = cal1(value).funnel(cal2).funnel(cal3)
    <span class="keyword">switch</span> r {
    <span class="keyword">case</span> .<span class="type">Success</span>(<span class="keyword">let</span> v):
        <span class="built_in">println</span>(v.value)
    <span class="keyword">case</span> .<span class="type">Failure</span>(<span class="keyword">let</span> s):
        <span class="built_in">println</span>(s)
    }
}
</code></pre><p>看起来简洁了一些。我们可以通过 <code>cal1(value).funnel(cal2).funnel(cal3)</code> 这样的链式调用来获取计算结果。</p>
<p>“面向轨道”编程确实给我们提供了一个很有趣的思路。本文只是一个简单地讨论，进一步学习可以仔细阅读后面的参考文献。比如 <a href="https://gist.github.com/DivineDominion/21446ef37ac87c62567b" target="_blank" rel="external">ValueTransformation.swift</a> 这个真实的完整案例，以及 <a href="https://github.com/antitypical/Result" target="_blank" rel="external">antitypical/Result</a> 这个封装完整的 Result 库。文中的实现方案只是一个比较简单的方法，和前两种实现略有差异。</p>
<p>面向铁轨，春暖花开。愿每段代码都走在 Happy Path 上，愿每个人都有个 Happy Ending 。</p>
<hr>
<p>参考文献：</p>
<ul>
<li><a href="https://vimeo.com/97344498" target="_blank" rel="external">Railway Oriented Programming - error handling in functional languages</a></li>
<li><a href="http://natashatherobot.com/swift-generics-box/" target="_blank" rel="external">Swift: Putting Your Generics in a Box</a></li>
<li><a href="http://nomothetis.svbtle.com/error-handling-in-swift" target="_blank" rel="external">Error Handling in Swift: Might and Magic</a></li>
<li><a href="http://nomothetis.svbtle.com/error-handling-in-swift-part-ii" target="_blank" rel="external">Error Handling in Swift: Might and Magic—Part II</a></li>
<li><a href="http://christiantietze.de/posts/2015/04/guard-latency-failure/" target="_blank" rel="external">Return Types can Capture Async Processes and Failures</a></li>
<li><a href="http://christiantietze.de/posts/2015/02/beyond-guard-clauses/" target="_blank" rel="external">Going Beyond Guard Clauses in Swift</a></li>
<li><a href="http://christiantietze.de/posts/2015/02/functional-swift-exceptions/" target="_blank" rel="external">Functional Error Handling in Swift Without Exceptions</a></li>
<li><a href="https://gist.github.com/DivineDominion/21446ef37ac87c62567b" target="_blank" rel="external">ValueTransformation.swift</a></li>
<li><a href="https://github.com/antitypical/Result" target="_blank" rel="external">antitypical/Result</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[A program is a spell cast over a computer, turning input into error messages.]]>
    
    </summary>
    
      <category term="Swift" scheme="http://blog.callmewhy.com/tags/Swift/"/>
    
      <category term="开发笔记" scheme="http://blog.callmewhy.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用函数式编程解决逻辑难题 - Swift 版本]]></title>
    <link href="http://blog.callmewhy.com/2015/03/14/getting-into-functional-programming-with-swift/"/>
    <id>http://blog.callmewhy.com/2015/03/14/getting-into-functional-programming-with-swift/</id>
    <published>2015-03-14T13:11:59.000Z</published>
    <updated>2015-04-25T10:03:34.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这篇翻译的文章，用两种方法解决了同一个逻辑难题。第一种方法的编程风格接近大多数 iOS 开发者，实现了指令式编程的解决方案。第二种方法利用了 Swift 的一些语言特性，实现了函数式编程的解决方案。</p>
<p>源代码可以在这里下载：<a href="https://github.com/ijoshsmith/break-a-dollar" target="_blank" rel="external">https://github.com/ijoshsmith/break-a-dollar</a></p>
</blockquote>
<h2 id="逻辑难题">逻辑难题</h2><p>前阵子朋友和我说起，把1美元分解成更小的面额，有293种方法。换句话说，如果一个哥们儿告诉你他有1美元，那么他的手里有293种可能的组合，有可能是两个50美分，也可能是4个25美分。第二天，我就开始尝试用代码去解决这个问题。这篇博客回顾了当时想到的两种解决方案。</p>
<h2 id="美元硬币">美元硬币</h2><p>对于不熟悉美元硬币的同学，可以先了解一下美元的硬币。如下图所示，1美元(dollar) = 100美分(cent)：</p>
<p><img src="https://ijoshsmith.files.wordpress.com/2014/11/coins1.jpg?w=960&amp;h=296" alt=""></p>
<h2 id="初探问题">初探问题</h2><p>思考后我发现用一种比较简单肮脏的手段解决这个问题并不难，但是这还远远不够。我想找到一种优雅的解决方案，所以我尝试从各个角度思考这个问题，最终得到了想要的答案。</p>
<p>解决这个问题的关键在于递归的分解问题。“如何用各种硬币组合拼成1美元”，更宽泛点讲，其实就是“如何用各种硬币组合拼成指定金额”。</p>
<p>举个人民币的例子。你欠人家100块，人家说你100块都不给我。你说好，我给！于是掏出两张50，这便是一个50+50的解决方案。<br>这时你发现有一张是崭新的50，你不想给他这张50，于是你的问题变成了：如何用手里的碎钱组合出50面额的钱。<br>后来你把50换成了5张10块，这便是一个50+10*5的解决方案，然后感觉有一张10块是崭新的，要不我换成硬币给他。<br>于是问题又变成了：如何组合出10面额的钱。就是这样慢慢拆分下去。</p>
<p>点击 <a href="https://github.com/ijoshsmith/break-a-dollar/blob/master/DollarBreak/algorithm_overview.txt" target="_blank" rel="external">这里</a> 查看完整的算法回顾。</p>
<h2 id="先造硬币">先造硬币</h2><p>我多次提到“硬币”这个词，实际上一枚硬币也就是一个整数值，代替了它价值多少美分。我写一个枚举类存储所有的硬币面额，然后再用一个静态方法降序返回所有的值：</p>
<pre><code><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span>: <span class="title">Int</span> {</span>
    <span class="keyword">case</span> <span class="constant">SilverDollar</span> = <span class="number">100</span>
    <span class="keyword">case</span> <span class="constant">HalfDollar</span>   = <span class="number">50</span>
    <span class="keyword">case</span> <span class="constant">Quarter</span>      = <span class="number">25</span>
    <span class="keyword">case</span> <span class="constant">Dime</span>         = <span class="number">10</span>
    <span class="keyword">case</span> <span class="constant">Nickel</span>       = <span class="number">5</span>
    <span class="keyword">case</span> <span class="constant">Penny</span>        = <span class="number">1</span>

    static func coinsInDescendingOrder() -&gt; [<span class="constant">Coin</span>] {
        <span class="keyword">return</span> [
            <span class="constant">Coin</span>.<span class="constant">SilverDollar</span>,
            <span class="constant">Coin</span>.<span class="constant">HalfDollar</span>,
            <span class="constant">Coin</span>.<span class="constant">Quarter</span>,
            <span class="constant">Coin</span>.<span class="constant">Dime</span>,
            <span class="constant">Coin</span>.<span class="constant">Nickel</span>,
            <span class="constant">Coin</span>.<span class="constant">Penny</span>,
        ]
    }
}
</code></pre><h2 id="解决方案1：指令式编程_-_Imperative">解决方案1：指令式编程 - Imperative</h2><p>指令式编程的一个重要观点是：变量改变状态。指令式的程序像是一种微型控制器，它告诉计算机如何完成任务。接下来的 Swift 代码大家看起来应该都不陌生，因为 objc 就是一种指令式的编程语言：</p>
<pre><code><span class="func"><span class="keyword">func</span> <span class="title">countWaysToBreakAmout</span><span class="params">(amount: Int, usingCoins coins:[Coin])</span></span> -&gt; <span class="type">Int</span>{
    <span class="keyword">let</span> coin = coins[<span class="number">0</span>]
    <span class="keyword">if</span> (coin == .<span class="type">Penny</span>) {
        <span class="keyword">return</span> <span class="number">1</span>
    }

    <span class="keyword">var</span> smallerCoins = [<span class="type">Coin</span>]()
    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span>..&lt;coins.<span class="built_in">count</span> {
        smallerCoins.append(coins[index])
    }

    <span class="keyword">var</span> sum = <span class="number">0</span>
    <span class="keyword">for</span> coinCount <span class="keyword">in</span> <span class="number">0</span>...(amount/coin.rawValue) {
        <span class="keyword">let</span> remainingAmount = amount - (coin.rawValue * coinCount)
        sum += countWaysToBreakAmout(remainingAmount, usingCoins: smallerCoins)
    }

    <span class="keyword">return</span> sum
}
</code></pre><p>仔细看下上面的代码，计算过程一共分三步：</p>
<ul>
<li>首先取出可用数组中的第一个硬币，如果这枚硬币已经是 1 美分，也就是最小的面额，那没有继续拆分的可能性，直接返回1作为结束。</li>
<li>然后创建了一个数组 (<code>smallerCoins</code>) ，存储比当前硬币更小的硬币，用来作为下次调用的参数。</li>
<li>最后计算除去第一次取出的硬币之后，还有多少种解决方案。</li>
</ul>
<p>这样的代码对于指令式编程来说再平常不过，接下来我们就来看下如何用函数式编程解决这个问题。</p>
<h2 id="解决方案2：函数式编程_-_Functional">解决方案2：函数式编程 - Functional</h2><p>函数式编程的依赖对象，是函数，而不是状态变化。没有太多的共享数据，就意味着发生错误的可能性更小，需要同步数据的次数也越少。 Swift 中函数已经是一等公民，这让<a href="http://zh.wikipedia.org/wiki/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0" target="_blank" rel="external">高阶函数</a>变成可能，也就是说，一个函数可以是通过其它函数组装构成的。随着 objc 中 block 的引入， iOS 开发者对这个应该并不陌生。</p>
<p>下面是我的函数式解决方案：</p>
<pre><code><span class="func"><span class="keyword">func</span> <span class="title">countWaysToBreakAmount</span><span class="params">(amount: Int, usingCoins coins:Slice&lt;Coin&gt;)</span></span> -&gt; <span class="type">Int</span>{
    <span class="keyword">let</span> (coin, smallerCoins) = (coins[<span class="number">0</span>], coins[<span class="number">1</span>..&lt;coins.<span class="built_in">count</span>])
    <span class="keyword">if</span> (coin == .<span class="type">Penny</span>) {
        <span class="keyword">return</span> <span class="number">1</span>
    }
    <span class="keyword">let</span> coinCounts = [<span class="type">Int</span>](<span class="number">0</span>...amount/coin.rawValue)
    <span class="keyword">return</span> coinCounts.<span class="built_in">reduce</span>(<span class="number">0</span>) { (sum, coinCount) <span class="keyword">in</span>
        <span class="keyword">let</span> remainingAmount = amount - (coin.rawValue * coinCount)
        <span class="keyword">return</span> sum + <span class="keyword">self</span>.countWaysToBreakAmount(remainingAmount, usingCoins: smallerCoins)
    }
}
</code></pre><p>第二个参数是 <code>Slice&lt;Coin&gt;</code> 而不是数组，因为没必要把硬币拷贝到新的数组里。我们只需要用数组的一个切片就可以，也就是第一行代码里的 <code>smallerCoins</code> ，在函数式编程里称之为 <code>tail</code> 。我们把数据中的第一个元素称之为 <code>head</code> ，剩下来的部分称之为 <code>tail</code> 。将数组进行切分在下标越界的情况下也不会引发异常。如果数组中只剩下一个元素，这时 <code>smallerCoins</code> 就为空。</p>
<p>我用元组的语法同时获取了 <code>coin</code> 和 <code>smallerCoins</code> 这两个数据，因为取头取尾可以说是同一个操作。与其写一堆代码去解释如何先取出第一个元素，然后再获取剩下的元素，不如直接用“取出头部和尾部”这样语义化的方式一步到位。</p>
<p>接下来，也并没有采用循环然后改变局部变量的方法来计算剩余的组合数，而是用 <code>reduce</code> 这个高阶函数。如果你对 <code>reduce</code> 这个函数不太熟悉，可以看下<a href="http://ijoshsmith.com/2014/06/25/understanding-swifts-reduce-method/" target="_blank" rel="external">这篇文章</a>有个大概的了解。</p>
<p>首先 <code>coin</code> 指当前处理的硬币， <code>coinCounts</code> 是一个数组，里面存储了所有当前面额的硬币的可能出现的数目。比如 <code>amount</code> 是10， <code>coin</code> 是3，那么 <code>coinCounts</code> 的值就是，面额为3的硬币可能有多少。显然应该最多出现3个，所以 <code>coinCounts</code> 是 [1,2,3] 这样的一列数。然后在分别对每种情况进行分解计算。</p>
<h2 id="思考">思考</h2><p>Swift 对于函数式编程的支持让我感觉的兴奋，Excited！换种方式思考或许是个不小的挑战，但是这都是值得的。几年前我自学了一些 Haskell ，我很欣喜的发现一些函数式思考习惯，让我在 iOS 开发中也能受益匪浅。</p>
<p>示例项目的源代码可以在<a href="https://github.com/ijoshsmith/break-a-dollar" target="_blank" rel="external">这里</a>下载。</p>
<hr>
<p>原文地址：</p>
<ul>
<li><a href="http://ijoshsmith.com/2014/11/30/getting-into-functional-programming-with-swift/" target="_blank" rel="external">Getting into functional programming with Swift</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[好坏好坏的，100块都不给我！]]>
    
    </summary>
    
      <category term="Functional" scheme="http://blog.callmewhy.com/tags/Functional/"/>
    
      <category term="翻译笔记" scheme="http://blog.callmewhy.com/categories/%E7%BF%BB%E8%AF%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JSQMessage 源码对比阅读笔记]]></title>
    <link href="http://blog.callmewhy.com/2015/03/02/jsqmessage-code-reading-notes/"/>
    <id>http://blog.callmewhy.com/2015/03/02/jsqmessage-code-reading-notes/</id>
    <published>2015-03-02T03:12:15.000Z</published>
    <updated>2015-04-25T10:03:34.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/jessesquires/JSQMessagesViewController" target="_blank" rel="external">JSQMessagesViewController</a> 是 <a href="http://www.jessesquires.com/" target="_blank" rel="external">Jesse Squires</a> 开发的一个消息界面的 UI 库。</p>
<p><code>HBTalkTableView</code> 是公司自己人写的。 <code>HB</code> 的前缀实在是不知道有什么缘由，暂且理解成 哈利(Hali)波特(Bote) 的缩写吧。</p>
<p>一起对照阅读了两边的代码，写篇博客记录一下。</p>
<a id="more"></a>
<p>方便起见，后面 <code>JSQMessagesViewController</code> 简称为 <code>JSQ</code> ，<code>HBTalkTableView</code> 简称为 <code>HB</code> 。</p>
<h2 id="Round_1_-_Overview">Round 1 - Overview</h2><h3 id="HB">HB</h3><p>HB 的消息界面是这样的：</p>
<p><img src="http://callmewhy.qiniudn.com/Screen%20Shot%202015-03-02%20at%2011.20.54.png" alt=""></p>
<h3 id="JSQ">JSQ</h3><p>JSQ 的消息界面是这样的：</p>
<p><img src="https://raw.githubusercontent.com/jessesquires/JSQMessagesViewController/develop/Screenshots/screenshot0.png" alt=""></p>
<p>可以看到一些基本功能相同，文字、图片、视屏、电话和网址识别、长按操作、等等。</p>
<p>OK，旗鼓相当，第一回合双方持平。</p>
<h2 id="Round_2_-_Cell">Round 2 - Cell</h2><h3 id="HB-1">HB</h3><p>在 <code>HB</code> 里面，继承了 <code>UITableViewCell</code> 的 <code>HBTalkTableViewCell</code> 是所有 <code>Cell</code> 的基类，定义了时间戳、气泡框这些基础 view ，并且定义 <code>HBTalkTableCellDelegate</code> ，用来处理所有委托事件。</p>
<p>其中有个 <code>cellWithMessage</code> 的构造函数，根据传入的 <code>HBTalkData</code> 类型不同，分别 <code>init</code> ：</p>
<pre><code>+ (instancetype)cellWithMessage:(HBTalkData *)message previousMessage:(HBTalkData *)previousMessage inTableView:(<span class="built_in">UITableView</span> *)tableView previewMode:(<span class="built_in">BOOL</span>)previewMode {
    Class cellClass = <span class="literal">nil</span>;
    <span class="keyword">switch</span> (message<span class="variable">.contentType</span>) {
        <span class="keyword">case</span> HBTalkDataContentTypeText:
            cellClass = (message<span class="variable">.fromSelf</span>)?[HBTalkTableViewTextRightCell class]:[HBTalkTableViewTextLeftCell class];
            <span class="keyword">break</span>;
        ...
    }

    <span class="built_in">NSString</span> *cellIdentifier = <span class="built_in">NSStringFromClass</span>(cellClass);
    HBTalkTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier];
    <span class="keyword">if</span> (cell == <span class="literal">nil</span>) {
        cell = [[cellClass alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span> reuseIdentifier:cellIdentifier previewMode:previewMode];
    }
    cell<span class="variable">.previousMessage</span> = previousMessage;
    cell<span class="variable">.message</span> = message;
    [cell updateViews];
    <span class="keyword">return</span> cell;
}
</code></pre><p>然后有 <code>HBTalkTableViewLeftCell</code> 和 <code>HBTalkTableViewRightCell</code> 继承这个基类，用于定制左右两边的气泡，然后各个子类再分别继承上面的两个 <code>Cell</code> ，实现 <code>updateViews</code> 方法，完成不同类型的内容加载。</p>
<p>大概的结构是这样的：</p>
<p><img src="http://callmewhy.qiniudn.com/QQ20150302-3.png" alt=""></p>
<p>也就是说，每当需要增加一种新类型的 <code>Cell</code> 的时候，比如我要加个发红包的 <code>Cell</code> ，那我要写两个类：<code>HBTalkTableViewMoneyRightCell</code> 和 <code>HBTalkTableViewMoneyLeftCell</code> ，分别继承自 <code>LeftCell</code> 和 <code>RightCell</code>。</p>
<p>看了一下现有类的实现，比如 <code>HBTalkTableViewTextLeftCell</code> 和 <code>HBTalkTableViewTextRightCell</code> ，除掉业务部分的代码，里面的属性、方法基本完全相同，唯一不同的就是气泡和消息内容的位置，存在大量重复代码。</p>
<h3 id="JSQ-1">JSQ</h3><p>再看下 <code>JSQ</code> 的源码，由于它的会话页是通过 <code>UICollectionView</code> 实现的，所以它的基类是继承了 <code>UICollectionViewCell</code> 的 <code>JSQMessagesCollectionViewCell</code> 。</p>
<p>对于左右气泡的问题， <code>JSQ</code> 和 <code>HB</code> 处理基本相同，都是分别建了 <code>JSQMessagesCollectionViewCellIncoming</code> 和 <code>JSQMessagesCollectionViewCellOutgoing</code> 这两个子类。 <code>JSQ</code> 是在 <code>xib</code> 里面设置不同的布局：</p>
<p><img src="http://callmewhy.qiniudn.com/QQ20150302-4.png" alt=""></p>
<p>但是对于具体功能的 <code>Cell</code> ， <code>JSQ</code> 的实现方法和 <code>HB</code> 大相径庭。<code>JSQ</code> 只有 <code>JSQMessagesCollectionViewCellIncoming</code> 和 <code>JSQMessagesCollectionViewCellOutgoing</code> 这两个子类，具体业务的实现是这样做的：</p>
<ul>
<li>如果是文本消息，则显示在 <code>textView</code> 上</li>
<li>如果是多媒体消息，则显示在 <code>mediaView</code> 上</li>
</ul>
<p>然后在 <code>collectionView:cellForItemAtIndexPath:</code> 这个方法里，对数据源类型进行判断。如果是多媒体资源 (对应协议 <code>JSQMessageMediaData</code> ) ，则把多媒体资源的 <code>mediaView</code> 赋给 <code>cell</code> 的 <code>mediaView</code> ：</p>
<pre><code><span class="comment">// 如果是文字消息</span>
<span class="keyword">if</span> (!isMediaMessage) {
    cell.textView.<span class="keyword">text</span> = [messageItem <span class="keyword">text</span>];
    ...
}

<span class="comment">// 如果是多媒体消息</span>
<span class="keyword">else</span> {
    id&lt;JSQMessageMediaData&gt; messageMedia = [messageItem media];
    cell.mediaView = [messageMedia mediaView] ?: [messageMedia mediaPlaceholderView];
}
</code></pre><p>再看一下 <code>JSQMessageMediaData</code> 这个多媒体资源的协议：</p>
<pre><code>@protocol JSQMessageMediaData &lt;NSObject&gt;

@required
-<span class="ruby"> (<span class="constant">UIView</span> *)mediaView;
</span>-<span class="ruby"> (<span class="constant">CGSize</span>)mediaViewDisplaySize;
</span>-<span class="ruby"> (<span class="constant">UIView</span> *)mediaPlaceholderView;
</span>-<span class="ruby"> (<span class="constant">NSUInteger</span>)hash;
</span>
@end
</code></pre><p>有了这些关键数据， <code>UICollectionView</code> 就知道应该如何正确的显示多媒体资源了。</p>
<p>在 <code>JSQ</code> 里提供了一个实现了 <code>JSQMessageMediaData</code> 协议的类： <code>JSQMediaItem</code> 。所有的多媒体资源类，例如图片 (<code>JSQPhotoMediaItem</code>) 、视屏 (<code>JSQVideoMediaItem</code>) 等等，都是继承自 <code>JSQMediaItem</code> 。如果要加新类型的多媒体消息，只需要自定义一个继承了 <code>JSQMediaItem</code> 的子类就可以了。</p>
<p>嗯拖拖拽拽个关系图是这样的：</p>
<p><img src="http://callmewhy.qiniudn.com/QQ20150302-7.png" alt=""></p>
<p>我们以 <code>JSQPhotoMediaItem</code> 为例，看下图片消息的 <code>mediaView</code> ：</p>
<pre><code>...

<span class="preprocessor">#pragma mark - JSQMessageMediaData protocol</span>

- (<span class="built_in">UIView</span> *)mediaView
{
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.image</span> == <span class="literal">nil</span>) {
        <span class="keyword">return</span> <span class="literal">nil</span>;
    }

    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.cachedImageView</span> == <span class="literal">nil</span>) {
        <span class="built_in">CGSize</span> size = [<span class="keyword">self</span> mediaViewDisplaySize];
        <span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] initWithImage:<span class="keyword">self</span><span class="variable">.image</span>];
        imageView<span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="number">0.0</span>f, <span class="number">0.0</span>f, size<span class="variable">.width</span>, size<span class="variable">.height</span>);
        imageView<span class="variable">.contentMode</span> = <span class="built_in">UIViewContentModeScaleAspectFill</span>;
        imageView<span class="variable">.clipsToBounds</span> = <span class="literal">YES</span>;
        [JSQMessagesMediaViewBubbleImageMasker applyBubbleImageMaskToMediaView:imageView isOutgoing:<span class="keyword">self</span><span class="variable">.appliesMediaViewMaskAsOutgoing</span>];
        <span class="keyword">self</span><span class="variable">.cachedImageView</span> = imageView;
    }

    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.cachedImageView</span>;
}
</code></pre><h2 id="Round_3_-_Layout">Round 3 - Layout</h2><h3 id="HB-2">HB</h3><p><code>HB</code> 是基于 <code>UITableView</code> 实现的，消息时间、气泡图片都是 <code>Cell</code> 的 <code>subview</code> 。实现自适应高度 <code>Cell</code> 的方法比较淳朴，它有个静态方法计算 `Cell 的高度：</p>
<pre><code>+ (float)getHeightByContent:(<span class="type">HBTalkData</span>*)<span class="typedef"><span class="keyword">data</span> preData:<span class="container">(<span class="type">HBTalkData</span> *)</span>preData <span class="container">{

    <span class="title">if</span> (<span class="title">data</span>.<span class="title">contentType</span> == <span class="type">HBTalkDataContentTypeImage</span>) {
        ...
    }</span></span>
    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="typedef"><span class="keyword">data</span>.contentType == <span class="type">HBTalkDataContentTypeCall</span>) <span class="container">{
        ...
    }</span></span>
    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="typedef"><span class="keyword">data</span>.contentType == <span class="type">HBTalkDataContentTypeBubbleReply</span>) <span class="container">{
        <span class="title">return</span> 105 + <span class="title">height</span>;
    }</span></span>
    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="typedef"><span class="keyword">data</span>.contentType == <span class="type">HBTalkDataContentTypeVideo</span>) <span class="container">{
        <span class="title">return</span> 120+60;
    }</span></span>
    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="typedef"><span class="keyword">data</span>.contentType == <span class="type">HBTalkDataContentTypeVoice</span>) <span class="container">{
        <span class="title">return</span> 42.0<span class="title">f</span> + <span class="title">height</span>;
    }</span></span>
    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="typedef"><span class="keyword">data</span>.contentType == <span class="type">HBTalkDataContentTypePoke</span>) <span class="container">{
        ...
        <span class="title">return</span> <span class="title">height</span>;
    }</span></span>
    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="typedef"><span class="keyword">data</span>.contentType == <span class="type">HBTalkDataContentTypeGame</span>) <span class="container">{
        ...
        <span class="title">return</span> <span class="title">height</span>;
    }</span></span>
    <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="typedef"><span class="keyword">data</span>.contents isKindOfClass:[<span class="type">NSString</span> class]]) <span class="container">{
        <span class="title">if</span> (<span class="title">data</span>.<span class="title">contentType</span> == <span class="type">HBTalkDataContentTypeSys</span>) {
            <span class="title">return</span> 40 + <span class="title">height</span>;
        }</span></span>
        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="typedef"><span class="keyword">data</span>.contentType == <span class="type">HBTalkDataContentTypeGif</span>) <span class="container">{
            <span class="title">return</span> 130 + <span class="title">height</span>;
        }</span></span>
        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="typedef"><span class="keyword">data</span>.contentType == <span class="type">HBTalkDataContentTypeRegister</span>) <span class="container">{
            ...
            <span class="title">return</span> <span class="type">MAX</span>(<span class="title">size</span>.<span class="title">height</span> + 14.0<span class="title">f</span>, 46.0<span class="title">f</span>) + 20.0<span class="title">f</span> + <span class="title">height</span>;
        }</span></span>

        // 普通文字消息
        <span class="keyword">else</span> {
            ...
            return size.height + <span class="number">20</span> + height;
        }
    }

    return <span class="number">0</span>;
}
</code></pre><p>可以看到各种 <code>Magic Number</code> 乱入，什么 130、105、120、42，就不说什么了。</p>
<p>如果要调整 <code>Cell</code> 的大小，需要先去 <code>Cell</code> 里调一下控件的大小，然后再调整一下这个方法里返回的高度。</p>
<p>然后对于左右气泡，则是在 <code>layoutSubviews</code> 里写的。比如左边气泡距离左边缘 <code>margin</code> 为10：</p>
<pre><code>- (<span class="keyword">void</span>)layoutSubviews {
    [<span class="keyword">super</span> layoutSubviews];
    <span class="built_in">CGRect</span> frame= <span class="keyword">self</span><span class="variable">.backgroundImageView</span><span class="variable">.frame</span>;
    frame<span class="variable">.origin</span><span class="variable">.x</span> = <span class="number">10.0</span>f;
    <span class="keyword">self</span><span class="variable">.backgroundImageView</span><span class="variable">.frame</span> = frame;
}
</code></pre><h3 id="JSQ-2">JSQ</h3><p><code>JSQ</code> 是基于 <code>UICollectionView</code> 开发的，布局任务基本全交给了 <code>JSQMessagesCollectionViewFlowLayout</code> 这个自定义的 <code>UICollectionViewFlowLayout</code> 来做，然后把布局细节通过委托方法暴露给外面。比如通过 <code>heightForCellTopLabelAtIndexPath</code> 设置时间戳的高度，如果我们希望每隔三条消息就显示一次时间戳，可以这样做：</p>
<pre><code>- (CGFloat)collectionView:(JSQMessagesCollectionView *)collectionView layout:(JSQMessagesCollectionViewFlowLayout *)collectionViewLayout heightForCellTopLabelAtIndexPath:(NSIndexPath *)indexPath {
    <span class="keyword">if</span> (indexPath.item % <span class="number">3</span> == <span class="number">0</span>) {
        <span class="keyword">return</span> kJSQMessagesCollectionViewCellLabelHeightDefault;
    }
    <span class="keyword">return</span> <span class="number">0.0f</span>;
}
</code></pre><p>至于每个 <code>Cell</code> 的高度，则是通过 <code>sizeForItemAtIndexPath</code> 方法计算的：</p>
<pre><code>- (<span class="built_in">CGSize</span>)sizeForItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath {
    <span class="built_in">CGSize</span> messageBubbleSize = [<span class="keyword">self</span> messageBubbleSizeForItemAtIndexPath:indexPath];
    JSQMessagesCollectionViewLayoutAttributes *attributes = (JSQMessagesCollectionViewLayoutAttributes *)[<span class="keyword">self</span> layoutAttributesForItemAtIndexPath:indexPath];

    <span class="built_in">CGFloat</span> finalHeight = messageBubbleSize<span class="variable">.height</span>;
    finalHeight += attributes<span class="variable">.cellTopLabelHeight</span>;
    finalHeight += attributes<span class="variable">.messageBubbleTopLabelHeight</span>;
    finalHeight += attributes<span class="variable">.cellBottomLabelHeight</span>;

    <span class="keyword">return</span> <span class="built_in">CGSizeMake</span>(<span class="keyword">self</span><span class="variable">.itemWidth</span>, ceilf(finalHeight));
}
</code></pre><p>先获取单个单元格的尺寸，然后加上时间戳的高度、加上用户昵称的高度、加上底部文字的高度，得出最终的尺寸。</p>
<h2 id="小结">小结</h2><p>相比较而言， <code>HB</code> 虽然勉强实现了会话页面，但是维护成本较高，可扩展性不强，相比较而言 <code>JSQ</code> 的源码要优秀很多。<a href="https://github.com/jessesquires/JSQMessagesViewController" target="_blank" rel="external">源码</a> 中还有很多值得学习的地方，大家可以继续深入阅读。</p>
<p>去接女朋友了。噢耶。</p>
]]></content>
    <summary type="html">
    <![CDATA[同志，聊天页面你要是再这么写我就要报警了]]>
    
    </summary>
    
      <category term="ChatView" scheme="http://blog.callmewhy.com/tags/ChatView/"/>
    
      <category term="开发笔记" scheme="http://blog.callmewhy.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 中的设计模式 (Swift版本) Part 2]]></title>
    <link href="http://blog.callmewhy.com/2015/03/01/introducing-ios-design-patterns-in-swift-part-2/"/>
    <id>http://blog.callmewhy.com/2015/03/01/introducing-ios-design-patterns-in-swift-part-2/</id>
    <published>2015-03-01T04:59:22.000Z</published>
    <updated>2015-04-25T10:03:34.000Z</updated>
    <content type="html"><![CDATA[<h2 id="更新声明">更新声明</h2><p>翻译自 <a href="http://www.raywenderlich.com/90773/introducing-ios-design-patterns-in-swift-part-2" target="_blank" rel="external">Introducing iOS Design Patterns in Swift – Part 2/2</a> ，本教程 <a href="http://www.raywenderlich.com/46988/ios-design-patterns" target="_blank" rel="external">objc</a> 版本的作者是 Eli Ganem ，由 Vincent Ngo 更新为 Swift 版本。</p>
<h2 id="再续前缘">再续前缘</h2><p>欢迎来到教程的第二部分！这是本系列教程的最后一部分，在这一章的学习里，我们会更加深入的学习一些 iOS 开发中常见的设计模式：适配器模式 (Adapter)，观察者模式 (Observer)，备忘录模式 (Memento)。</p>
<p>开始吧少年们！</p>
<h2 id="准备工作">准备工作</h2><p>你可以先下载上一章结束时的<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2014/11/BlueLibrarySwift-Part1.zip" target="_blank" rel="external">项目源码</a> 。</p>
<p>在第一部分的教程里，我们完成了这样一个简单的应用：</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/11/Screen-Shot-2014-11-11-at-12.38.53-AM-179x320.png" alt=""></p>
<p>我们的原计划是在上面的空白处放一个可以横滑浏览专辑的视图。其实仔细想想，这个控件是可以应用在其他地方的，我们不妨把它做成一个可复用的视图。</p>
<p>为了让这个视图可以复用，显示内容的工作都只能交给另一个对象来完成：它的委托。这个横滑页面应该声明一些方法让它的委托去实现，就像是 <code>UITableView</code> 的 <code>UITableViewDelegate</code> 一样。我们将会在下一个设计模式中实现这个功能。</p>
<h2 id="适配器模式_-_Adapter">适配器模式 - Adapter</h2><p>适配器把自己封装起来然后暴露统一的接口给其他类，这样即使其他类的接口各不相同，也能相安无事，一起工作。</p>
<p>如果你熟悉适配器模式，那么你会发现苹果在实现适配器模式的方式稍有不同：苹果通过委托实现了适配器模式。委托相信大家都不陌生。举个例子，如果一个类遵循了 <code>NSCoying</code> 的协议，那么它一定要实现 <code>copy</code> 方法。</p>
<h3 id="如何使用适配器模式">如何使用适配器模式</h3><p>横滑的滚动栏理论上应该是这个样子的：</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/11/swiftDesignPattern7.png" alt=""></p>
<p>新建一个 Swift 文件：<code>HorizontalScroller.swift</code> ，作为我们的横滑滚动控件， <code>HorizontalScroller</code> 继承自 <code>UIView</code> 。</p>
<p>打开 <code>HorizontalScroller.swift</code> 文件并添加如下代码：</p>
<pre><code><span class="preprocessor">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">HorizontalScrollerDelegate</span> </span>{
}
</code></pre><p>这行代码定义了一个新的协议： <code>HorizontalScrollerDelegate</code> 。我们在前面加上了 <code>@objc</code> 的标记，这样我们就可以像在 objc 里一样使用 <code>@optional</code> 的委托方法了。</p>
<p>接下来我们在大括号里定义所有的委托方法，包括必须的和可选的：</p>
<pre><code><span class="comment">// 在横滑视图中有多少页面需要展示</span>
<span class="func"><span class="keyword">func</span> <span class="title">numberOfViewsForHorizontalScroller</span><span class="params">(scroller: HorizontalScroller)</span></span> -&gt; <span class="type">Int</span>
<span class="comment">// 展示在第 index 位置显示的 UIView</span>
<span class="func"><span class="keyword">func</span> <span class="title">horizontalScrollerViewAtIndex</span><span class="params">(scroller: HorizontalScroller, index:Int)</span></span> -&gt; <span class="type">UIView</span>
<span class="comment">// 通知委托第 index 个视图被点击了</span>
<span class="func"><span class="keyword">func</span> <span class="title">horizontalScrollerClickedViewAtIndex</span><span class="params">(scroller: HorizontalScroller, index:Int)</span></span>
<span class="comment">// 可选方法，返回初始化时显示的图片下标，默认是0</span>
<span class="keyword">optional</span> <span class="func"><span class="keyword">func</span> <span class="title">initialViewIndex</span><span class="params">(scroller: HorizontalScroller)</span></span> -&gt; <span class="type">Int</span>
</code></pre><p>其中，没有 <code>option</code> 标记的方法是必须实现的，一般来说包括那些用来显示的必须数据，比如如何展示数据，有多少数据需要展示，点击事件如何处理等等，不可或缺；有 <code>option</code> 标记的方法为可选实现的，相当于是一些辅助设置和功能，就算没有实现也有默认值进行处理。</p>
<p>在 <code>HorizontalScroller</code> 类里添加一个新的委托对象：</p>
<pre><code><span class="keyword">weak</span> <span class="keyword">var</span> <span class="keyword">delegate</span>: HorizontalScrollerDelegate?
</code></pre><p>为了避免循环引用的问题，委托是 <code>weak</code> 类型。如果委托是 <code>strong</code> 类型的，当前对象持有了委托的强引用，委托又持有了当前对象的强引用，这样谁都无法释放就会导致内存泄露。</p>
<p>委托是可选类型，所以很有可能当前类的使用者并没有指定委托。但是如果指定了委托，那么它一定会遵循 <code>HorizontalScrollerDelegate</code> 里约定的内容。</p>
<p>再添加一些新的属性：</p>
<pre><code><span class="comment">// 1</span>
<span class="keyword">private</span> <span class="keyword">let</span> VIEW_PADDING = <span class="number">10</span>
<span class="keyword">private</span> <span class="keyword">let</span> VIEW_DIMENSIONS = <span class="number">100</span>
<span class="keyword">private</span> <span class="keyword">let</span> VIEWS_OFFSET = <span class="number">100</span>

<span class="comment">// 2</span>
<span class="keyword">private</span> <span class="keyword">var</span> scroller : UIScrollView!
<span class="comment">// 3</span>
<span class="keyword">var</span> viewArray = [UIView]()
</code></pre><p>上面标注的三点分别做了这些事情：</p>
<ul>
<li>定义一个常量，用来方便的改变布局。现在默认的是显示的内容长宽为100，间隔为10。</li>
<li>创建一个 <code>UIScrollView</code> 作为容器。</li>
<li>创建一个数组用来存放需要展示的数据</li>
</ul>
<p>接下来实现初始化方法：</p>
<pre><code>override init(<span class="string">frame:</span> CGRect) {
    <span class="keyword">super</span>.init(<span class="string">frame:</span> frame)
    initializeScrollView()
}

required init(coder <span class="string">aDecoder:</span> NSCoder) {
    <span class="keyword">super</span>.init(<span class="string">coder:</span> aDecoder)
    initializeScrollView()
}

func initializeScrollView() {
    <span class="comment">//1</span>
    scroller = UIScrollView()
    addSubview(scroller)

    <span class="comment">//2</span>
    scroller.setTranslatesAutoresizingMaskIntoConstraints(<span class="literal">false</span>)
    <span class="comment">//3</span>
    self.addConstraint(NSLayoutConstraint(<span class="string">item:</span> scroller, <span class="string">attribute:</span> .Leading, <span class="string">relatedBy:</span> .Equal, <span class="string">toItem:</span> self, <span class="string">attribute:</span> .Leading, <span class="string">multiplier:</span> <span class="number">1.0</span>, <span class="string">constant:</span> <span class="number">0.0</span>))
    self.addConstraint(NSLayoutConstraint(<span class="string">item:</span> scroller, <span class="string">attribute:</span> .Trailing, <span class="string">relatedBy:</span> .Equal, <span class="string">toItem:</span> self, <span class="string">attribute:</span> .Trailing, <span class="string">multiplier:</span> <span class="number">1.0</span>, <span class="string">constant:</span> <span class="number">0.0</span>))
    self.addConstraint(NSLayoutConstraint(<span class="string">item:</span> scroller, <span class="string">attribute:</span> .Top, <span class="string">relatedBy:</span> .Equal, <span class="string">toItem:</span> self, <span class="string">attribute:</span> .Top, <span class="string">multiplier:</span> <span class="number">1.0</span>, <span class="string">constant:</span> <span class="number">0.0</span>))
    self.addConstraint(NSLayoutConstraint(<span class="string">item:</span> scroller, <span class="string">attribute:</span> .Bottom, <span class="string">relatedBy:</span> .Equal, <span class="string">toItem:</span> self, <span class="string">attribute:</span> .Bottom, <span class="string">multiplier:</span> <span class="number">1.0</span>, <span class="string">constant:</span> <span class="number">0.0</span>))

    <span class="comment">//4</span>
    let tapRecognizer = UITapGestureRecognizer(<span class="string">target:</span> self, <span class="string">action:</span>Selector(<span class="string">"scrollerTapped:"</span>))
    scroller.addGestureRecognizer(tapRecognizer)
}
</code></pre><p>上面的代码做了如下工作：</p>
<ul>
<li>创建一个 <code>UIScrollView</code> 对象并且把它加到父视图中。</li>
<li>关闭 <code>autoresizing masks</code> ，从而可以使用 <code>AutoLayout</code> 进行布局。</li>
<li>给 <code>scrollview</code> 添加约束。我们希望 <code>scrollview</code> 能填满 <code>HorizontalScroller</code> 。</li>
<li>创建一个点击事件，检测是否点击到了专辑封面，如果确实点击到了专辑封面，我们需要通知 <code>HorizontalScroller</code> 的委托。</li>
</ul>
<p>添加委托方法：</p>
<pre><code><span class="func"><span class="keyword">func</span> <span class="title">scrollerTapped</span><span class="params">(gesture: UITapGestureRecognizer)</span></span> {
  <span class="keyword">let</span> location = gesture.locationInView(gesture.view)
  <span class="keyword">if</span> <span class="keyword">let</span> delegate = <span class="keyword">self</span>.delegate {
    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span>..&lt;delegate.numberOfViewsForHorizontalScroller(<span class="keyword">self</span>) {
      <span class="keyword">let</span> view = scroller.subviews[index] <span class="keyword">as</span> <span class="type">UIView</span>
      <span class="keyword">if</span> <span class="type">CGRectContainsPoint</span>(view.frame, location) {
        delegate.horizontalScrollerClickedViewAtIndex(<span class="keyword">self</span>, index: index)
        scroller.setContentOffset(<span class="type">CGPointMake</span>(view.frame.origin.x - <span class="keyword">self</span>.frame.size.width/<span class="number">2</span> + view.frame.size.width/<span class="number">2</span>, <span class="number">0</span>), animated:<span class="literal">true</span>)
        <span class="keyword">break</span>
      }
    }
  }
}
</code></pre><p>我们把 <code>gesture</code> 作为一个参数传了进来，这样就可以获取点击的具体坐标了。</p>
<p>接下来我们调用了 <code>numberOfViewsForHorizontalScroller</code> 方法，<code>HorizontalScroller</code> 不知道自己的 <code>delegate</code> 具体是谁，但是知道它一定实现了 <code>HorizontalScrollerDelegate</code> 协议，所以可以放心的调用。</p>
<p>对于 <code>scroll view</code> 中的 <code>view</code> ，通过 <code>CGRectContainsPoint</code> 进行点击检测，从而获知是哪一个 <code>view</code> 被点击了。当找到了点击的 <code>view</code> 的时候，则会调用委托方法里的 <code>horizontalScrollerClickedViewAtIndex</code> 方法通知委托。在跳出 <code>for</code> 循环之前，先把点击到的 <code>view</code> 居中。</p>
<p>接下来我们再加个方法获取数组里的 <code>view</code> ：</p>
<pre><code><span class="func"><span class="keyword">func</span> <span class="title">viewAtIndex</span><span class="params">(index :Int)</span></span> -&gt; <span class="type">UIView</span> {
  <span class="keyword">return</span> viewArray[index]
} 
</code></pre><p>这个方法很简单，只是用来更方便获取数组里的 <code>view</code> 而已。在后面实现高亮选中专辑的时候会用到这个方法。</p>
<p>添加如下代码用来重新加载 <code>scroller</code> ：</p>
<pre><code>func reload() {
  <span class="comment">// 1 - Check if there is a delegate, if not there is nothing to load.</span>
  <span class="keyword">if</span> let delegate = <span class="keyword">self</span><span class="variable">.delegate</span> {
    <span class="comment">//2 - Will keep adding new album views on reload, need to reset.</span>
    viewArray = []
    let views: <span class="built_in">NSArray</span> = scroller<span class="variable">.subviews</span>

    <span class="comment">// 3 - remove all subviews</span>
    views<span class="variable">.enumerateObjectsUsingBlock</span> {
    (object: AnyObject!, idx: Int, stop: UnsafeMutablePointer&lt;ObjCBool&gt;) -&gt; Void <span class="keyword">in</span>
      object<span class="variable">.removeFromSuperview</span>()
    }
    <span class="comment">// 4 - xValue is the starting point of the views inside the scroller            </span>
    var xValue = VIEWS_OFFSET
    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0.</span>.&lt;delegate<span class="variable">.numberOfViewsForHorizontalScroller</span>(<span class="keyword">self</span>) {
      <span class="comment">// 5 - add a view at the right position</span>
      xValue += VIEW_PADDING
      let view = delegate<span class="variable">.horizontalScrollerViewAtIndex</span>(<span class="keyword">self</span>, index: index)
      view<span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="built_in">CGFloat</span>(xValue), <span class="built_in">CGFloat</span>(VIEW_PADDING), <span class="built_in">CGFloat</span>(VIEW_DIME<span class="built_in">NSIONS</span>), <span class="built_in">CGFloat</span>(VIEW_DIME<span class="built_in">NSIONS</span>))
      scroller<span class="variable">.addSubview</span>(view)
      xValue += VIEW_DIME<span class="built_in">NSIONS</span> + VIEW_PADDING
      <span class="comment">// 6 - Store the view so we can reference it later</span>
     viewArray<span class="variable">.append</span>(view)
    }
    <span class="comment">// 7</span>
    scroller<span class="variable">.contentSize</span> = <span class="built_in">CGSizeMake</span>(<span class="built_in">CGFloat</span>(xValue + VIEWS_OFFSET), frame<span class="variable">.size</span><span class="variable">.height</span>)

    <span class="comment">// 8 - If an initial view is defined, center the scroller on it</span>
    <span class="keyword">if</span> let initialView = delegate<span class="variable">.initialViewIndex</span>?(<span class="keyword">self</span>) {
      scroller<span class="variable">.setContentOffset</span>(<span class="built_in">CGPointMake</span>(<span class="built_in">CGFloat</span>(initialView)*<span class="built_in">CGFloat</span>((VIEW_DIME<span class="built_in">NSIONS</span> + (<span class="number">2</span> * VIEW_PADDING))), <span class="number">0</span>), animated: <span class="literal">true</span>)
    }
  }
}
</code></pre><p>这个 <code>reload</code> 方法有点像是 <code>UITableView</code> 里面的 <code>reloadData</code> 方法，它会重新加载所有数据。</p>
<p>一段一段的看下上面的代码：</p>
<ul>
<li>在调用 <code>reload</code> 之前，先检查一下是否有委托。</li>
<li>既然要清除专辑封面，那么也需要重新设置 <code>viewArray</code> ，要不然以前的数据会累加进来。</li>
<li>移除先前加入到 <code>scrollview</code> 的子视图。</li>
<li>所有的 <code>view</code> 都有一个偏移量，目前默认是100，我们可以修改 <code>VIEW_OFFSET</code> 这个常量轻松的修改它。</li>
<li><code>HorizontalScroller</code> 通过委托获取对应位置的 <code>view</code> 并且把它们放在对应的位置上。</li>
<li>把 <code>view</code> 存进 <code>viewArray</code> 以便后面的操作。</li>
<li>当所有 <code>view</code> 都安放好了，再设置一下 <code>content size</code> 这样才可以进行滑动。</li>
<li><code>HorizontalScroller</code> 检查一下委托是否实现了 <code>initialViewIndex()</code> 这个可选方法，这种检查十分必要，因为这个委托方法是可选的，如果委托没有实现这个方法则用0作为默认值。最终设置 <code>scroll view</code> 将初始的 <code>view</code> 放置到居中的位置。</li>
</ul>
<p>当数据发生改变的时候，我们需要调用 <code>reload</code> 方法。当 <code>HorizontalScroller</code> 被加到其他页面的时候也需要调用这个方法，我们在 <code>HorizontalScroller.swift</code> 里面加入如下代码：</p>
<pre><code><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">didMoveToSuperview</span><span class="params">()</span></span> {
    reload()
}
</code></pre><p>在当前 <code>view</code> 添加到其他 <code>view</code> 里的时候就会自动调用 <code>didMoveToSuperview</code> 方法，这样可以在正确的时间重新加载数据。</p>
<p><code>HorizontalScroller</code> 的最后一部分是用来确保当前浏览的内容时刻位于正中心的位置，为了实现这个功能我们需要在用户滑动结束的时候做一些额外的计算和修正。</p>
<p>添加下面这个方法：</p>
<pre><code>func centerCurrentView() {
    var xFinal = scroller<span class="variable">.contentOffset</span><span class="variable">.x</span> + <span class="built_in">CGFloat</span>((VIEWS_OFFSET/<span class="number">2</span>) + VIEW_PADDING)
    let viewIndex = xFinal / <span class="built_in">CGFloat</span>((VIEW_DIME<span class="built_in">NSIONS</span> + (<span class="number">2</span>*VIEW_PADDING)))
    xFinal = viewIndex * <span class="built_in">CGFloat</span>(VIEW_DIME<span class="built_in">NSIONS</span> + (<span class="number">2</span>*VIEW_PADDING))
    scroller<span class="variable">.setContentOffset</span>(<span class="built_in">CGPointMake</span>(xFinal, <span class="number">0</span>), animated: <span class="literal">true</span>)
    <span class="keyword">if</span> let delegate = <span class="keyword">self</span><span class="variable">.delegate</span> {
        delegate<span class="variable">.horizontalScrollerClickedViewAtIndex</span>(<span class="keyword">self</span>, index: Int(viewIndex))
    }  
}
</code></pre><p>上面的代码计算了当前视图里中心位置距离多少，然后算出正确的居中坐标并滑动到那个位置。最后一行是通知委托所选视图已经发生了改变。</p>
<p>为了检测到用户滑动的结束时间，我们还需要实现 <code>UIScrollViewDelegate</code> 的方法。在文件结尾加上下面这个扩展：</p>
<pre><code><span class="class"><span class="keyword">extension</span> <span class="title">HorizontalScroller</span>: <span class="title">UIScrollViewDelegate</span> </span>{
    <span class="func"><span class="keyword">func</span> <span class="title">scrollViewDidEndDragging</span><span class="params">(scrollView: UIScrollView, willDecelerate decelerate: Bool)</span></span> {
        <span class="keyword">if</span> !decelerate {
            centerCurrentView()
        }
    }

    <span class="func"><span class="keyword">func</span> <span class="title">scrollViewDidEndDecelerating</span><span class="params">(scrollView: UIScrollView)</span></span> {
        centerCurrentView()
    }
}
</code></pre><p>当用户停止滑动的时候，<code>scrollViewDidEndDragging(_:willDecelerate:)</code> 这个方法会通知委托。如果滑动还没有停止，<code>decelerate</code> 的值为 <code>true</code> 。当滑动完全结束的时候，则会调用 <code>scrollViewDidEndDecelerating</code> 这个方法。在这两种情况下，你都应该把当前的视图居中，因为用户的操作可能会改变当前视图。</p>
<p>你的 <code>HorizontalScroller</code> 已经可以使用了！回头看看前面写的代码，你会看到我们并没有涉及什么 <code>Album</code> 或者 <code>AlbumView</code> 的代码。这是极好的，因为这样意味着这个 <code>scroller</code> 是完全独立的，可以复用。</p>
<p>运行一下你的项目，确保编译通过。</p>
<p>这样，我们的 <code>HorizontalScroller</code> 就完成了，接下来我们就要把它应用到我们的项目里了。首先，打开 <code>Main.Sstoryboard</code> 文件，点击上面的灰色矩形，设置 <code>Class</code> 为 <code>HorizontalScroller</code> ：</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/11/swiftDesignPattwern9-700x414.png" alt=""></p>
<p>接下来，在 <code>assistant editor</code> 模式下向 <code>ViewController.swift</code> 拖拽生成 outlet ，命名为 <code>scroller</code> ：</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/11/swiftDesignPattern10-700x411.png" alt=""></p>
<p>接下来打开 <code>ViewController.swift</code> 文件，是时候实现 <code>HorizontalScrollerDelegate</code> 委托里的方法啦！</p>
<p>添加如下扩展：</p>
<pre><code><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">HorizontalScrollerDelegate</span> </span>{
    <span class="func"><span class="keyword">func</span> <span class="title">horizontalScrollerClickedViewAtIndex</span><span class="params">(scroller: HorizontalScroller, index: Int)</span></span> {
        <span class="comment">//1</span>
        <span class="keyword">let</span> previousAlbumView = scroller.viewAtIndex(currentAlbumIndex) <span class="keyword">as</span> <span class="type">AlbumView</span>
        previousAlbumView.highlightAlbum(didHighlightView: <span class="literal">false</span>)
        <span class="comment">//2</span>
        currentAlbumIndex = index
        <span class="comment">//3</span>
        <span class="keyword">let</span> albumView = scroller.viewAtIndex(index) <span class="keyword">as</span> <span class="type">AlbumView</span>
        albumView.highlightAlbum(didHighlightView: <span class="literal">true</span>)
        <span class="comment">//4</span>
        showDataForAlbum(index)
    }
}
</code></pre><p>让我们一行一行的看下这个委托的实现：</p>
<ul>
<li>获取上一个选中的相册，然后取消高亮</li>
<li>存储当前点击的相册封面</li>
<li>获取当前选中的相册，设置为高亮</li>
<li>在 <code>table view</code> 里面展示新数据</li>
</ul>
<p>接下来在扩展里添加如下方法：</p>
<pre><code><span class="func"><span class="keyword">func</span> <span class="title">numberOfViewsForHorizontalScroller</span><span class="params">(scroller: HorizontalScroller)</span></span> -&gt; (<span class="type">Int</span>) {
    <span class="keyword">return</span> allAlbums.<span class="built_in">count</span>
}
</code></pre><p>这个委托方法返回 <code>scroll vew</code> 里面的视图数量，因为是用来展示所有的专辑的封面，所以数目也就是专辑数目。</p>
<p>然后添加如下代码：</p>
<pre><code><span class="func"><span class="keyword">func</span> <span class="title">horizontalScrollerViewAtIndex</span><span class="params">(scroller: HorizontalScroller, index: Int)</span></span> -&gt; (<span class="type">UIView</span>) {
    <span class="keyword">let</span> album = allAlbums[index]
    <span class="keyword">let</span> albumView = <span class="type">AlbumView</span>(frame: <span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>), albumCover: album.coverUrl)
    <span class="keyword">if</span> currentAlbumIndex == index {
        albumView.highlightAlbum(didHighlightView: <span class="literal">true</span>)
    } <span class="keyword">else</span> {
        albumView.highlightAlbum(didHighlightView: <span class="literal">false</span>)
    }
    <span class="keyword">return</span> albumView
}
</code></pre><p>我们创建了一个新的 <code>AlbumView</code> ，然后检查一下是不是当前选中的专辑，如果是则设为高亮，最后返回结果。</p>
<p>是的就是这么简单！三个方法，完成了一个横向滚动的浏览视图。</p>
<p>我们还需要创建这个滚动视图并把它加到主视图里，但是在这之前，先添加如下方法：</p>
<pre><code><span class="func"><span class="keyword">func</span> <span class="title">reloadScroller</span><span class="params">()</span></span> {
    allAlbums = <span class="type">LibraryAPI</span>.sharedInstance.getAlbums()
    <span class="keyword">if</span> currentAlbumIndex &lt; <span class="number">0</span> {
        currentAlbumIndex = <span class="number">0</span>
    } <span class="keyword">else</span> <span class="keyword">if</span> currentAlbumIndex &gt;= allAlbums.<span class="built_in">count</span> {
        currentAlbumIndex = allAlbums.<span class="built_in">count</span> - <span class="number">1</span>
    } 
    scroller.reload() 
    showDataForAlbum(currentAlbumIndex)
}
</code></pre><p>这个方法通过 <code>LibraryAPI</code> 加载专辑数据，然后根据 <code>currentAlbumIndex</code> 的值设置当前视图。在设置之前先进行了校正，如果小于0则设置第一个专辑为展示的视图，如果超出了范围则设置最后一个专辑为展示的视图。</p>
<p>接下来只需要指定委托就可以了，在 <code>viewDidLoad</code> 最后加入一下代码：</p>
<pre><code>scroller<span class="class">.delegate</span> = self
<span class="function"><span class="title">reloadScroller</span><span class="params">()</span></span>
</code></pre><p>因为 <code>HorizontalScroller</code> 是在 <code>StoryBoard</code> 里初始化的，所以我们需要做的只是指定委托，然后调用 <code>reloadScroller()</code> 方法，从而加载所有的子视图并且展示专辑数据。</p>
<p>标注：如果协议里的方法过多，可以考虑把它分解成几个更小的协议。<code>UITableViewDelegate</code> 和 <code>UITableViewDataSource</code> 就是很好的例子，它们都是 <code>UITableView</code> 的协议。尝试去设计你自己的协议，让每个协议都单独负责一部分功能。</p>
<p>运行一下当前项目，看一下我们的新页面：</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/11/swiftDesignPattern12-288x320.png" alt=""></p>
<p>等下，滚动视图显示出来了，但是专辑的封面怎么不见了？</p>
<p>啊哈，是的。我们还没完成下载部分的代码，我们需要添加下载图片的方法。因为我们所有的访问都是通过 <code>LibraryAPI</code> 实现的，所以很显然我们下一步应该去完善这个类了。不过在这之前，我们还需要考虑一些问题：</p>
<ul>
<li><code>AlbumView</code> 不应该直接和 <code>LibraryAPI</code> 交互，我们不应该把视图的逻辑和业务逻辑混在一起。</li>
<li>同样， <code>LibraryAPI</code> 也不应该知道 <code>AlbumView</code> 这个类。</li>
<li>如果 <code>AlbumView</code> 要展示封面，<code>LibraryAPI</code> 需要告诉 <code>AlbumView</code> 图片下载完成。</li>
</ul>
<p>看起来好像很难的样子？别绝望，接下来我们会用观察者模式 (<code>Observer Pattern</code>) 解决这个问题！:]</p>
<h2 id="观察者模式_-_Observer">观察者模式 - Observer</h2><p>在观察者模式里，一个对象在状态变化的时候会通知另一个对象。参与者并不需要知道其他对象的具体是干什么的 - 这是一种降低耦合度的设计。这个设计模式常用于在某个属性改变的时候通知关注该属性的对象。</p>
<p>常见的使用方法是观察者注册监听，然后再状态改变的时候，所有观察者们都会收到通知。</p>
<p>在 MVC 里，观察者模式意味着需要允许 <code>Model</code> 对象和 <code>View</code> 对象进行交流，而不能有直接的关联。</p>
<p><code>Cocoa</code> 使用两种方式实现了观察者模式： <code>Notification</code> 和 <code>Key-Value Observing (KVO)</code>。</p>
<h3 id="通知_-_Notification">通知 - Notification</h3><p>不要把这里的通知和推送通知或者本地通知搞混了，这里的通知是基于订阅-发布模型的，即一个对象 (发布者) 向其他对象 (订阅者) 发送消息。发布者永远不需要知道订阅者的任何数据。</p>
<p><code>Apple</code> 对于通知的使用很频繁，比如当键盘弹出或者收起的时候，系统会分别发送 <code>UIKeyboardWillShowNotification/UIKeyboardWillHideNotification</code> 的通知。当你的应用切到后台的时候，又会发送 <code>UIApplicationDidEnterBackgroundNotification</code> 的通知。</p>
<p>注意：打开 <code>UIApplication.swift</code> 文件，在文件结尾你会看到二十多种系统发送的通知。</p>
<h4 id="如何使用通知">如何使用通知</h4><p>打开 <code>AlbumView.swift</code> 然后在 <code>init</code> 的最后插入如下代码：</p>
<pre><code>NSNotificationCenter.<span class="function"><span class="title">defaultCenter</span><span class="params">()</span></span>.<span class="function"><span class="title">postNotificationName</span><span class="params">(<span class="string">"BLDownloadImageNotification"</span>, object: self, userInfo: [<span class="string">"imageView"</span>:coverImage, <span class="string">"coverUrl"</span> : albumCover])</span></span>
</code></pre><p>这行代码通过 <code>NSNotificationCenter</code> 发送了一个通知，通知信息包含了 <code>UIImageView</code> 和图片的下载地址。这是下载图像需要的所有数据。</p>
<p>然后在 <code>LibraryAPI.swift</code> 的 <code>init</code> 方法的 <code>super.init()</code> 后面加上如下代码：</p>
<pre><code>NSNotificationCenter.<span class="function"><span class="title">defaultCenter</span><span class="params">()</span></span>.<span class="function"><span class="title">addObserver</span><span class="params">(self, selector:<span class="string">"downloadImage:"</span>, name: <span class="string">"BLDownloadImageNotification"</span>, object: nil)</span></span>
</code></pre><p>这是等号的另一边：观察者。每当 <code>AlbumView</code> 发出一个 <code>BLDownloadImageNotification</code> 通知的时候，由于 <code>LibraryAPI</code> 已经注册了成为观察者，所以系统会调用 <code>downloadImage()</code> 方法。</p>
<p>但是，在实现 <code>downloadImage()</code> 之前，我们必须先在 <code>dealloc</code> 里取消监听。如果没有取消监听消息，消息会发送给一个已经销毁的对象，导致程序崩溃。</p>
<p>在 <code>LibaratyAPI.swift</code> 里加上取消订阅的代码：</p>
<pre><code>deinit {
    <span class="built_in">NSNotificationCenter</span><span class="variable">.defaultCenter</span>()<span class="variable">.removeObserver</span>(<span class="keyword">self</span>)
}
</code></pre><p>当对象销毁的时候，把它从所有消息的订阅列表里去除。</p>
<p>这里还要做一件事情：我们最好把图片存储到本地，这样可以避免一次又一次下载相同的封面。</p>
<p>打开 <code>PersistencyManager.swift</code> 添加如下代码：</p>
<pre><code><span class="func"><span class="keyword">func</span> <span class="title">saveImage</span><span class="params">(image: UIImage, filename: String)</span></span> {
    <span class="keyword">let</span> path = <span class="type">NSHomeDirectory</span>().stringByAppendingString(<span class="string">"/Documents/<span class="subst">\(filename)</span>"</span>)
    <span class="keyword">let</span> data = <span class="type">UIImagePNGRepresentation</span>(image)
    data.writeToFile(path, atomically: <span class="literal">true</span>)
}

<span class="func"><span class="keyword">func</span> <span class="title">getImage</span><span class="params">(filename: String)</span></span> -&gt; <span class="type">UIImage</span>? {
    <span class="keyword">var</span> error: <span class="type">NSError</span>?
    <span class="keyword">let</span> path = <span class="type">NSHomeDirectory</span>().stringByAppendingString(<span class="string">"/Documents/<span class="subst">\(filename)</span>"</span>)
    <span class="keyword">let</span> data = <span class="type">NSData</span>(contentsOfFile: path, options: .<span class="type">UncachedRead</span>, error: &amp;error)
    <span class="keyword">if</span> <span class="keyword">let</span> unwrappedError = error {
        <span class="keyword">return</span> <span class="literal">nil</span>
    } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="type">UIImage</span>(data: data!)
    }
}
</code></pre><p>代码很简单直接，下载的图片会存储在 <code>Documents</code> 目录下，如果没有检查到缓存文件， <code>getImage()</code> 方法则会返回 <code>nil</code> 。</p>
<p>然后在 <code>LibraryAPI.swift</code> 添加如下代码：</p>
<pre><code><span class="func"><span class="keyword">func</span> <span class="title">downloadImage</span><span class="params">(notification: NSNotification)</span></span> {
    <span class="comment">//1</span>
    <span class="keyword">let</span> userInfo = notification.userInfo <span class="keyword">as</span> [<span class="type">String</span>: <span class="type">AnyObject</span>]
    <span class="keyword">var</span> imageView = userInfo[<span class="string">"imageView"</span>] <span class="keyword">as</span> <span class="type">UIImageView</span>?
    <span class="keyword">let</span> coverUrl = userInfo[<span class="string">"coverUrl"</span>] <span class="keyword">as</span> <span class="type">NSString</span>

    <span class="comment">//2</span>
    <span class="keyword">if</span> <span class="keyword">let</span> imageViewUnWrapped = imageView {
        imageViewUnWrapped.image = persistencyManager.getImage(coverUrl.lastPathComponent)
        <span class="keyword">if</span> imageViewUnWrapped.image == <span class="literal">nil</span> {
            <span class="comment">//3</span>
            dispatch_async(dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>), { () -&gt; <span class="type">Void</span> <span class="keyword">in</span>
                <span class="keyword">let</span> downloadedImage = <span class="keyword">self</span>.httpClient.downloadImage(coverUrl)
                <span class="comment">//4</span>
                dispatch_sync(dispatch_get_main_queue(), { () -&gt; <span class="type">Void</span> <span class="keyword">in</span>
                    imageViewUnWrapped.image = downloadedImage
                    <span class="keyword">self</span>.persistencyManager.saveImage(downloadedImage, filename: coverUrl.lastPathComponent)
                })
            })
        }
    }
}
</code></pre><p>拆解一下上面的代码：</p>
<ul>
<li><code>downloadImage</code> 通过通知调用，所以这个方法的参数就是 <code>NSNotification</code> 本身。 <code>UIImageView</code> 和 <code>URL</code> 都可以从其中获取到。</li>
<li>如果以前下载过，从 <code>PersistencyManager</code> 里获取缓存。</li>
<li>如果图片没有缓存，则通过 <code>HTTPClient</code> 获取。</li>
<li>如果下载完成，展示图片并用 <code>PersistencyManager</code> 存储到本地。</li>
</ul>
<p>再回顾一下，我们使用外观模式隐藏了下载图片的复杂程度。通知的发送者并不在乎图片是如何从网上下载到本地的。</p>
<p>运行一下项目，可以看到专辑封面已经显示出来了：</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/11/swiftDesignPattern13-288x320.png" alt=""></p>
<p>关了应用再重新运行，注意这次没有任何延时就显示了所有的图片，因为我们已经有了本地缓存。我们甚至可以在没有网络的情况下正常使用我们的应用。不过出了问题：这个用来提示加载网络请求的小菊花怎么一直在显示！</p>
<p>我们在下载图片的时候开启了这个白色小菊花，但是在图片下载完毕的时候我们并没有停掉它。我们可以在每次下载成功的时候发送一个通知，但是我们不这样做，这次我们来用用另一个观察者模式： KVO 。</p>
<h3 id="键值观察_-_KVO">键值观察 - KVO</h3><p>在 KVO 里，对象可以注册监听任何属性的变化，不管它是否持有。如果感兴趣的话，可以读一读<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html" target="_blank" rel="external">苹果 KVO 编程指南</a>。</p>
<h4 id="如何使用_KVO">如何使用 KVO</h4><p>正如前面所提及的， 对象可以关注任何属性的变化。在我们的例子里，我们可以用 KVO 关注 <code>UIImageView</code> 的 <code>image</code> 属性变化。</p>
<p>打开 <code>AlbumView.swift</code> 文件，找到 <code>init(frame:albumCover:)</code> 方法，在把 <code>coverImage</code> 添加到 <code>subView</code> 的代码后面添加如下代码：</p>
<pre><code>coverImage.addObserver(<span class="keyword">self</span>, <span class="symbol">forKeyPath:</span> <span class="string">"image"</span>, <span class="symbol">options:</span> <span class="keyword">nil</span>, <span class="symbol">context:</span> <span class="keyword">nil</span>)
</code></pre><p>这行代码把 <code>self</code> (也就是当前类) 添加到了 <code>coverImage</code> 的 <code>image</code> 属性的观察者里。</p>
<p>在销毁的时候，我们也需要取消观察。还是在 <code>AlbumView.swift</code> 文件里，添加如下代码：</p>
<pre><code>deinit {
    coverImage.removeObserver(<span class="literal">self</span>, <span class="keyword">for</span>KeyPath: <span class="string">"image"</span>)
}
</code></pre><p>最终添加如下方法：</p>
<pre><code><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">observeValueForKeyPath</span><span class="params">(keyPath: String, ofObject object: AnyObject, change: [NSObject : AnyObject], context: UnsafeMutablePointer&lt;Void&gt;)</span></span> {
    <span class="keyword">if</span> keyPath == <span class="string">"image"</span> {
        indicator.stopAnimating()
    }
}
</code></pre><p>必须在所有的观察者里实现上面的代码。在检测到属性变化的时候，系统会自动调用这个方法。在上面的代码里，我们在图片加载完成的时候把那个提示加载的小菊花去掉了。</p>
<p>再次运行项目，你会发现一切正常了：</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/11/swiftDesignPattern14-292x320.png" alt=""></p>
<p>注意：一定要记得移除观察者，否则如果对象已经销毁了还给它发送消息会导致应用崩溃。</p>
<p>此时你可以把玩一下当前的应用然后再关掉它，你会发现你的应用的状态并没有存储下来。最后看见的专辑并不会再下次打开应用的时候出现。</p>
<p>为了解决这个问题，我们可以使用下一种模式：备忘录模式。</p>
<h2 id="备忘录模式_-_Memento">备忘录模式 - Memento</h2><p>备忘录模式捕捉并且具象化一个对象的内在状态。换句话说，它把你的对象存在了某个地方，然后在以后的某个时间再把它恢复出来，而不会打破它本身的封装性，私有数据依旧是私有数据。 </p>
<h3 id="如何使用备忘录模式">如何使用备忘录模式</h3><p>在 <code>ViewController.swift</code> 里加上下面两个方法：</p>
<pre><code><span class="comment">//MARK: Memento Pattern</span>
<span class="func"><span class="keyword">func</span> <span class="title">saveCurrentState</span><span class="params">()</span></span> {
    <span class="comment">// When the user leaves the app and then comes back again, he wants it to be in the exact same state</span>
    <span class="comment">// he left it. In order to do this we need to save the currently displayed album.</span>
    <span class="comment">// Since it's only one piece of information we can use NSUserDefaults.</span>
    <span class="type">NSUserDefaults</span>.standardUserDefaults().setInteger(currentAlbumIndex, forKey: <span class="string">"currentAlbumIndex"</span>)
}

<span class="func"><span class="keyword">func</span> <span class="title">loadPreviousState</span><span class="params">()</span></span> {
    currentAlbumIndex = <span class="type">NSUserDefaults</span>.standardUserDefaults().integerForKey(<span class="string">"currentAlbumIndex"</span>)
    showDataForAlbum(currentAlbumIndex)
}
</code></pre><p><code>saveCurrentState</code> 把当前相册的索引值存到 <code>NSUserDefaults</code> 里。<code>NSUserDefaults</code> 是 iOS 提供的一个标准存储方案，用于保存应用的配置信息和数据。</p>
<p><code>loadPreviousState</code> 方法加载上次存储的索引值。这并不是备忘录模式的完整实现，但是已经离目标不远了。</p>
<p>接下来在 <code>viewDidLoad</code> 的 <code>scroller.delegate = self</code> 前面调用：</p>
<pre><code><span class="function"><span class="title">loadPreviousState</span><span class="params">()</span></span>
</code></pre><p>这样在刚初始化的时候就加载了上次存储的状态。但是什么时候存储当前状态呢？这个时候我们可以用通知来做。在应用进入到后台的时候， iOS 会发送一个 <code>UIApplicationDidEnterBackgroundNotification</code> 的通知，我们可以在这个通知里调用 <code>saveCurrentState</code> 这个方法。是不是很方便？</p>
<p>在 <code>viewDidLoad</code> 的最后加上如下代码：</p>
<pre><code>NSNotificationCenter.<span class="function"><span class="title">defaultCenter</span><span class="params">()</span></span>.<span class="function"><span class="title">addObserver</span><span class="params">(self, selector:<span class="string">"saveCurrentState"</span>, name: UIApplicationDidEnterBackgroundNotification, object: nil)</span></span>
</code></pre><p>现在，当应用即将进入后台的时候，<code>ViewController</code> 会调用 <code>saveCurrentState</code> 方法自动存储当前状态。</p>
<p>当然也别忘了取消监听通知，添加如下代码：</p>
<pre><code>deinit {
    <span class="built_in">NSNotificationCenter</span><span class="variable">.defaultCenter</span>()<span class="variable">.removeObserver</span>(<span class="keyword">self</span>)
}
</code></pre><p>这样就确保在 <code>ViewController</code> 销毁的时候取消监听通知。</p>
<p>这时再运行程序，随意移到某个专辑上，然后按下 Home 键把应用切换到后台，再在 Xcode 上把 App 关闭。重新启动，会看见上次记录的专辑已经存了下来并成功还原了：</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/11/swiftDesignPattern15-202x320.png" alt=""></p>
<p>看起来专辑数据好像是对了，但是上面的滚动条似乎出了问题，没有居中啊！</p>
<p>这时 <code>initialViewIndex</code> 方法就派上用场了。由于在委托里 (也就是 <code>ViewController</code> ) 还没实现这个方法，所以初始化的结果总是第一张专辑。</p>
<p>为了修复这个问题，我们可以在 <code>ViewController.swift</code> 里添加如下代码：</p>
<pre><code><span class="func"><span class="keyword">func</span> <span class="title">initialViewIndex</span><span class="params">(scroller: HorizontalScroller)</span></span> -&gt; <span class="type">Int</span> {
    <span class="keyword">return</span> currentAlbumIndex
}
</code></pre><p>现在 <code>HorizontalScroller</code> 可以根据 <code>currentAlbumIndex</code> 自动滑到相应的索引位置了。</p>
<p>再次重复上次的步骤，切到后台，关闭应用，重启，一切顺利：</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/11/swiftDesignPattern16-230x320.png" alt=""></p>
<p>回头看看 <code>PersistencyManager</code> 的 <code>init</code> 方法，你会发现专辑数据是我们硬编码写进去的，而且每次创建 <code>PersistencyManager</code> 的时候都会再创建一次专辑数据。而实际上一个比较好的方案是只创建一次，然后把专辑数据存到本地文件里。我们如何把专辑数据存到文件里呢？</p>
<p>一种方案是遍历 <code>Album</code> 的属性然后把它们写到一个 <code>plist</code> 文件里，然后如果需要的时候再重新创建 <code>Album</code> 对象。这并不是最好的选择，因为数据和属性不同，你的代码也就要相应的产生变化。举个例子，如果我们以后想添加 <code>Movie</code> 对象，它有着完全不同的属性，那么存储和读取数据又需要重写新的代码。</p>
<p>况且你也无法存储这些对象的私有属性，因为其他类是没有访问权限的。这也就是为什么 Apple 提供了 归档 的机制。</p>
<h3 id="归档_-_Archiving">归档 - Archiving</h3><p>苹果通过归档的方法来实现备忘录模式。它把对象转化成了流然后在不暴露内部属性的情况下存储数据。你可以读一读 《iOS 6 by Tutorials》 这本书的第 16 章，或者看下<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Archiving/Archiving.html" target="_blank" rel="external">苹果的归档和序列化文档</a>。</p>
<h4 id="如何使用归档">如何使用归档</h4><p>首先，我们需要让 <code>Album</code> 实现 <code>NSCoding</code> 协议，声明这个类是可被归档的。打开 <code>Album.swift</code> 在 <code>class</code> 那行后面加上 <code>NSCoding</code> ：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Album</span>: <span class="typename">NSObject</span>, <span class="typename">NSCoding {</span></span>
</code></pre><p>然后添加如下的两个方法：</p>
<pre><code><span class="keyword">required</span> <span class="keyword">init</span>(coder decoder: <span class="type">NSCoder</span>) {
    <span class="keyword">super</span>.<span class="keyword">init</span>()
    <span class="keyword">self</span>.title = decoder.decodeObjectForKey(<span class="string">"title"</span>) <span class="keyword">as</span> <span class="type">String</span>?
    <span class="keyword">self</span>.artist = decoder.decodeObjectForKey(<span class="string">"artist"</span>) <span class="keyword">as</span> <span class="type">String</span>?
    <span class="keyword">self</span>.genre = decoder.decodeObjectForKey(<span class="string">"genre"</span>) <span class="keyword">as</span> <span class="type">String</span>?
    <span class="keyword">self</span>.coverUrl = decoder.decodeObjectForKey(<span class="string">"cover_url"</span>) <span class="keyword">as</span> <span class="type">String</span>?
    <span class="keyword">self</span>.year = decoder.decodeObjectForKey(<span class="string">"year"</span>) <span class="keyword">as</span> <span class="type">String</span>?
}

<span class="func"><span class="keyword">func</span> <span class="title">encodeWithCoder</span><span class="params">(aCoder: NSCoder)</span></span> {
    aCoder.encodeObject(title, forKey: <span class="string">"title"</span>)
    aCoder.encodeObject(artist, forKey: <span class="string">"artist"</span>)
    aCoder.encodeObject(genre, forKey: <span class="string">"genre"</span>)
    aCoder.encodeObject(coverUrl, forKey: <span class="string">"cover_url"</span>)
    aCoder.encodeObject(year, forKey: <span class="string">"year"</span>)
}
</code></pre><p><code>encodeWithCoder</code> 方法是 <code>NSCoding</code> 的一部分，在被归档的时候调用。相对的， <code>init(coder:)</code> 方法则是用来解档的。很简单，很强大。</p>
<p>现在 <code>Album</code> 对象可以被归档了，添加一些代码来存储和加载 <code>Album</code> 数据。</p>
<p>在 <code>PersistencyManager.swift</code> 里添加如下代码：</p>
<pre><code><span class="title">func</span> saveAlbums() {
    var filename = <span class="type">NSHomeDirectory</span>().stringByAppendingString(<span class="string">"/Documents/albums.bin"</span>)
    <span class="keyword">let</span> <span class="typedef"><span class="keyword">data</span> = <span class="type">NSKeyedArchiver</span>.archivedDataWithRootObject<span class="container">(<span class="title">albums</span>)</span></span>
    <span class="typedef"><span class="keyword">data</span>.writeToFile<span class="container">(<span class="title">filename</span>, <span class="title">atomically</span>: <span class="title">true</span>)</span></span>
} 
</code></pre><p>这个方法可以用来存储专辑。 <code>NSKeyedArchiver</code> 把专辑数组归档到了 <code>albums.bin</code> 这个文件里。</p>
<p>当我们归档一个包含子对象的对象时，系统会自动递归的归档子对象，然后是子对象的子对象，这样一层层递归下去。在我们的例子里，我们归档的是 <code>albums</code> 因为 <code>Array</code> 和 <code>Album</code> 都是实现 <code>NSCopying</code> 接口的，所以数组里的对象都可以自动归档。</p>
<p>用下面的代码取代 <code>PersistencyManager</code> 中的 <code>init</code> 方法：</p>
<pre><code><span class="keyword">override</span> <span class="keyword">init</span>() {
    <span class="keyword">super</span>.<span class="keyword">init</span>()
    <span class="keyword">if</span> <span class="keyword">let</span> data = <span class="type">NSData</span>(contentsOfFile: <span class="type">NSHomeDirectory</span>().stringByAppendingString(<span class="string">"/Documents/albums.bin"</span>)) {
        <span class="keyword">let</span> unarchiveAlbums = <span class="type">NSKeyedUnarchiver</span>.unarchiveObjectWithData(data) <span class="keyword">as</span> [<span class="type">Album</span>]?
        <span class="keyword">if</span> <span class="keyword">let</span> unwrappedAlbum = unarchiveAlbums {
            albums = unwrappedAlbum
        }
    } <span class="keyword">else</span> {
        createPlaceholderAlbum()
    }
}

<span class="func"><span class="keyword">func</span> <span class="title">createPlaceholderAlbum</span><span class="params">()</span></span> {
    <span class="comment">//Dummy list of albums</span>
    <span class="keyword">let</span> album1 = <span class="type">Album</span>(title: <span class="string">"Best of Bowie"</span>,
             artist: <span class="string">"David Bowie"</span>,
             genre: <span class="string">"Pop"</span>,
             coverUrl: <span class="string">"http://www.coversproject.com/static/thumbs/album/album_david%20bowie_best%20of%20bowie.png"</span>,
             year: <span class="string">"1992"</span>)

    <span class="keyword">let</span> album2 = <span class="type">Album</span>(title: <span class="string">"It's My Life"</span>,
           artist: <span class="string">"No Doubt"</span>,
           genre: <span class="string">"Pop"</span>,
           coverUrl: <span class="string">"http://www.coversproject.com/static/thumbs/album/album_no%20doubt_its%20my%20life%20%20bathwater.png"</span>,
           year: <span class="string">"2003"</span>)

    <span class="keyword">let</span> album3 = <span class="type">Album</span>(title: <span class="string">"Nothing Like The Sun"</span>,
               artist: <span class="string">"Sting"</span>,
           genre: <span class="string">"Pop"</span>,
           coverUrl: <span class="string">"http://www.coversproject.com/static/thumbs/album/album_sting_nothing%20like%20the%20sun.png"</span>,
           year: <span class="string">"1999"</span>)

    <span class="keyword">let</span> album4 = <span class="type">Album</span>(title: <span class="string">"Staring at the Sun"</span>,
           artist: <span class="string">"U2"</span>,
           genre: <span class="string">"Pop"</span>,
           coverUrl: <span class="string">"http://www.coversproject.com/static/thumbs/album/album_u2_staring%20at%20the%20sun.png"</span>,
           year: <span class="string">"2000"</span>)

    <span class="keyword">let</span> album5 = <span class="type">Album</span>(title: <span class="string">"American Pie"</span>,
           artist: <span class="string">"Madonna"</span>,
           genre: <span class="string">"Pop"</span>,
           coverUrl: <span class="string">"http://www.coversproject.com/static/thumbs/album/album_madonna_american%20pie.png"</span>,
           year: <span class="string">"2000"</span>)
    albums = [album1, album2, album3, album4, album5]
    saveAlbums()
}
</code></pre><p>我们把创建专辑数据的方法放到了 <code>createPlaceholderAlbum</code> 里，这样代码可读性更高。在新的代码里，如果存在归档文件， <code>NSKeyedUnarchiver</code> 从归档文件加载数据；否则就创建归档文件，这样下次程序启动的时候可以读取本地文件加载数据。</p>
<p>我们还想在每次程序进入后台的时候存储专辑数据。看起来现在这个功能并不是必须的，但是如果以后我们加了编辑功能，这样做还是很有必要的，那时我们肯定希望确保新的数据会同步到本地的归档文件。</p>
<p>因为我们的程序通过 <code>LibraryAPI</code> 来访问所有服务，所以我们需要通过 <code>LibraryAPI</code> 来通知 <code>PersistencyManager</code> 存储专辑数据。</p>
<p>在 <code>LibraryAPI</code> 里添加存储专辑数据的方法：</p>
<pre><code><span class="function"><span class="keyword">func</span> <span class="title">saveAlbums</span><span class="params">()</span> {</span>
    persistencyManager.saveAlbums()
}
</code></pre><p>这个方法很简单，就是把 <code>LibraryAPI</code> 的 <code>saveAlbums</code> 方法传递给了 <code>persistencyManager</code> 的 <code>saveAlbums</code> 方法。</p>
<p>然后在 <code>ViewController.swift</code> 的 <code>saveCurrentState</code> 方法的最后加上：</p>
<pre><code>LibraryAPI<span class="class">.sharedInstance</span><span class="class">.saveAlbums</span>()
</code></pre><p>在 <code>ViewController</code> 需要存储状态的时候，上面的代码通过 <code>LibraryAPI</code> 归档当前的专辑数据。</p>
<p>运行一下程序，检查一下没有编译错误。</p>
<p>不幸的是似乎没什么简单的方法来检查归档是否正确完成。你可以检查一下 <code>Documents</code> 目录，看下是否存在归档文件。如果要查看其他数据变化的话，还需要添加编辑专辑数据的功能。</p>
<p>不过和编辑数据相比，似乎加个删除专辑的功能更好一点，如果不想要这张专辑直接删除即可。再进一步，万一误删了话，是不是还可以再加个撤销按钮？</p>
<h2 id="最后的润色">最后的润色</h2><p>现在我们将添加最后一个功能：允许用户删除专辑，以及撤销上次的删除操作。</p>
<p>在 <code>ViewController</code> 里添加如下属性：</p>
<pre><code><span class="comment">// 为了实现撤销功能，我们用数组作为一个栈来 push 和 pop 用户的操作</span>
<span class="variable"><span class="keyword">var</span> undoStack</span>: [(Album, <span class="typename">Int</span>)] = []
</code></pre><p>然后在 <code>viewDidLoad</code> 的 <code>reloadScroller()</code> 后面添加如下代码：</p>
<pre><code>let undoButton = UIBarButtonItem(<span class="string">barButtonSystemItem:</span> .Undo, <span class="string">target:</span> self, <span class="string">action:</span><span class="string">"undoAction"</span>)
undoButton.enabled = <span class="literal">false</span>;
let space = UIBarButtonItem(<span class="string">barButtonSystemItem:</span> .FlexibleSpace, <span class="string">target:</span>nil, <span class="string">action:</span>nil)
let trashButton = UIBarButtonItem(<span class="string">barButtonSystemItem:</span> .Trash, <span class="string">target:</span>self, <span class="string">action:</span><span class="string">"deleteAlbum"</span>)
let toolbarButtonItems = [undoButton, space, trashButton]
toolbar.setItems(toolbarButtonItems, <span class="string">animated:</span> <span class="literal">true</span>)
</code></pre><p>上面的代码创建了一个 <code>toolbar</code> ，上面有两个按钮，在 <code>undoStack</code> 为空的情况下， <code>undo</code> 的按钮是不可用的。注意 <code>toolbar</code> 已经在 <code>storyboard</code> 里了，我们需要做的只是配置上面的按钮。</p>
<p>我们需要在 <code>ViewController.swift</code> 里添加三个方法，用来处理专辑的编辑事件：增加，删除，撤销。</p>
<p>先写添加的方法：</p>
<pre><code>func addAlbumAtIndex(album: Album,<span class="built_in">index</span>: <span class="built_in">Int</span>) {
    LibraryAPI.sharedInstance.addAlbum(album, <span class="built_in">index</span>: <span class="built_in">index</span>)
    currentAlbumIndex = <span class="built_in">index</span>
    reloadScroller()
}
</code></pre><p>做了三件事：添加专辑，设为当前的索引，重新加载滚动条。</p>
<p>接下来是删除方法：</p>
<pre><code><span class="func"><span class="keyword">func</span> <span class="title">deleteAlbum</span><span class="params">()</span></span> {
    <span class="comment">//1</span>
    <span class="keyword">var</span> deletedAlbum : <span class="type">Album</span> = allAlbums[currentAlbumIndex]
    <span class="comment">//2</span>
    <span class="keyword">var</span> undoAction = (deletedAlbum, currentAlbumIndex)
    undoStack.insert(undoAction, atIndex: <span class="number">0</span>)
    <span class="comment">//3</span>
    <span class="type">LibraryAPI</span>.sharedInstance.deleteAlbum(currentAlbumIndex)
    reloadScroller()
    <span class="comment">//4</span>
    <span class="keyword">let</span> barButtonItems = toolbar.items <span class="keyword">as</span> [<span class="type">UIBarButtonItem</span>]
    <span class="keyword">var</span> undoButton : <span class="type">UIBarButtonItem</span> = barButtonItems[<span class="number">0</span>]
    undoButton.enabled = <span class="literal">true</span>
    <span class="comment">//5</span>
    <span class="keyword">if</span> (allAlbums.<span class="built_in">count</span> == <span class="number">0</span>) {
        <span class="keyword">var</span> trashButton : <span class="type">UIBarButtonItem</span> = barButtonItems[<span class="number">2</span>]
        trashButton.enabled = <span class="literal">false</span>
    }
}
</code></pre><p>挨个看一下各个部分：</p>
<ul>
<li>获取要删除的专辑。</li>
<li>创建一个 <code>undoAction</code> 对象，用元组存储 <code>Album</code> 对象和它的索引值。然后把这个元组加到了栈里。</li>
<li>使用 <code>LibraryAPI</code> 删除专辑数据，然后重新加载滚动条。</li>
<li>既然撤销栈里已经有了数据，那么我们需要设置撤销按钮为可用。</li>
<li>检查一下是不是还剩专辑，如果没有专辑了那就设置删除按钮为不可用。</li>
</ul>
<p>最后添加撤销按钮：</p>
<pre><code><span class="func"><span class="keyword">func</span> <span class="title">undoAction</span><span class="params">()</span></span> {
    <span class="keyword">let</span> barButtonItems = toolbar.items <span class="keyword">as</span> [<span class="type">UIBarButtonItem</span>]
    <span class="comment">//1       </span>
    <span class="keyword">if</span> undoStack.<span class="built_in">count</span> &gt; <span class="number">0</span> {
        <span class="keyword">let</span> (deletedAlbum, index) = undoStack.removeAtIndex(<span class="number">0</span>)
        addAlbumAtIndex(deletedAlbum, index: index)
    }
    <span class="comment">//2       </span>
    <span class="keyword">if</span> undoStack.<span class="built_in">count</span> == <span class="number">0</span> {
        <span class="keyword">var</span> undoButton : <span class="type">UIBarButtonItem</span> = barButtonItems[<span class="number">0</span>]
        undoButton.enabled = <span class="literal">false</span>
    }
    <span class="comment">//3       </span>
    <span class="keyword">let</span> trashButton : <span class="type">UIBarButtonItem</span> = barButtonItems[<span class="number">2</span>]
    trashButton.enabled = <span class="literal">true</span>
}
</code></pre><p>照着备注的三个步骤再看一下撤销方法里的代码：</p>
<ul>
<li>首先从栈里 <code>pop</code> 出一个对象，这个对象就是我们当初塞进去的元祖，存有删除的 <code>Album</code> 对象和它的索引位置。然后我们把取出来的对象放回了数据源里。</li>
<li>因为我们从栈里删除了一个对象，所以需要检查一下看看栈是不是空了。如果空了那就设置撤销按钮不可用。</li>
<li>既然我们已经撤消了一个专辑，那删除按钮肯定是可用的。所以把它设置为 <code>enabled</code> 。</li>
</ul>
<p>这时再运行应用，试试删除和插销功能，似乎一切正常了：</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/11/swiftDesignPattern1-179x320.png" alt=""></p>
<p>我们也可以趁机测试一下，看看是否及时存储了专辑数据的变化。比如删除一个专辑，然后切到后台，强关应用，再重新开启，看看是不是删除操作成功保存了。</p>
<p>如果想要恢复所有数据，删除应用然后重新安装即可。</p>
<h2 id="小结">小结</h2><p>最终项目的源代码可以在 <a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/12/BlueLibrarySwift-Final.zip" target="_blank" rel="external">BlueLibrarySwift-Final</a> 下载。</p>
<p>通过这两篇设计模式的学习，我们接触到了一些基础的设计模式和概念：Singleton、MVC、Delegation、Protocols、Facade、Observer、Memento 。</p>
<p>这篇文章的目的，并不是推崇每行代码都要用设计模式，而是希望大家在考虑一些问题的时候，可以参考设计模式提出一些合理的解决方案，尤其是应用开发的起始阶段，思考和设计尤为重要。</p>
<p>如果想继续深入学习设计模式，推荐设计模式的经典书籍：<a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/" target="_blank" rel="external">Design Patterns: Elements of Reusable Object-Oriented Software</a>。</p>
<p>如果想看更多的设计模式相关的代码，推荐这个神奇的项目： <a href="https://github.com/ochococo/Design-Patterns-In-Swift" target="_blank" rel="external">Swift 实现的种种设计模式</a>。</p>
<p>接下来你可以看看这篇：<a href="http://www.raywenderlich.com/86053/intermediate-design-patterns-in-swift" target="_blank" rel="external">Swift 设计模式中级指南</a>，学习更多的设计模式。</p>
<p>玩的开心。 :]</p>
<hr>
<p>原文链接：</p>
<ul>
<li><a href="http://www.raywenderlich.com/90773/introducing-ios-design-patterns-in-swift-part-2" target="_blank" rel="external">Introducing iOS Design Patterns in Swift – Part 2/2</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[设计模式系列教程翻译 之 再续前缘。]]>
    
    </summary>
    
      <category term="Swift" scheme="http://blog.callmewhy.com/tags/Swift/"/>
    
      <category term="翻译笔记" scheme="http://blog.callmewhy.com/categories/%E7%BF%BB%E8%AF%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
